using System;
using System.Xml.Linq;
using Exolutio.Model.OCL;
using Exolutio.Model.OCL.AST;
using Exolutio.Model.OCL.Bridge;
using Exolutio.SupportingClasses;

namespace Exolutio.Model.PSM.Grammar.SchematronTranslation
{
    public class SchematronSchemaGenerator
    {
        private PSMSchema psmSchema;

        public PSMSchema PSMSchema
        {
            get { return psmSchema; }
        }

        public Log<OclExpression> Log { get; private set; }

        public void Initialize(PSMSchema psmSchema)
        {
            this.psmSchema = psmSchema;
            Log = new Log<OclExpression>();
        }

        public XDocument GetSchematronSchema()
        {
            XDocument doc = new XDocument(new XDeclaration("1.0", "utf-8", null));
            XElement schSchema = doc.SchematronSchema();
            XComment comment = new XComment(string.Format(" Generated by eXolutio on {0} {1} from {2}/{3}. ", DateTime.Now.ToShortDateString(), DateTime.Now.ToShortTimeString(), PSMSchema.Project.Name, PSMSchema.Caption));
            schSchema.Add(comment);

            foreach (OCLScript oclScript in PSMSchema.OCLScripts)
            {
                TranslateScript(schSchema, oclScript);
            }

            return doc;
        }

        private void TranslateScript(XElement schSchema, OCLScript oclScript)
        {
            XElement patternElement = schSchema.SchematronPattern();

            CompilerResult compilerResult = oclScript.CompileToAst();
            if (!compilerResult.Errors.HasError)
            {
                XComment comment = new XComment(string.Format("Below follow constraints from OCL script '{0}'. ", oclScript.Name));
                patternElement.Add(comment);
                foreach (ClassifierConstraint constraint in compilerResult.Constraints.Classifiers)
                {
                    PSMAssociationMember contextNode = (PSMAssociationMember)constraint.Context.Tag;
                    XElement ruleElement = patternElement.SchematronRule(contextNode.XPath);                    
                    foreach (OclExpression invariant in constraint.Invariants)
                    {
                        string xpath = TranslateInvariantToXPath(oclScript, constraint, compilerResult.Bridge, invariant);
                        try
                        {
                            ruleElement.Add(new XComment(invariant.ToString()));
                            XElement assertElement = ruleElement.SchematronAssert(xpath);
                        }
                        catch
                        {
                            ruleElement.Add(new XComment("Translation of the constraint failed. "));
                        }
                    }
                }
            }
            else
            {
                XComment comment = new XComment(string.Format("OCL script '{0}' contains errors and thus can not be translated. ", oclScript.Name));
                patternElement.Add(comment);
            }
        }

        private string TranslateInvariantToXPath(OCLScript oclScript, ClassifierConstraint constraint, IBridgeToOCL bridge, OclExpression invariant)
        {
            PSMOCLtoXPathConverter xpathConverter = new PSMOCLtoXPathConverter();
            xpathConverter.OCLScript = oclScript;
            xpathConverter.Bridge = (PSMBridge) bridge;
            xpathConverter.OclContext = constraint;
            xpathConverter.Log = Log;
            string invariantStr = xpathConverter.TranslateExpression(invariant);

            return invariantStr;

        }
    }
}
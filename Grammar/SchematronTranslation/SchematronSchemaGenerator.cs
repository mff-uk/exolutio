using System;
using System.Collections.Generic;
using System.Xml.Linq;
using Exolutio.Model.OCL;
using Exolutio.Model.OCL.AST;
using Exolutio.Model.OCL.Bridge;
using Exolutio.SupportingClasses;
using Exolutio.SupportingClasses.Annotations;

namespace Exolutio.Model.PSM.Grammar.SchematronTranslation
{
    public class SchematronSchemaGenerator
    {
        public class TranslationSettings
        {
            public bool SchemaAware { get; set; }

            public bool Functional { get; set; }

            public bool Retranslation { get; set; }

            public SubexpressionTranslations SubexpressionTranslations { get; private set; }

            public TranslationSettings()
            {
                SubexpressionTranslations = new SubexpressionTranslations();
            }

            public TranslationSettings(bool schemaAware, bool functional) : this()
            {
                SchemaAware = schemaAware;
                Functional = functional;
            }
        }

        private PSMSchema psmSchema;

        public PSMSchema PSMSchema
        {
            get { return psmSchema; }
        }

        public Log<OclExpression> Log { get; private set; }

        public void Initialize(PSMSchema psmSchema)
        {
            this.psmSchema = psmSchema;
            Log = new Log<OclExpression>();
        }

        public XDocument GetSchematronSchema([NotNull]TranslationSettings translationSettings)
        {
            XDocument doc = new XDocument(new XDeclaration("1.0", "utf-8", null));
            XElement schSchema = doc.SchematronSchema();
            XComment comment = new XComment(string.Format(" Generated by eXolutio on {0} {1} from {2}/{3}. ", DateTime.Now.ToShortDateString(), DateTime.Now.ToShortTimeString(), PSMSchema.Project.Name, PSMSchema.Caption));
            schSchema.Add(comment);

            foreach (OCLScript oclScript in PSMSchema.OCLScripts)
            {
                TranslateScript(schSchema, oclScript, translationSettings);
            }

            foreach (LogMessage<OclExpression> e in Log)
            {
                if (e.Tag != null && e.Tag.CodeSource != null && e.Tag.CodeSource.IsFromCode)
                {
                    e.MessageText += System.Environment.NewLine + string.Format("Expression: > {0} <", e.Tag);
                    e.Column = e.Tag.CodeSource.Column;
                    e.Line = e.Tag.CodeSource.Line;
                }
            }

            return doc;
        }

        private void TranslateScript(XElement schSchema, OCLScript oclScript, TranslationSettings translationSettings)
        {
            XElement patternElement = schSchema.SchematronPattern(oclScript.Name);

            CompilerResult compilerResult = oclScript.CompileToAst();
            if (!compilerResult.Errors.HasError)
            {
                XComment comment = new XComment(string.Format("Below follow constraints from OCL script '{0}'. ", oclScript.Name));
                patternElement.Add(comment);
                foreach (ClassifierConstraint constraint in compilerResult.Constraints.Classifiers)
                {
                    PSMAssociationMember contextNode = (PSMAssociationMember)constraint.Context.Tag;
                    XElement ruleElement = patternElement.SchematronRule(contextNode.XPath);
                    if (constraint.Self.Name != @"self")
                    {
                        XElement contextVarElement = new XElement((XNamespace)("http://eXolutio.com/oclX") + "context-variable");
                        contextVarElement.AddAttributeWithValue("name", constraint.Self.Name);
                        ruleElement.Add(contextVarElement);    
                    }                    
                    
                    foreach (OclExpression invariant in constraint.Invariants)
                    {
                        string xpath = TranslateInvariantToXPath(oclScript, constraint, compilerResult.Bridge, invariant, translationSettings);

                        try
                        {
                            ruleElement.Add(new XComment(invariant.ToString()));
                            XElement assertElement = ruleElement.SchematronAssert(xpath);
                        }
                        catch
                        {
                            ruleElement.Add(new XComment("Translation of the constraint failed. "));
                        }
                    }
                }
            }
            else
            {
                XComment comment = new XComment(string.Format("OCL script '{0}' contains errors and thus can not be translated. ", oclScript.Name));
                patternElement.Add(comment);
            }
        }

        private string TranslateInvariantToXPath(OCLScript oclScript, ClassifierConstraint constraint, IBridgeToOCL bridge, OclExpression invariant, TranslationSettings translationSettings)
        {
            PSMOCLtoXPathConverter xpathConverter = translationSettings.Functional ? 
                (PSMOCLtoXPathConverter) new PSMOCLtoXPathConverterFunctional() : 
                (PSMOCLtoXPathConverter) new PSMOCLtoXPathConverterDynamic();
            xpathConverter.OCLScript = oclScript;
            xpathConverter.Bridge = (PSMBridge) bridge;
            xpathConverter.OclContext = constraint;
            xpathConverter.Log = Log;
            xpathConverter.Settings = translationSettings;
            if (!translationSettings.Retranslation)
            {
                try
                {
                    string invariantStr = xpathConverter.TranslateExpression(invariant);
                    translationSettings.SubexpressionTranslations.Merge(xpathConverter.SubexpressionTranslations);
                    return invariantStr;
                }
                catch (ExpressionNotSupportedInXPath e)
                {
                    Log.AddError(e.Message, e.Expression);
                }
                catch
                {
                    Log.AddError("Unable to translate invariant. ", invariant);
                }
            }
            else
            {
                try
                {
                    string invariantStr = xpathConverter.TranslateExpression(invariant);
                    foreach (OclExpression translatedExp in translationSettings.SubexpressionTranslations.Translations.Keys)
                    {
                        if (translatedExp.ToString() == invariant.ToString())
                        {
                            return translationSettings.SubexpressionTranslations.GetSubexpressionTranslation(translatedExp).GetString(true);
                        }
                    }
                    
                    //return translationSettings.SubexpressionTranslations.GetSubexpressionTranslation(invariant).GetString();
                }
                catch (ExpressionNotSupportedInXPath e)
                {
                    Log.AddError(e.Message, e.Expression);
                }
                catch
                {
                    Log.AddError("Unable to translate invariant. ", invariant);
                }
            }
            return "### ERROR";
        }
    }
}
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.3.1.7705
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.3.1.7705 ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3 2011-09-22 16:41:14

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162


using System.Collections.Generic;
using Antlr.Runtime;


using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;

namespace Exolutio.Model.OCL.Compiler
{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.3.1.7705")]
[System.CLSCompliant(false)]
public partial class OCLSyntaxParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "BooleanLiteralExp", "CALL", "CALLARGS", "COLLECTIONLITERAL", "COLLECTIONTYPE", "COLLPART", "COLLTYPE", "Char", "DECL", "EscapeSequence", "ExponentPart", "Hex", "INDEX", "INFIX", "ITERATE", "IntegerLiteralExp", "InvalidLiteralExp", "LET", "LINE_COMMENT", "MESSAGE", "NESTED_ML_COMMENT", "NameChar", "NameStartChar", "NullLiteralExp", "Num", "PATH", "PRIMITIVELITERAL", "RealLiteralExp", "SimpleName", "StringChar", "StringLiteralExp", "TUPLELITERAL", "TYPE", "UNARY", "UnlimitedNaturalLiteralExp", "VARDECL", "WS", "WhiteSpaceChar", "'('", "')'", "'+'", "','", "'-'", "'->'", "'.'", "'..'", "'/'", "':'", "'::'", "';'", "'<'", "'<='", "'<>'", "'='", "'>'", "'>='", "'?'", "'@'", "'Bag'", "'Boolean'", "'Collection'", "'Integer'", "'OclAny'", "'OclInvalid'", "'OclMessage'", "'OclVoid'", "'OrderedSet'", "'Real'", "'Sequence'", "'Set'", "'String'", "'Tuple'", "'UnlimitedNatural'", "'['", "']'", "'^'", "'^^'", "'and'", "'body'", "'context'", "'def'", "'derivate'", "'else'", "'endif'", "'if'", "'implies'", "'in'", "'init'", "'inv'", "'iterate'", "'let'", "'not'", "'or'", "'post'", "'pre'", "'static'", "'then'", "'xor'", "'{'", "'|'", "'}'"
	};
	public const int EOF=-1;
	public const int BooleanLiteralExp=4;
	public const int CALL=5;
	public const int CALLARGS=6;
	public const int COLLECTIONLITERAL=7;
	public const int COLLECTIONTYPE=8;
	public const int COLLPART=9;
	public const int COLLTYPE=10;
	public const int Char=11;
	public const int DECL=12;
	public const int EscapeSequence=13;
	public const int ExponentPart=14;
	public const int Hex=15;
	public const int INDEX=16;
	public const int INFIX=17;
	public const int ITERATE=18;
	public const int IntegerLiteralExp=19;
	public const int InvalidLiteralExp=20;
	public const int LET=21;
	public const int LINE_COMMENT=22;
	public const int MESSAGE=23;
	public const int NESTED_ML_COMMENT=24;
	public const int NameChar=25;
	public const int NameStartChar=26;
	public const int NullLiteralExp=27;
	public const int Num=28;
	public const int PATH=29;
	public const int PRIMITIVELITERAL=30;
	public const int RealLiteralExp=31;
	public const int SimpleName=32;
	public const int StringChar=33;
	public const int StringLiteralExp=34;
	public const int TUPLELITERAL=35;
	public const int TYPE=36;
	public const int UNARY=37;
	public const int UnlimitedNaturalLiteralExp=38;
	public const int VARDECL=39;
	public const int WS=40;
	public const int WhiteSpaceChar=41;
	public const int T__42=42;
	public const int T__43=43;
	public const int T__44=44;
	public const int T__45=45;
	public const int T__46=46;
	public const int T__47=47;
	public const int T__48=48;
	public const int T__49=49;
	public const int T__50=50;
	public const int T__51=51;
	public const int T__52=52;
	public const int T__53=53;
	public const int T__54=54;
	public const int T__55=55;
	public const int T__56=56;
	public const int T__57=57;
	public const int T__58=58;
	public const int T__59=59;
	public const int T__60=60;
	public const int T__61=61;
	public const int T__62=62;
	public const int T__63=63;
	public const int T__64=64;
	public const int T__65=65;
	public const int T__66=66;
	public const int T__67=67;
	public const int T__68=68;
	public const int T__69=69;
	public const int T__70=70;
	public const int T__71=71;
	public const int T__72=72;
	public const int T__73=73;
	public const int T__74=74;
	public const int T__75=75;
	public const int T__76=76;
	public const int T__77=77;
	public const int T__78=78;
	public const int T__79=79;
	public const int T__80=80;
	public const int T__81=81;
	public const int T__82=82;
	public const int T__83=83;
	public const int T__84=84;
	public const int T__85=85;
	public const int T__86=86;
	public const int T__87=87;
	public const int T__88=88;
	public const int T__89=89;
	public const int T__90=90;
	public const int T__91=91;
	public const int T__92=92;
	public const int T__93=93;
	public const int T__94=94;
	public const int T__95=95;
	public const int T__96=96;
	public const int T__97=97;
	public const int T__98=98;
	public const int T__99=99;
	public const int T__100=100;
	public const int T__101=101;
	public const int T__102=102;
	public const int T__103=103;
	public const int T__104=104;

	// delegates
	// delegators

	public OCLSyntaxParser( ITokenStream input )
		: this( input, new RecognizerSharedState() )
	{
	}
	public OCLSyntaxParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		ITreeAdaptor treeAdaptor = default(ITreeAdaptor);
		CreateTreeAdaptor(ref treeAdaptor);

		TreeAdaptor = treeAdaptor ?? new CommonTreeAdaptor();


		OnCreated();
	}
		
	// Implement this function in your helper file to use a custom tree adaptor
	partial void CreateTreeAdaptor(ref ITreeAdaptor adaptor);

	private ITreeAdaptor adaptor;

	public ITreeAdaptor TreeAdaptor
	{
		get
		{
			return adaptor;
		}

		set
		{
			this.adaptor = value;
		}
	}

	public override string[] TokenNames { get { return OCLSyntaxParser.tokenNames; } }
	public override string GrammarFileName { get { return "..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	public sealed partial class contextDeclarationList_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public contextDeclarationList_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_contextDeclarationList();
	partial void LeaveRule_contextDeclarationList();

	// $ANTLR start "contextDeclarationList"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:21:1: public contextDeclarationList : ( contextDeclaration )* ;
	[GrammarRule("contextDeclarationList")]
	public OCLSyntaxParser.contextDeclarationList_return contextDeclarationList()
	{
		EnterRule_contextDeclarationList();
		EnterRule("contextDeclarationList", 1);
		TraceIn("contextDeclarationList", 1);
		OCLSyntaxParser.contextDeclarationList_return retval = new OCLSyntaxParser.contextDeclarationList_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		OCLSyntaxParser.contextDeclaration_return contextDeclaration1 = default(OCLSyntaxParser.contextDeclaration_return);


		try { DebugEnterRule(GrammarFileName, "contextDeclarationList");
		DebugLocation(21, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:22:2: ( ( contextDeclaration )* )
			DebugEnterAlt(1);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:22:3: ( contextDeclaration )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(22, 3);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:22:3: ( contextDeclaration )*
			try { DebugEnterSubRule(1);
			while (true)
			{
				int alt1=2;
				try { DebugEnterDecision(1, false);
				int LA1_0 = input.LA(1);

				if ((LA1_0==83))
				{
					alt1 = 1;
				}


				} finally { DebugExitDecision(1); }
				switch ( alt1 )
				{
				case 1:
					DebugEnterAlt(1);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:22:3: contextDeclaration
					{
					DebugLocation(22, 3);
					PushFollow(Follow._contextDeclaration_in_contextDeclarationList105);
					contextDeclaration1=contextDeclaration();
					PopFollow();

					adaptor.AddChild(root_0, contextDeclaration1.Tree);

					}
					break;

				default:
					goto loop1;
				}
			}

			loop1:
				;

			} finally { DebugExitSubRule(1); }


			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("contextDeclarationList", 1);
			LeaveRule("contextDeclarationList", 1);
			LeaveRule_contextDeclarationList();
		}
		DebugLocation(23, 1);
		} finally { DebugExitRule(GrammarFileName, "contextDeclarationList"); }
		return retval;

	}
	// $ANTLR end "contextDeclarationList"

	public sealed partial class contextDeclaration_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public contextDeclaration_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_contextDeclaration();
	partial void LeaveRule_contextDeclaration();

	// $ANTLR start "contextDeclaration"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:26:1: public contextDeclaration : ( propertyContextDecl | classifierContextDecl | operationContextDecl );
	[GrammarRule("contextDeclaration")]
	public OCLSyntaxParser.contextDeclaration_return contextDeclaration()
	{
		EnterRule_contextDeclaration();
		EnterRule("contextDeclaration", 2);
		TraceIn("contextDeclaration", 2);
		OCLSyntaxParser.contextDeclaration_return retval = new OCLSyntaxParser.contextDeclaration_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		OCLSyntaxParser.propertyContextDecl_return propertyContextDecl2 = default(OCLSyntaxParser.propertyContextDecl_return);
		OCLSyntaxParser.classifierContextDecl_return classifierContextDecl3 = default(OCLSyntaxParser.classifierContextDecl_return);
		OCLSyntaxParser.operationContextDecl_return operationContextDecl4 = default(OCLSyntaxParser.operationContextDecl_return);


		try { DebugEnterRule(GrammarFileName, "contextDeclaration");
		DebugLocation(26, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:27:2: ( propertyContextDecl | classifierContextDecl | operationContextDecl )
			int alt2=3;
			try { DebugEnterDecision(2, false);
			try
			{
				alt2 = dfa2.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(2); }
			switch (alt2)
			{
			case 1:
				DebugEnterAlt(1);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:27:3: propertyContextDecl
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(27, 3);
				PushFollow(Follow._propertyContextDecl_in_contextDeclaration119);
				propertyContextDecl2=propertyContextDecl();
				PopFollow();

				adaptor.AddChild(root_0, propertyContextDecl2.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:28:3: classifierContextDecl
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(28, 3);
				PushFollow(Follow._classifierContextDecl_in_contextDeclaration123);
				classifierContextDecl3=classifierContextDecl();
				PopFollow();

				adaptor.AddChild(root_0, classifierContextDecl3.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:29:3: operationContextDecl
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(29, 3);
				PushFollow(Follow._operationContextDecl_in_contextDeclaration127);
				operationContextDecl4=operationContextDecl();
				PopFollow();

				adaptor.AddChild(root_0, operationContextDecl4.Tree);

				}
				break;

			}
			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("contextDeclaration", 2);
			LeaveRule("contextDeclaration", 2);
			LeaveRule_contextDeclaration();
		}
		DebugLocation(30, 1);
		} finally { DebugExitRule(GrammarFileName, "contextDeclaration"); }
		return retval;

	}
	// $ANTLR end "contextDeclaration"

	private sealed partial class propertyContextDecl_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public propertyContextDecl_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_propertyContextDecl();
	partial void LeaveRule_propertyContextDecl();

	// $ANTLR start "propertyContextDecl"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:32:1: propertyContextDecl : propertyContextHead ( initOrDerValue )* ;
	[GrammarRule("propertyContextDecl")]
	private OCLSyntaxParser.propertyContextDecl_return propertyContextDecl()
	{
		EnterRule_propertyContextDecl();
		EnterRule("propertyContextDecl", 3);
		TraceIn("propertyContextDecl", 3);
		OCLSyntaxParser.propertyContextDecl_return retval = new OCLSyntaxParser.propertyContextDecl_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		OCLSyntaxParser.propertyContextHead_return propertyContextHead5 = default(OCLSyntaxParser.propertyContextHead_return);
		OCLSyntaxParser.initOrDerValue_return initOrDerValue6 = default(OCLSyntaxParser.initOrDerValue_return);


		try { DebugEnterRule(GrammarFileName, "propertyContextDecl");
		DebugLocation(32, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:33:2: ( propertyContextHead ( initOrDerValue )* )
			DebugEnterAlt(1);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:33:3: propertyContextHead ( initOrDerValue )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(33, 3);
			PushFollow(Follow._propertyContextHead_in_propertyContextDecl137);
			propertyContextHead5=propertyContextHead();
			PopFollow();

			adaptor.AddChild(root_0, propertyContextHead5.Tree);
			DebugLocation(33, 23);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:33:23: ( initOrDerValue )*
			try { DebugEnterSubRule(3);
			while (true)
			{
				int alt3=2;
				try { DebugEnterDecision(3, false);
				int LA3_0 = input.LA(1);

				if ((LA3_0==85||LA3_0==91))
				{
					alt3 = 1;
				}


				} finally { DebugExitDecision(3); }
				switch ( alt3 )
				{
				case 1:
					DebugEnterAlt(1);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:33:23: initOrDerValue
					{
					DebugLocation(33, 23);
					PushFollow(Follow._initOrDerValue_in_propertyContextDecl139);
					initOrDerValue6=initOrDerValue();
					PopFollow();

					adaptor.AddChild(root_0, initOrDerValue6.Tree);

					}
					break;

				default:
					goto loop3;
				}
			}

			loop3:
				;

			} finally { DebugExitSubRule(3); }


			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("propertyContextDecl", 3);
			LeaveRule("propertyContextDecl", 3);
			LeaveRule_propertyContextDecl();
		}
		DebugLocation(34, 1);
		} finally { DebugExitRule(GrammarFileName, "propertyContextDecl"); }
		return retval;

	}
	// $ANTLR end "propertyContextDecl"

	private sealed partial class propertyContextHead_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public propertyContextHead_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_propertyContextHead();
	partial void LeaveRule_propertyContextHead();

	// $ANTLR start "propertyContextHead"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:36:1: propertyContextHead : 'context' SimpleName '::' pathName ':' type ;
	[GrammarRule("propertyContextHead")]
	private OCLSyntaxParser.propertyContextHead_return propertyContextHead()
	{
		EnterRule_propertyContextHead();
		EnterRule("propertyContextHead", 4);
		TraceIn("propertyContextHead", 4);
		OCLSyntaxParser.propertyContextHead_return retval = new OCLSyntaxParser.propertyContextHead_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		CommonToken string_literal7 = default(CommonToken);
		CommonToken SimpleName8 = default(CommonToken);
		CommonToken string_literal9 = default(CommonToken);
		CommonToken char_literal11 = default(CommonToken);
		OCLSyntaxParser.pathName_return pathName10 = default(OCLSyntaxParser.pathName_return);
		OCLSyntaxParser.type_return type12 = default(OCLSyntaxParser.type_return);

		object string_literal7_tree = default(object);
		object SimpleName8_tree = default(object);
		object string_literal9_tree = default(object);
		object char_literal11_tree = default(object);

		try { DebugEnterRule(GrammarFileName, "propertyContextHead");
		DebugLocation(36, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:37:2: ( 'context' SimpleName '::' pathName ':' type )
			DebugEnterAlt(1);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:37:3: 'context' SimpleName '::' pathName ':' type
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(37, 3);
			string_literal7=(CommonToken)Match(input,83,Follow._83_in_propertyContextHead150); 
			string_literal7_tree = (object)adaptor.Create(string_literal7);
			adaptor.AddChild(root_0, string_literal7_tree);

			DebugLocation(37, 13);
			SimpleName8=(CommonToken)Match(input,SimpleName,Follow._SimpleName_in_propertyContextHead152); 
			SimpleName8_tree = (object)adaptor.Create(SimpleName8);
			adaptor.AddChild(root_0, SimpleName8_tree);

			DebugLocation(37, 24);
			string_literal9=(CommonToken)Match(input,52,Follow._52_in_propertyContextHead154); 
			string_literal9_tree = (object)adaptor.Create(string_literal9);
			adaptor.AddChild(root_0, string_literal9_tree);

			DebugLocation(37, 29);
			PushFollow(Follow._pathName_in_propertyContextHead156);
			pathName10=pathName();
			PopFollow();

			adaptor.AddChild(root_0, pathName10.Tree);
			DebugLocation(37, 38);
			char_literal11=(CommonToken)Match(input,51,Follow._51_in_propertyContextHead158); 
			char_literal11_tree = (object)adaptor.Create(char_literal11);
			adaptor.AddChild(root_0, char_literal11_tree);

			DebugLocation(37, 42);
			PushFollow(Follow._type_in_propertyContextHead160);
			type12=type();
			PopFollow();

			adaptor.AddChild(root_0, type12.Tree);

			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("propertyContextHead", 4);
			LeaveRule("propertyContextHead", 4);
			LeaveRule_propertyContextHead();
		}
		DebugLocation(38, 1);
		} finally { DebugExitRule(GrammarFileName, "propertyContextHead"); }
		return retval;

	}
	// $ANTLR end "propertyContextHead"

	private sealed partial class operationContextDecl_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public operationContextDecl_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_operationContextDecl();
	partial void LeaveRule_operationContextDecl();

	// $ANTLR start "operationContextDecl"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:40:1: operationContextDecl : operationContextHead ( prePostOrBodyDecl )* ;
	[GrammarRule("operationContextDecl")]
	private OCLSyntaxParser.operationContextDecl_return operationContextDecl()
	{
		EnterRule_operationContextDecl();
		EnterRule("operationContextDecl", 5);
		TraceIn("operationContextDecl", 5);
		OCLSyntaxParser.operationContextDecl_return retval = new OCLSyntaxParser.operationContextDecl_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		OCLSyntaxParser.operationContextHead_return operationContextHead13 = default(OCLSyntaxParser.operationContextHead_return);
		OCLSyntaxParser.prePostOrBodyDecl_return prePostOrBodyDecl14 = default(OCLSyntaxParser.prePostOrBodyDecl_return);


		try { DebugEnterRule(GrammarFileName, "operationContextDecl");
		DebugLocation(40, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:41:2: ( operationContextHead ( prePostOrBodyDecl )* )
			DebugEnterAlt(1);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:41:3: operationContextHead ( prePostOrBodyDecl )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(41, 3);
			PushFollow(Follow._operationContextHead_in_operationContextDecl170);
			operationContextHead13=operationContextHead();
			PopFollow();

			adaptor.AddChild(root_0, operationContextHead13.Tree);
			DebugLocation(41, 24);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:41:24: ( prePostOrBodyDecl )*
			try { DebugEnterSubRule(4);
			while (true)
			{
				int alt4=2;
				try { DebugEnterDecision(4, false);
				int LA4_0 = input.LA(1);

				if ((LA4_0==82||(LA4_0>=97 && LA4_0<=98)))
				{
					alt4 = 1;
				}


				} finally { DebugExitDecision(4); }
				switch ( alt4 )
				{
				case 1:
					DebugEnterAlt(1);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:41:24: prePostOrBodyDecl
					{
					DebugLocation(41, 24);
					PushFollow(Follow._prePostOrBodyDecl_in_operationContextDecl172);
					prePostOrBodyDecl14=prePostOrBodyDecl();
					PopFollow();

					adaptor.AddChild(root_0, prePostOrBodyDecl14.Tree);

					}
					break;

				default:
					goto loop4;
				}
			}

			loop4:
				;

			} finally { DebugExitSubRule(4); }


			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("operationContextDecl", 5);
			LeaveRule("operationContextDecl", 5);
			LeaveRule_operationContextDecl();
		}
		DebugLocation(42, 1);
		} finally { DebugExitRule(GrammarFileName, "operationContextDecl"); }
		return retval;

	}
	// $ANTLR end "operationContextDecl"

	private sealed partial class operationContextHead_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public operationContextHead_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_operationContextHead();
	partial void LeaveRule_operationContextHead();

	// $ANTLR start "operationContextHead"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:44:1: operationContextHead : 'context' operation ;
	[GrammarRule("operationContextHead")]
	private OCLSyntaxParser.operationContextHead_return operationContextHead()
	{
		EnterRule_operationContextHead();
		EnterRule("operationContextHead", 6);
		TraceIn("operationContextHead", 6);
		OCLSyntaxParser.operationContextHead_return retval = new OCLSyntaxParser.operationContextHead_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		CommonToken string_literal15 = default(CommonToken);
		OCLSyntaxParser.operation_return operation16 = default(OCLSyntaxParser.operation_return);

		object string_literal15_tree = default(object);

		try { DebugEnterRule(GrammarFileName, "operationContextHead");
		DebugLocation(44, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:45:2: ( 'context' operation )
			DebugEnterAlt(1);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:45:3: 'context' operation
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(45, 3);
			string_literal15=(CommonToken)Match(input,83,Follow._83_in_operationContextHead183); 
			string_literal15_tree = (object)adaptor.Create(string_literal15);
			adaptor.AddChild(root_0, string_literal15_tree);

			DebugLocation(45, 13);
			PushFollow(Follow._operation_in_operationContextHead185);
			operation16=operation();
			PopFollow();

			adaptor.AddChild(root_0, operation16.Tree);

			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("operationContextHead", 6);
			LeaveRule("operationContextHead", 6);
			LeaveRule_operationContextHead();
		}
		DebugLocation(46, 1);
		} finally { DebugExitRule(GrammarFileName, "operationContextHead"); }
		return retval;

	}
	// $ANTLR end "operationContextHead"

	private sealed partial class classifierContextDecl_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public classifierContextDecl_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_classifierContextDecl();
	partial void LeaveRule_classifierContextDecl();

	// $ANTLR start "classifierContextDecl"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:48:1: classifierContextDecl : classifierContextHead ( invOrDef )* ;
	[GrammarRule("classifierContextDecl")]
	private OCLSyntaxParser.classifierContextDecl_return classifierContextDecl()
	{
		EnterRule_classifierContextDecl();
		EnterRule("classifierContextDecl", 7);
		TraceIn("classifierContextDecl", 7);
		OCLSyntaxParser.classifierContextDecl_return retval = new OCLSyntaxParser.classifierContextDecl_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		OCLSyntaxParser.classifierContextHead_return classifierContextHead17 = default(OCLSyntaxParser.classifierContextHead_return);
		OCLSyntaxParser.invOrDef_return invOrDef18 = default(OCLSyntaxParser.invOrDef_return);


		try { DebugEnterRule(GrammarFileName, "classifierContextDecl");
		DebugLocation(48, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:49:2: ( classifierContextHead ( invOrDef )* )
			DebugEnterAlt(1);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:49:3: classifierContextHead ( invOrDef )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(49, 3);
			PushFollow(Follow._classifierContextHead_in_classifierContextDecl195);
			classifierContextHead17=classifierContextHead();
			PopFollow();

			adaptor.AddChild(root_0, classifierContextHead17.Tree);
			DebugLocation(49, 25);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:49:25: ( invOrDef )*
			try { DebugEnterSubRule(5);
			while (true)
			{
				int alt5=2;
				try { DebugEnterDecision(5, false);
				int LA5_0 = input.LA(1);

				if ((LA5_0==84||LA5_0==92||LA5_0==99))
				{
					alt5 = 1;
				}


				} finally { DebugExitDecision(5); }
				switch ( alt5 )
				{
				case 1:
					DebugEnterAlt(1);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:49:26: invOrDef
					{
					DebugLocation(49, 26);
					PushFollow(Follow._invOrDef_in_classifierContextDecl198);
					invOrDef18=invOrDef();
					PopFollow();

					adaptor.AddChild(root_0, invOrDef18.Tree);

					}
					break;

				default:
					goto loop5;
				}
			}

			loop5:
				;

			} finally { DebugExitSubRule(5); }


			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("classifierContextDecl", 7);
			LeaveRule("classifierContextDecl", 7);
			LeaveRule_classifierContextDecl();
		}
		DebugLocation(50, 1);
		} finally { DebugExitRule(GrammarFileName, "classifierContextDecl"); }
		return retval;

	}
	// $ANTLR end "classifierContextDecl"

	private sealed partial class classifierContextHead_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public classifierContextHead_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_classifierContextHead();
	partial void LeaveRule_classifierContextHead();

	// $ANTLR start "classifierContextHead"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:52:1: classifierContextHead : ( 'context' pathName | 'context' SimpleName ':' pathName );
	[GrammarRule("classifierContextHead")]
	private OCLSyntaxParser.classifierContextHead_return classifierContextHead()
	{
		EnterRule_classifierContextHead();
		EnterRule("classifierContextHead", 8);
		TraceIn("classifierContextHead", 8);
		OCLSyntaxParser.classifierContextHead_return retval = new OCLSyntaxParser.classifierContextHead_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		CommonToken string_literal19 = default(CommonToken);
		CommonToken string_literal21 = default(CommonToken);
		CommonToken SimpleName22 = default(CommonToken);
		CommonToken char_literal23 = default(CommonToken);
		OCLSyntaxParser.pathName_return pathName20 = default(OCLSyntaxParser.pathName_return);
		OCLSyntaxParser.pathName_return pathName24 = default(OCLSyntaxParser.pathName_return);

		object string_literal19_tree = default(object);
		object string_literal21_tree = default(object);
		object SimpleName22_tree = default(object);
		object char_literal23_tree = default(object);

		try { DebugEnterRule(GrammarFileName, "classifierContextHead");
		DebugLocation(52, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:53:2: ( 'context' pathName | 'context' SimpleName ':' pathName )
			int alt6=2;
			try { DebugEnterDecision(6, false);
			int LA6_0 = input.LA(1);

			if ((LA6_0==83))
			{
				int LA6_1 = input.LA(2);

				if ((LA6_1==SimpleName))
				{
					int LA6_2 = input.LA(3);

					if ((LA6_2==51))
					{
						alt6 = 2;
					}
					else if ((LA6_2==EOF||LA6_2==52||(LA6_2>=83 && LA6_2<=84)||LA6_2==92||LA6_2==99))
					{
						alt6 = 1;
					}
					else
					{
						NoViableAltException nvae = new NoViableAltException("", 6, 2, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 6, 1, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 6, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(6); }
			switch (alt6)
			{
			case 1:
				DebugEnterAlt(1);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:53:3: 'context' pathName
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(53, 3);
				string_literal19=(CommonToken)Match(input,83,Follow._83_in_classifierContextHead211); 
				string_literal19_tree = (object)adaptor.Create(string_literal19);
				adaptor.AddChild(root_0, string_literal19_tree);

				DebugLocation(53, 13);
				PushFollow(Follow._pathName_in_classifierContextHead213);
				pathName20=pathName();
				PopFollow();

				adaptor.AddChild(root_0, pathName20.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:54:3: 'context' SimpleName ':' pathName
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(54, 3);
				string_literal21=(CommonToken)Match(input,83,Follow._83_in_classifierContextHead219); 
				string_literal21_tree = (object)adaptor.Create(string_literal21);
				adaptor.AddChild(root_0, string_literal21_tree);

				DebugLocation(54, 13);
				SimpleName22=(CommonToken)Match(input,SimpleName,Follow._SimpleName_in_classifierContextHead221); 
				SimpleName22_tree = (object)adaptor.Create(SimpleName22);
				adaptor.AddChild(root_0, SimpleName22_tree);

				DebugLocation(54, 23);
				char_literal23=(CommonToken)Match(input,51,Follow._51_in_classifierContextHead222); 
				char_literal23_tree = (object)adaptor.Create(char_literal23);
				adaptor.AddChild(root_0, char_literal23_tree);

				DebugLocation(54, 26);
				PushFollow(Follow._pathName_in_classifierContextHead223);
				pathName24=pathName();
				PopFollow();

				adaptor.AddChild(root_0, pathName24.Tree);

				}
				break;

			}
			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("classifierContextHead", 8);
			LeaveRule("classifierContextHead", 8);
			LeaveRule_classifierContextHead();
		}
		DebugLocation(55, 1);
		} finally { DebugExitRule(GrammarFileName, "classifierContextHead"); }
		return retval;

	}
	// $ANTLR end "classifierContextHead"

	private sealed partial class initOrDerValue_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public initOrDerValue_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_initOrDerValue();
	partial void LeaveRule_initOrDerValue();

	// $ANTLR start "initOrDerValue"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:57:1: initOrDerValue : ( 'init' ':' oclExpression | 'derivate' ':' oclExpression );
	[GrammarRule("initOrDerValue")]
	private OCLSyntaxParser.initOrDerValue_return initOrDerValue()
	{
		EnterRule_initOrDerValue();
		EnterRule("initOrDerValue", 9);
		TraceIn("initOrDerValue", 9);
		OCLSyntaxParser.initOrDerValue_return retval = new OCLSyntaxParser.initOrDerValue_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		CommonToken string_literal25 = default(CommonToken);
		CommonToken char_literal26 = default(CommonToken);
		CommonToken string_literal28 = default(CommonToken);
		CommonToken char_literal29 = default(CommonToken);
		OCLSyntaxParser.oclExpression_return oclExpression27 = default(OCLSyntaxParser.oclExpression_return);
		OCLSyntaxParser.oclExpression_return oclExpression30 = default(OCLSyntaxParser.oclExpression_return);

		object string_literal25_tree = default(object);
		object char_literal26_tree = default(object);
		object string_literal28_tree = default(object);
		object char_literal29_tree = default(object);

		try { DebugEnterRule(GrammarFileName, "initOrDerValue");
		DebugLocation(57, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:58:2: ( 'init' ':' oclExpression | 'derivate' ':' oclExpression )
			int alt7=2;
			try { DebugEnterDecision(7, false);
			int LA7_0 = input.LA(1);

			if ((LA7_0==91))
			{
				alt7 = 1;
			}
			else if ((LA7_0==85))
			{
				alt7 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 7, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(7); }
			switch (alt7)
			{
			case 1:
				DebugEnterAlt(1);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:58:3: 'init' ':' oclExpression
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(58, 3);
				string_literal25=(CommonToken)Match(input,91,Follow._91_in_initOrDerValue234); 
				string_literal25_tree = (object)adaptor.Create(string_literal25);
				adaptor.AddChild(root_0, string_literal25_tree);

				DebugLocation(58, 10);
				char_literal26=(CommonToken)Match(input,51,Follow._51_in_initOrDerValue236); 
				char_literal26_tree = (object)adaptor.Create(char_literal26);
				adaptor.AddChild(root_0, char_literal26_tree);

				DebugLocation(58, 14);
				PushFollow(Follow._oclExpression_in_initOrDerValue238);
				oclExpression27=oclExpression();
				PopFollow();

				adaptor.AddChild(root_0, oclExpression27.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:59:3: 'derivate' ':' oclExpression
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(59, 3);
				string_literal28=(CommonToken)Match(input,85,Follow._85_in_initOrDerValue243); 
				string_literal28_tree = (object)adaptor.Create(string_literal28);
				adaptor.AddChild(root_0, string_literal28_tree);

				DebugLocation(59, 14);
				char_literal29=(CommonToken)Match(input,51,Follow._51_in_initOrDerValue245); 
				char_literal29_tree = (object)adaptor.Create(char_literal29);
				adaptor.AddChild(root_0, char_literal29_tree);

				DebugLocation(59, 18);
				PushFollow(Follow._oclExpression_in_initOrDerValue247);
				oclExpression30=oclExpression();
				PopFollow();

				adaptor.AddChild(root_0, oclExpression30.Tree);

				}
				break;

			}
			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("initOrDerValue", 9);
			LeaveRule("initOrDerValue", 9);
			LeaveRule_initOrDerValue();
		}
		DebugLocation(60, 1);
		} finally { DebugExitRule(GrammarFileName, "initOrDerValue"); }
		return retval;

	}
	// $ANTLR end "initOrDerValue"

	private sealed partial class invOrDef_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public invOrDef_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_invOrDef();
	partial void LeaveRule_invOrDef();

	// $ANTLR start "invOrDef"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:62:1: invOrDef : ( 'inv' ( SimpleName )? ':' oclExpression | ( 'static' )? 'def' ( SimpleName )? ':' defExpression );
	[GrammarRule("invOrDef")]
	private OCLSyntaxParser.invOrDef_return invOrDef()
	{
		EnterRule_invOrDef();
		EnterRule("invOrDef", 10);
		TraceIn("invOrDef", 10);
		OCLSyntaxParser.invOrDef_return retval = new OCLSyntaxParser.invOrDef_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		CommonToken string_literal31 = default(CommonToken);
		CommonToken SimpleName32 = default(CommonToken);
		CommonToken char_literal33 = default(CommonToken);
		CommonToken string_literal35 = default(CommonToken);
		CommonToken string_literal36 = default(CommonToken);
		CommonToken SimpleName37 = default(CommonToken);
		CommonToken char_literal38 = default(CommonToken);
		OCLSyntaxParser.oclExpression_return oclExpression34 = default(OCLSyntaxParser.oclExpression_return);
		OCLSyntaxParser.defExpression_return defExpression39 = default(OCLSyntaxParser.defExpression_return);

		object string_literal31_tree = default(object);
		object SimpleName32_tree = default(object);
		object char_literal33_tree = default(object);
		object string_literal35_tree = default(object);
		object string_literal36_tree = default(object);
		object SimpleName37_tree = default(object);
		object char_literal38_tree = default(object);

		try { DebugEnterRule(GrammarFileName, "invOrDef");
		DebugLocation(62, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:63:2: ( 'inv' ( SimpleName )? ':' oclExpression | ( 'static' )? 'def' ( SimpleName )? ':' defExpression )
			int alt11=2;
			try { DebugEnterDecision(11, false);
			int LA11_0 = input.LA(1);

			if ((LA11_0==92))
			{
				alt11 = 1;
			}
			else if ((LA11_0==84||LA11_0==99))
			{
				alt11 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 11, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(11); }
			switch (alt11)
			{
			case 1:
				DebugEnterAlt(1);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:63:3: 'inv' ( SimpleName )? ':' oclExpression
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(63, 3);
				string_literal31=(CommonToken)Match(input,92,Follow._92_in_invOrDef258); 
				string_literal31_tree = (object)adaptor.Create(string_literal31);
				adaptor.AddChild(root_0, string_literal31_tree);

				DebugLocation(63, 9);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:63:9: ( SimpleName )?
				int alt8=2;
				try { DebugEnterSubRule(8);
				try { DebugEnterDecision(8, false);
				int LA8_0 = input.LA(1);

				if ((LA8_0==SimpleName))
				{
					alt8 = 1;
				}
				} finally { DebugExitDecision(8); }
				switch (alt8)
				{
				case 1:
					DebugEnterAlt(1);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:63:10: SimpleName
					{
					DebugLocation(63, 10);
					SimpleName32=(CommonToken)Match(input,SimpleName,Follow._SimpleName_in_invOrDef261); 
					SimpleName32_tree = (object)adaptor.Create(SimpleName32);
					adaptor.AddChild(root_0, SimpleName32_tree);


					}
					break;

				}
				} finally { DebugExitSubRule(8); }

				DebugLocation(63, 24);
				char_literal33=(CommonToken)Match(input,51,Follow._51_in_invOrDef266); 
				char_literal33_tree = (object)adaptor.Create(char_literal33);
				adaptor.AddChild(root_0, char_literal33_tree);

				DebugLocation(63, 28);
				PushFollow(Follow._oclExpression_in_invOrDef268);
				oclExpression34=oclExpression();
				PopFollow();

				adaptor.AddChild(root_0, oclExpression34.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:64:4: ( 'static' )? 'def' ( SimpleName )? ':' defExpression
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(64, 4);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:64:4: ( 'static' )?
				int alt9=2;
				try { DebugEnterSubRule(9);
				try { DebugEnterDecision(9, false);
				int LA9_0 = input.LA(1);

				if ((LA9_0==99))
				{
					alt9 = 1;
				}
				} finally { DebugExitDecision(9); }
				switch (alt9)
				{
				case 1:
					DebugEnterAlt(1);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:64:4: 'static'
					{
					DebugLocation(64, 4);
					string_literal35=(CommonToken)Match(input,99,Follow._99_in_invOrDef274); 
					string_literal35_tree = (object)adaptor.Create(string_literal35);
					adaptor.AddChild(root_0, string_literal35_tree);


					}
					break;

				}
				} finally { DebugExitSubRule(9); }

				DebugLocation(64, 14);
				string_literal36=(CommonToken)Match(input,84,Follow._84_in_invOrDef277); 
				string_literal36_tree = (object)adaptor.Create(string_literal36);
				adaptor.AddChild(root_0, string_literal36_tree);

				DebugLocation(64, 20);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:64:20: ( SimpleName )?
				int alt10=2;
				try { DebugEnterSubRule(10);
				try { DebugEnterDecision(10, false);
				int LA10_0 = input.LA(1);

				if ((LA10_0==SimpleName))
				{
					alt10 = 1;
				}
				} finally { DebugExitDecision(10); }
				switch (alt10)
				{
				case 1:
					DebugEnterAlt(1);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:64:20: SimpleName
					{
					DebugLocation(64, 20);
					SimpleName37=(CommonToken)Match(input,SimpleName,Follow._SimpleName_in_invOrDef279); 
					SimpleName37_tree = (object)adaptor.Create(SimpleName37);
					adaptor.AddChild(root_0, SimpleName37_tree);


					}
					break;

				}
				} finally { DebugExitSubRule(10); }

				DebugLocation(64, 32);
				char_literal38=(CommonToken)Match(input,51,Follow._51_in_invOrDef282); 
				char_literal38_tree = (object)adaptor.Create(char_literal38);
				adaptor.AddChild(root_0, char_literal38_tree);

				DebugLocation(64, 36);
				PushFollow(Follow._defExpression_in_invOrDef284);
				defExpression39=defExpression();
				PopFollow();

				adaptor.AddChild(root_0, defExpression39.Tree);

				}
				break;

			}
			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("invOrDef", 10);
			LeaveRule("invOrDef", 10);
			LeaveRule_invOrDef();
		}
		DebugLocation(65, 1);
		} finally { DebugExitRule(GrammarFileName, "invOrDef"); }
		return retval;

	}
	// $ANTLR end "invOrDef"

	private sealed partial class prePostOrBodyDecl_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public prePostOrBodyDecl_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_prePostOrBodyDecl();
	partial void LeaveRule_prePostOrBodyDecl();

	// $ANTLR start "prePostOrBodyDecl"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:67:1: prePostOrBodyDecl : ( 'pre' ( SimpleName )? ':' oclExpression | 'post' ( SimpleName )? ':' oclExpression | 'body' ( SimpleName )? ':' oclExpression );
	[GrammarRule("prePostOrBodyDecl")]
	private OCLSyntaxParser.prePostOrBodyDecl_return prePostOrBodyDecl()
	{
		EnterRule_prePostOrBodyDecl();
		EnterRule("prePostOrBodyDecl", 11);
		TraceIn("prePostOrBodyDecl", 11);
		OCLSyntaxParser.prePostOrBodyDecl_return retval = new OCLSyntaxParser.prePostOrBodyDecl_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		CommonToken string_literal40 = default(CommonToken);
		CommonToken SimpleName41 = default(CommonToken);
		CommonToken char_literal42 = default(CommonToken);
		CommonToken string_literal44 = default(CommonToken);
		CommonToken SimpleName45 = default(CommonToken);
		CommonToken char_literal46 = default(CommonToken);
		CommonToken string_literal48 = default(CommonToken);
		CommonToken SimpleName49 = default(CommonToken);
		CommonToken char_literal50 = default(CommonToken);
		OCLSyntaxParser.oclExpression_return oclExpression43 = default(OCLSyntaxParser.oclExpression_return);
		OCLSyntaxParser.oclExpression_return oclExpression47 = default(OCLSyntaxParser.oclExpression_return);
		OCLSyntaxParser.oclExpression_return oclExpression51 = default(OCLSyntaxParser.oclExpression_return);

		object string_literal40_tree = default(object);
		object SimpleName41_tree = default(object);
		object char_literal42_tree = default(object);
		object string_literal44_tree = default(object);
		object SimpleName45_tree = default(object);
		object char_literal46_tree = default(object);
		object string_literal48_tree = default(object);
		object SimpleName49_tree = default(object);
		object char_literal50_tree = default(object);

		try { DebugEnterRule(GrammarFileName, "prePostOrBodyDecl");
		DebugLocation(67, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:68:2: ( 'pre' ( SimpleName )? ':' oclExpression | 'post' ( SimpleName )? ':' oclExpression | 'body' ( SimpleName )? ':' oclExpression )
			int alt15=3;
			try { DebugEnterDecision(15, false);
			switch (input.LA(1))
			{
			case 98:
				{
				alt15 = 1;
				}
				break;
			case 97:
				{
				alt15 = 2;
				}
				break;
			case 82:
				{
				alt15 = 3;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 15, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(15); }
			switch (alt15)
			{
			case 1:
				DebugEnterAlt(1);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:68:3: 'pre' ( SimpleName )? ':' oclExpression
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(68, 3);
				string_literal40=(CommonToken)Match(input,98,Follow._98_in_prePostOrBodyDecl294); 
				string_literal40_tree = (object)adaptor.Create(string_literal40);
				adaptor.AddChild(root_0, string_literal40_tree);

				DebugLocation(68, 9);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:68:9: ( SimpleName )?
				int alt12=2;
				try { DebugEnterSubRule(12);
				try { DebugEnterDecision(12, false);
				int LA12_0 = input.LA(1);

				if ((LA12_0==SimpleName))
				{
					alt12 = 1;
				}
				} finally { DebugExitDecision(12); }
				switch (alt12)
				{
				case 1:
					DebugEnterAlt(1);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:68:10: SimpleName
					{
					DebugLocation(68, 10);
					SimpleName41=(CommonToken)Match(input,SimpleName,Follow._SimpleName_in_prePostOrBodyDecl297); 
					SimpleName41_tree = (object)adaptor.Create(SimpleName41);
					adaptor.AddChild(root_0, SimpleName41_tree);


					}
					break;

				}
				} finally { DebugExitSubRule(12); }

				DebugLocation(68, 23);
				char_literal42=(CommonToken)Match(input,51,Follow._51_in_prePostOrBodyDecl301); 
				char_literal42_tree = (object)adaptor.Create(char_literal42);
				adaptor.AddChild(root_0, char_literal42_tree);

				DebugLocation(68, 27);
				PushFollow(Follow._oclExpression_in_prePostOrBodyDecl303);
				oclExpression43=oclExpression();
				PopFollow();

				adaptor.AddChild(root_0, oclExpression43.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:69:3: 'post' ( SimpleName )? ':' oclExpression
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(69, 3);
				string_literal44=(CommonToken)Match(input,97,Follow._97_in_prePostOrBodyDecl308); 
				string_literal44_tree = (object)adaptor.Create(string_literal44);
				adaptor.AddChild(root_0, string_literal44_tree);

				DebugLocation(69, 10);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:69:10: ( SimpleName )?
				int alt13=2;
				try { DebugEnterSubRule(13);
				try { DebugEnterDecision(13, false);
				int LA13_0 = input.LA(1);

				if ((LA13_0==SimpleName))
				{
					alt13 = 1;
				}
				} finally { DebugExitDecision(13); }
				switch (alt13)
				{
				case 1:
					DebugEnterAlt(1);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:69:11: SimpleName
					{
					DebugLocation(69, 11);
					SimpleName45=(CommonToken)Match(input,SimpleName,Follow._SimpleName_in_prePostOrBodyDecl311); 
					SimpleName45_tree = (object)adaptor.Create(SimpleName45);
					adaptor.AddChild(root_0, SimpleName45_tree);


					}
					break;

				}
				} finally { DebugExitSubRule(13); }

				DebugLocation(69, 24);
				char_literal46=(CommonToken)Match(input,51,Follow._51_in_prePostOrBodyDecl315); 
				char_literal46_tree = (object)adaptor.Create(char_literal46);
				adaptor.AddChild(root_0, char_literal46_tree);

				DebugLocation(69, 28);
				PushFollow(Follow._oclExpression_in_prePostOrBodyDecl317);
				oclExpression47=oclExpression();
				PopFollow();

				adaptor.AddChild(root_0, oclExpression47.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:70:3: 'body' ( SimpleName )? ':' oclExpression
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(70, 3);
				string_literal48=(CommonToken)Match(input,82,Follow._82_in_prePostOrBodyDecl322); 
				string_literal48_tree = (object)adaptor.Create(string_literal48);
				adaptor.AddChild(root_0, string_literal48_tree);

				DebugLocation(70, 10);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:70:10: ( SimpleName )?
				int alt14=2;
				try { DebugEnterSubRule(14);
				try { DebugEnterDecision(14, false);
				int LA14_0 = input.LA(1);

				if ((LA14_0==SimpleName))
				{
					alt14 = 1;
				}
				} finally { DebugExitDecision(14); }
				switch (alt14)
				{
				case 1:
					DebugEnterAlt(1);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:70:11: SimpleName
					{
					DebugLocation(70, 11);
					SimpleName49=(CommonToken)Match(input,SimpleName,Follow._SimpleName_in_prePostOrBodyDecl325); 
					SimpleName49_tree = (object)adaptor.Create(SimpleName49);
					adaptor.AddChild(root_0, SimpleName49_tree);


					}
					break;

				}
				} finally { DebugExitSubRule(14); }

				DebugLocation(70, 24);
				char_literal50=(CommonToken)Match(input,51,Follow._51_in_prePostOrBodyDecl329); 
				char_literal50_tree = (object)adaptor.Create(char_literal50);
				adaptor.AddChild(root_0, char_literal50_tree);

				DebugLocation(70, 28);
				PushFollow(Follow._oclExpression_in_prePostOrBodyDecl331);
				oclExpression51=oclExpression();
				PopFollow();

				adaptor.AddChild(root_0, oclExpression51.Tree);

				}
				break;

			}
			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("prePostOrBodyDecl", 11);
			LeaveRule("prePostOrBodyDecl", 11);
			LeaveRule_prePostOrBodyDecl();
		}
		DebugLocation(71, 1);
		} finally { DebugExitRule(GrammarFileName, "prePostOrBodyDecl"); }
		return retval;

	}
	// $ANTLR end "prePostOrBodyDecl"

	private sealed partial class operation_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public operation_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_operation();
	partial void LeaveRule_operation();

	// $ANTLR start "operation"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:74:1: operation : pathName '(' ( parameters )? ')' ( ':' type )? ;
	[GrammarRule("operation")]
	private OCLSyntaxParser.operation_return operation()
	{
		EnterRule_operation();
		EnterRule("operation", 12);
		TraceIn("operation", 12);
		OCLSyntaxParser.operation_return retval = new OCLSyntaxParser.operation_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		CommonToken char_literal53 = default(CommonToken);
		CommonToken char_literal55 = default(CommonToken);
		CommonToken char_literal56 = default(CommonToken);
		OCLSyntaxParser.pathName_return pathName52 = default(OCLSyntaxParser.pathName_return);
		OCLSyntaxParser.parameters_return parameters54 = default(OCLSyntaxParser.parameters_return);
		OCLSyntaxParser.type_return type57 = default(OCLSyntaxParser.type_return);

		object char_literal53_tree = default(object);
		object char_literal55_tree = default(object);
		object char_literal56_tree = default(object);

		try { DebugEnterRule(GrammarFileName, "operation");
		DebugLocation(74, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:75:2: ( pathName '(' ( parameters )? ')' ( ':' type )? )
			DebugEnterAlt(1);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:75:3: pathName '(' ( parameters )? ')' ( ':' type )?
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(75, 3);
			PushFollow(Follow._pathName_in_operation342);
			pathName52=pathName();
			PopFollow();

			adaptor.AddChild(root_0, pathName52.Tree);
			DebugLocation(75, 32);
			char_literal53=(CommonToken)Match(input,42,Follow._42_in_operation346); 
			char_literal53_tree = (object)adaptor.Create(char_literal53);
			adaptor.AddChild(root_0, char_literal53_tree);

			DebugLocation(75, 36);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:75:36: ( parameters )?
			int alt16=2;
			try { DebugEnterSubRule(16);
			try { DebugEnterDecision(16, false);
			int LA16_0 = input.LA(1);

			if ((LA16_0==SimpleName))
			{
				alt16 = 1;
			}
			} finally { DebugExitDecision(16); }
			switch (alt16)
			{
			case 1:
				DebugEnterAlt(1);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:75:36: parameters
				{
				DebugLocation(75, 36);
				PushFollow(Follow._parameters_in_operation348);
				parameters54=parameters();
				PopFollow();

				adaptor.AddChild(root_0, parameters54.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(16); }

			DebugLocation(75, 48);
			char_literal55=(CommonToken)Match(input,43,Follow._43_in_operation351); 
			char_literal55_tree = (object)adaptor.Create(char_literal55);
			adaptor.AddChild(root_0, char_literal55_tree);

			DebugLocation(75, 52);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:75:52: ( ':' type )?
			int alt17=2;
			try { DebugEnterSubRule(17);
			try { DebugEnterDecision(17, false);
			int LA17_0 = input.LA(1);

			if ((LA17_0==51))
			{
				alt17 = 1;
			}
			} finally { DebugExitDecision(17); }
			switch (alt17)
			{
			case 1:
				DebugEnterAlt(1);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:75:53: ':' type
				{
				DebugLocation(75, 53);
				char_literal56=(CommonToken)Match(input,51,Follow._51_in_operation354); 
				char_literal56_tree = (object)adaptor.Create(char_literal56);
				adaptor.AddChild(root_0, char_literal56_tree);

				DebugLocation(75, 57);
				PushFollow(Follow._type_in_operation356);
				type57=type();
				PopFollow();

				adaptor.AddChild(root_0, type57.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(17); }


			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("operation", 12);
			LeaveRule("operation", 12);
			LeaveRule_operation();
		}
		DebugLocation(76, 1);
		} finally { DebugExitRule(GrammarFileName, "operation"); }
		return retval;

	}
	// $ANTLR end "operation"

	private sealed partial class parameters_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public parameters_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_parameters();
	partial void LeaveRule_parameters();

	// $ANTLR start "parameters"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:78:1: parameters : variableDeclaration ( ',' parameters )? ;
	[GrammarRule("parameters")]
	private OCLSyntaxParser.parameters_return parameters()
	{
		EnterRule_parameters();
		EnterRule("parameters", 13);
		TraceIn("parameters", 13);
		OCLSyntaxParser.parameters_return retval = new OCLSyntaxParser.parameters_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		CommonToken char_literal59 = default(CommonToken);
		OCLSyntaxParser.variableDeclaration_return variableDeclaration58 = default(OCLSyntaxParser.variableDeclaration_return);
		OCLSyntaxParser.parameters_return parameters60 = default(OCLSyntaxParser.parameters_return);

		object char_literal59_tree = default(object);

		try { DebugEnterRule(GrammarFileName, "parameters");
		DebugLocation(78, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:79:2: ( variableDeclaration ( ',' parameters )? )
			DebugEnterAlt(1);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:79:3: variableDeclaration ( ',' parameters )?
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(79, 3);
			PushFollow(Follow._variableDeclaration_in_parameters368);
			variableDeclaration58=variableDeclaration();
			PopFollow();

			adaptor.AddChild(root_0, variableDeclaration58.Tree);
			DebugLocation(79, 23);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:79:23: ( ',' parameters )?
			int alt18=2;
			try { DebugEnterSubRule(18);
			try { DebugEnterDecision(18, false);
			int LA18_0 = input.LA(1);

			if ((LA18_0==45))
			{
				alt18 = 1;
			}
			} finally { DebugExitDecision(18); }
			switch (alt18)
			{
			case 1:
				DebugEnterAlt(1);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:79:24: ',' parameters
				{
				DebugLocation(79, 24);
				char_literal59=(CommonToken)Match(input,45,Follow._45_in_parameters371); 
				char_literal59_tree = (object)adaptor.Create(char_literal59);
				adaptor.AddChild(root_0, char_literal59_tree);

				DebugLocation(79, 28);
				PushFollow(Follow._parameters_in_parameters373);
				parameters60=parameters();
				PopFollow();

				adaptor.AddChild(root_0, parameters60.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(18); }


			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("parameters", 13);
			LeaveRule("parameters", 13);
			LeaveRule_parameters();
		}
		DebugLocation(80, 1);
		} finally { DebugExitRule(GrammarFileName, "parameters"); }
		return retval;

	}
	// $ANTLR end "parameters"

	private sealed partial class defExpression_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public defExpression_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_defExpression();
	partial void LeaveRule_defExpression();

	// $ANTLR start "defExpression"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:82:1: defExpression : ( variableDeclaration | operation '=' oclExpression );
	[GrammarRule("defExpression")]
	private OCLSyntaxParser.defExpression_return defExpression()
	{
		EnterRule_defExpression();
		EnterRule("defExpression", 14);
		TraceIn("defExpression", 14);
		OCLSyntaxParser.defExpression_return retval = new OCLSyntaxParser.defExpression_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		CommonToken char_literal63 = default(CommonToken);
		OCLSyntaxParser.variableDeclaration_return variableDeclaration61 = default(OCLSyntaxParser.variableDeclaration_return);
		OCLSyntaxParser.operation_return operation62 = default(OCLSyntaxParser.operation_return);
		OCLSyntaxParser.oclExpression_return oclExpression64 = default(OCLSyntaxParser.oclExpression_return);

		object char_literal63_tree = default(object);

		try { DebugEnterRule(GrammarFileName, "defExpression");
		DebugLocation(82, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:83:2: ( variableDeclaration | operation '=' oclExpression )
			int alt19=2;
			try { DebugEnterDecision(19, false);
			int LA19_0 = input.LA(1);

			if ((LA19_0==SimpleName))
			{
				int LA19_1 = input.LA(2);

				if ((LA19_1==EOF||LA19_1==51||LA19_1==57||(LA19_1>=83 && LA19_1<=84)||LA19_1==92||LA19_1==99))
				{
					alt19 = 1;
				}
				else if ((LA19_1==42||LA19_1==52))
				{
					alt19 = 2;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 19, 1, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 19, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(19); }
			switch (alt19)
			{
			case 1:
				DebugEnterAlt(1);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:83:4: variableDeclaration
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(83, 4);
				PushFollow(Follow._variableDeclaration_in_defExpression386);
				variableDeclaration61=variableDeclaration();
				PopFollow();

				adaptor.AddChild(root_0, variableDeclaration61.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:84:4: operation '=' oclExpression
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(84, 4);
				PushFollow(Follow._operation_in_defExpression391);
				operation62=operation();
				PopFollow();

				adaptor.AddChild(root_0, operation62.Tree);
				DebugLocation(84, 14);
				char_literal63=(CommonToken)Match(input,57,Follow._57_in_defExpression393); 
				char_literal63_tree = (object)adaptor.Create(char_literal63);
				adaptor.AddChild(root_0, char_literal63_tree);

				DebugLocation(84, 18);
				PushFollow(Follow._oclExpression_in_defExpression395);
				oclExpression64=oclExpression();
				PopFollow();

				adaptor.AddChild(root_0, oclExpression64.Tree);

				}
				break;

			}
			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("defExpression", 14);
			LeaveRule("defExpression", 14);
			LeaveRule_defExpression();
		}
		DebugLocation(85, 1);
		} finally { DebugExitRule(GrammarFileName, "defExpression"); }
		return retval;

	}
	// $ANTLR end "defExpression"

	public sealed partial class oclExpression_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public oclExpression_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_oclExpression();
	partial void LeaveRule_oclExpression();

	// $ANTLR start "oclExpression"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:88:1: public oclExpression : logicalImpliesExpression ;
	[GrammarRule("oclExpression")]
	public OCLSyntaxParser.oclExpression_return oclExpression()
	{
		EnterRule_oclExpression();
		EnterRule("oclExpression", 15);
		TraceIn("oclExpression", 15);
		OCLSyntaxParser.oclExpression_return retval = new OCLSyntaxParser.oclExpression_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		OCLSyntaxParser.logicalImpliesExpression_return logicalImpliesExpression65 = default(OCLSyntaxParser.logicalImpliesExpression_return);


		try { DebugEnterRule(GrammarFileName, "oclExpression");
		DebugLocation(88, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:89:2: ( logicalImpliesExpression )
			DebugEnterAlt(1);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:89:3: logicalImpliesExpression
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(89, 3);
			PushFollow(Follow._logicalImpliesExpression_in_oclExpression408);
			logicalImpliesExpression65=logicalImpliesExpression();
			PopFollow();

			adaptor.AddChild(root_0, logicalImpliesExpression65.Tree);

			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("oclExpression", 15);
			LeaveRule("oclExpression", 15);
			LeaveRule_oclExpression();
		}
		DebugLocation(91, 1);
		} finally { DebugExitRule(GrammarFileName, "oclExpression"); }
		return retval;

	}
	// $ANTLR end "oclExpression"

	private sealed partial class logicalImpliesExpression_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public logicalImpliesExpression_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_logicalImpliesExpression();
	partial void LeaveRule_logicalImpliesExpression();

	// $ANTLR start "logicalImpliesExpression"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:93:1: logicalImpliesExpression : ( logicalXorExpression -> logicalXorExpression ) (opToken= 'implies' expr= logicalXorExpression -> ^( INFIX $opToken $logicalImpliesExpression $expr) )* ;
	[GrammarRule("logicalImpliesExpression")]
	private OCLSyntaxParser.logicalImpliesExpression_return logicalImpliesExpression()
	{
		EnterRule_logicalImpliesExpression();
		EnterRule("logicalImpliesExpression", 16);
		TraceIn("logicalImpliesExpression", 16);
		OCLSyntaxParser.logicalImpliesExpression_return retval = new OCLSyntaxParser.logicalImpliesExpression_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		CommonToken opToken = default(CommonToken);
		OCLSyntaxParser.logicalXorExpression_return expr = default(OCLSyntaxParser.logicalXorExpression_return);
		OCLSyntaxParser.logicalXorExpression_return logicalXorExpression66 = default(OCLSyntaxParser.logicalXorExpression_return);

		object opToken_tree = default(object);
		RewriteRuleITokenStream stream_89=new RewriteRuleITokenStream(adaptor,"token 89");
		RewriteRuleSubtreeStream stream_logicalXorExpression=new RewriteRuleSubtreeStream(adaptor,"rule logicalXorExpression");
		try { DebugEnterRule(GrammarFileName, "logicalImpliesExpression");
		DebugLocation(93, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:94:2: ( ( logicalXorExpression -> logicalXorExpression ) (opToken= 'implies' expr= logicalXorExpression -> ^( INFIX $opToken $logicalImpliesExpression $expr) )* )
			DebugEnterAlt(1);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:94:4: ( logicalXorExpression -> logicalXorExpression ) (opToken= 'implies' expr= logicalXorExpression -> ^( INFIX $opToken $logicalImpliesExpression $expr) )*
			{
			DebugLocation(94, 4);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:94:4: ( logicalXorExpression -> logicalXorExpression )
			DebugEnterAlt(1);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:94:5: logicalXorExpression
			{
			DebugLocation(94, 5);
			PushFollow(Follow._logicalXorExpression_in_logicalImpliesExpression424);
			logicalXorExpression66=logicalXorExpression();
			PopFollow();

			stream_logicalXorExpression.Add(logicalXorExpression66.Tree);


			{
			// AST REWRITE
			// elements: logicalXorExpression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 94:25: -> logicalXorExpression
			{
				DebugLocation(94, 27);
				adaptor.AddChild(root_0, stream_logicalXorExpression.NextTree());

			}

			retval.Tree = root_0;
			}

			}

			DebugLocation(94, 50);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:94:50: (opToken= 'implies' expr= logicalXorExpression -> ^( INFIX $opToken $logicalImpliesExpression $expr) )*
			try { DebugEnterSubRule(20);
			while (true)
			{
				int alt20=2;
				try { DebugEnterDecision(20, false);
				int LA20_0 = input.LA(1);

				if ((LA20_0==89))
				{
					alt20 = 1;
				}


				} finally { DebugExitDecision(20); }
				switch ( alt20 )
				{
				case 1:
					DebugEnterAlt(1);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:94:51: opToken= 'implies' expr= logicalXorExpression
					{
					DebugLocation(94, 58);
					opToken=(CommonToken)Match(input,89,Follow._89_in_logicalImpliesExpression433);  
					stream_89.Add(opToken);

					DebugLocation(94, 73);
					PushFollow(Follow._logicalXorExpression_in_logicalImpliesExpression437);
					expr=logicalXorExpression();
					PopFollow();

					stream_logicalXorExpression.Add(expr.Tree);


					{
					// AST REWRITE
					// elements: opToken, logicalImpliesExpression, expr
					// token labels: opToken
					// rule labels: expr, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					retval.Tree = root_0;
					RewriteRuleITokenStream stream_opToken=new RewriteRuleITokenStream(adaptor,"token opToken",opToken);
					RewriteRuleSubtreeStream stream_expr=new RewriteRuleSubtreeStream(adaptor,"rule expr",expr!=null?expr.Tree:null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (object)adaptor.Nil();
					// 94:94: -> ^( INFIX $opToken $logicalImpliesExpression $expr)
					{
						DebugLocation(94, 96);
						// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:94:96: ^( INFIX $opToken $logicalImpliesExpression $expr)
						{
						object root_1 = (object)adaptor.Nil();
						DebugLocation(94, 98);
						root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(INFIX, "INFIX"), root_1);

						DebugLocation(94, 105);
						adaptor.AddChild(root_1, stream_opToken.NextNode());
						DebugLocation(94, 114);
						adaptor.AddChild(root_1, stream_retval.NextTree());
						DebugLocation(94, 140);
						adaptor.AddChild(root_1, stream_expr.NextTree());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}

					}
					break;

				default:
					goto loop20;
				}
			}

			loop20:
				;

			} finally { DebugExitSubRule(20); }


			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("logicalImpliesExpression", 16);
			LeaveRule("logicalImpliesExpression", 16);
			LeaveRule_logicalImpliesExpression();
		}
		DebugLocation(95, 1);
		} finally { DebugExitRule(GrammarFileName, "logicalImpliesExpression"); }
		return retval;

	}
	// $ANTLR end "logicalImpliesExpression"

	private sealed partial class logicalXorExpression_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public logicalXorExpression_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_logicalXorExpression();
	partial void LeaveRule_logicalXorExpression();

	// $ANTLR start "logicalXorExpression"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:96:1: logicalXorExpression : ( logicalOrExpression -> logicalOrExpression ) (opToken= 'xor' expr= logicalOrExpression -> ^( INFIX $opToken $logicalXorExpression $expr) )* ;
	[GrammarRule("logicalXorExpression")]
	private OCLSyntaxParser.logicalXorExpression_return logicalXorExpression()
	{
		EnterRule_logicalXorExpression();
		EnterRule("logicalXorExpression", 17);
		TraceIn("logicalXorExpression", 17);
		OCLSyntaxParser.logicalXorExpression_return retval = new OCLSyntaxParser.logicalXorExpression_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		CommonToken opToken = default(CommonToken);
		OCLSyntaxParser.logicalOrExpression_return expr = default(OCLSyntaxParser.logicalOrExpression_return);
		OCLSyntaxParser.logicalOrExpression_return logicalOrExpression67 = default(OCLSyntaxParser.logicalOrExpression_return);

		object opToken_tree = default(object);
		RewriteRuleITokenStream stream_101=new RewriteRuleITokenStream(adaptor,"token 101");
		RewriteRuleSubtreeStream stream_logicalOrExpression=new RewriteRuleSubtreeStream(adaptor,"rule logicalOrExpression");
		try { DebugEnterRule(GrammarFileName, "logicalXorExpression");
		DebugLocation(96, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:97:2: ( ( logicalOrExpression -> logicalOrExpression ) (opToken= 'xor' expr= logicalOrExpression -> ^( INFIX $opToken $logicalXorExpression $expr) )* )
			DebugEnterAlt(1);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:97:4: ( logicalOrExpression -> logicalOrExpression ) (opToken= 'xor' expr= logicalOrExpression -> ^( INFIX $opToken $logicalXorExpression $expr) )*
			{
			DebugLocation(97, 4);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:97:4: ( logicalOrExpression -> logicalOrExpression )
			DebugEnterAlt(1);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:97:5: logicalOrExpression
			{
			DebugLocation(97, 5);
			PushFollow(Follow._logicalOrExpression_in_logicalXorExpression464);
			logicalOrExpression67=logicalOrExpression();
			PopFollow();

			stream_logicalOrExpression.Add(logicalOrExpression67.Tree);


			{
			// AST REWRITE
			// elements: logicalOrExpression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 97:24: -> logicalOrExpression
			{
				DebugLocation(97, 26);
				adaptor.AddChild(root_0, stream_logicalOrExpression.NextTree());

			}

			retval.Tree = root_0;
			}

			}

			DebugLocation(97, 47);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:97:47: (opToken= 'xor' expr= logicalOrExpression -> ^( INFIX $opToken $logicalXorExpression $expr) )*
			try { DebugEnterSubRule(21);
			while (true)
			{
				int alt21=2;
				try { DebugEnterDecision(21, false);
				int LA21_0 = input.LA(1);

				if ((LA21_0==101))
				{
					alt21 = 1;
				}


				} finally { DebugExitDecision(21); }
				switch ( alt21 )
				{
				case 1:
					DebugEnterAlt(1);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:97:48: opToken= 'xor' expr= logicalOrExpression
					{
					DebugLocation(97, 55);
					opToken=(CommonToken)Match(input,101,Follow._101_in_logicalXorExpression472);  
					stream_101.Add(opToken);

					DebugLocation(97, 66);
					PushFollow(Follow._logicalOrExpression_in_logicalXorExpression476);
					expr=logicalOrExpression();
					PopFollow();

					stream_logicalOrExpression.Add(expr.Tree);


					{
					// AST REWRITE
					// elements: opToken, logicalXorExpression, expr
					// token labels: opToken
					// rule labels: expr, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					retval.Tree = root_0;
					RewriteRuleITokenStream stream_opToken=new RewriteRuleITokenStream(adaptor,"token opToken",opToken);
					RewriteRuleSubtreeStream stream_expr=new RewriteRuleSubtreeStream(adaptor,"rule expr",expr!=null?expr.Tree:null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (object)adaptor.Nil();
					// 97:86: -> ^( INFIX $opToken $logicalXorExpression $expr)
					{
						DebugLocation(97, 88);
						// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:97:88: ^( INFIX $opToken $logicalXorExpression $expr)
						{
						object root_1 = (object)adaptor.Nil();
						DebugLocation(97, 90);
						root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(INFIX, "INFIX"), root_1);

						DebugLocation(97, 97);
						adaptor.AddChild(root_1, stream_opToken.NextNode());
						DebugLocation(97, 106);
						adaptor.AddChild(root_1, stream_retval.NextTree());
						DebugLocation(97, 128);
						adaptor.AddChild(root_1, stream_expr.NextTree());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}

					}
					break;

				default:
					goto loop21;
				}
			}

			loop21:
				;

			} finally { DebugExitSubRule(21); }


			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("logicalXorExpression", 17);
			LeaveRule("logicalXorExpression", 17);
			LeaveRule_logicalXorExpression();
		}
		DebugLocation(98, 1);
		} finally { DebugExitRule(GrammarFileName, "logicalXorExpression"); }
		return retval;

	}
	// $ANTLR end "logicalXorExpression"

	private sealed partial class logicalOrExpression_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public logicalOrExpression_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_logicalOrExpression();
	partial void LeaveRule_logicalOrExpression();

	// $ANTLR start "logicalOrExpression"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:99:1: logicalOrExpression : ( logicalAndExpression -> logicalAndExpression ) (opToken= 'or' expr= logicalAndExpression -> ^( INFIX $opToken $logicalOrExpression $expr) )* ;
	[GrammarRule("logicalOrExpression")]
	private OCLSyntaxParser.logicalOrExpression_return logicalOrExpression()
	{
		EnterRule_logicalOrExpression();
		EnterRule("logicalOrExpression", 18);
		TraceIn("logicalOrExpression", 18);
		OCLSyntaxParser.logicalOrExpression_return retval = new OCLSyntaxParser.logicalOrExpression_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		CommonToken opToken = default(CommonToken);
		OCLSyntaxParser.logicalAndExpression_return expr = default(OCLSyntaxParser.logicalAndExpression_return);
		OCLSyntaxParser.logicalAndExpression_return logicalAndExpression68 = default(OCLSyntaxParser.logicalAndExpression_return);

		object opToken_tree = default(object);
		RewriteRuleITokenStream stream_96=new RewriteRuleITokenStream(adaptor,"token 96");
		RewriteRuleSubtreeStream stream_logicalAndExpression=new RewriteRuleSubtreeStream(adaptor,"rule logicalAndExpression");
		try { DebugEnterRule(GrammarFileName, "logicalOrExpression");
		DebugLocation(99, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:100:2: ( ( logicalAndExpression -> logicalAndExpression ) (opToken= 'or' expr= logicalAndExpression -> ^( INFIX $opToken $logicalOrExpression $expr) )* )
			DebugEnterAlt(1);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:100:4: ( logicalAndExpression -> logicalAndExpression ) (opToken= 'or' expr= logicalAndExpression -> ^( INFIX $opToken $logicalOrExpression $expr) )*
			{
			DebugLocation(100, 4);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:100:4: ( logicalAndExpression -> logicalAndExpression )
			DebugEnterAlt(1);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:100:5: logicalAndExpression
			{
			DebugLocation(100, 5);
			PushFollow(Follow._logicalAndExpression_in_logicalOrExpression502);
			logicalAndExpression68=logicalAndExpression();
			PopFollow();

			stream_logicalAndExpression.Add(logicalAndExpression68.Tree);


			{
			// AST REWRITE
			// elements: logicalAndExpression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 100:25: -> logicalAndExpression
			{
				DebugLocation(100, 27);
				adaptor.AddChild(root_0, stream_logicalAndExpression.NextTree());

			}

			retval.Tree = root_0;
			}

			}

			DebugLocation(100, 49);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:100:49: (opToken= 'or' expr= logicalAndExpression -> ^( INFIX $opToken $logicalOrExpression $expr) )*
			try { DebugEnterSubRule(22);
			while (true)
			{
				int alt22=2;
				try { DebugEnterDecision(22, false);
				int LA22_0 = input.LA(1);

				if ((LA22_0==96))
				{
					alt22 = 1;
				}


				} finally { DebugExitDecision(22); }
				switch ( alt22 )
				{
				case 1:
					DebugEnterAlt(1);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:100:50: opToken= 'or' expr= logicalAndExpression
					{
					DebugLocation(100, 57);
					opToken=(CommonToken)Match(input,96,Follow._96_in_logicalOrExpression510);  
					stream_96.Add(opToken);

					DebugLocation(100, 67);
					PushFollow(Follow._logicalAndExpression_in_logicalOrExpression514);
					expr=logicalAndExpression();
					PopFollow();

					stream_logicalAndExpression.Add(expr.Tree);


					{
					// AST REWRITE
					// elements: opToken, logicalOrExpression, expr
					// token labels: opToken
					// rule labels: expr, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					retval.Tree = root_0;
					RewriteRuleITokenStream stream_opToken=new RewriteRuleITokenStream(adaptor,"token opToken",opToken);
					RewriteRuleSubtreeStream stream_expr=new RewriteRuleSubtreeStream(adaptor,"rule expr",expr!=null?expr.Tree:null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (object)adaptor.Nil();
					// 100:88: -> ^( INFIX $opToken $logicalOrExpression $expr)
					{
						DebugLocation(100, 90);
						// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:100:90: ^( INFIX $opToken $logicalOrExpression $expr)
						{
						object root_1 = (object)adaptor.Nil();
						DebugLocation(100, 92);
						root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(INFIX, "INFIX"), root_1);

						DebugLocation(100, 99);
						adaptor.AddChild(root_1, stream_opToken.NextNode());
						DebugLocation(100, 108);
						adaptor.AddChild(root_1, stream_retval.NextTree());
						DebugLocation(100, 129);
						adaptor.AddChild(root_1, stream_expr.NextTree());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}

					}
					break;

				default:
					goto loop22;
				}
			}

			loop22:
				;

			} finally { DebugExitSubRule(22); }


			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("logicalOrExpression", 18);
			LeaveRule("logicalOrExpression", 18);
			LeaveRule_logicalOrExpression();
		}
		DebugLocation(101, 1);
		} finally { DebugExitRule(GrammarFileName, "logicalOrExpression"); }
		return retval;

	}
	// $ANTLR end "logicalOrExpression"

	private sealed partial class logicalAndExpression_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public logicalAndExpression_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_logicalAndExpression();
	partial void LeaveRule_logicalAndExpression();

	// $ANTLR start "logicalAndExpression"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:102:1: logicalAndExpression : ( relationalEqExpression -> relationalEqExpression ) (opToken= 'and' expr= relationalEqExpression -> ^( INFIX $opToken $logicalAndExpression $expr) )* ;
	[GrammarRule("logicalAndExpression")]
	private OCLSyntaxParser.logicalAndExpression_return logicalAndExpression()
	{
		EnterRule_logicalAndExpression();
		EnterRule("logicalAndExpression", 19);
		TraceIn("logicalAndExpression", 19);
		OCLSyntaxParser.logicalAndExpression_return retval = new OCLSyntaxParser.logicalAndExpression_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		CommonToken opToken = default(CommonToken);
		OCLSyntaxParser.relationalEqExpression_return expr = default(OCLSyntaxParser.relationalEqExpression_return);
		OCLSyntaxParser.relationalEqExpression_return relationalEqExpression69 = default(OCLSyntaxParser.relationalEqExpression_return);

		object opToken_tree = default(object);
		RewriteRuleITokenStream stream_81=new RewriteRuleITokenStream(adaptor,"token 81");
		RewriteRuleSubtreeStream stream_relationalEqExpression=new RewriteRuleSubtreeStream(adaptor,"rule relationalEqExpression");
		try { DebugEnterRule(GrammarFileName, "logicalAndExpression");
		DebugLocation(102, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:103:2: ( ( relationalEqExpression -> relationalEqExpression ) (opToken= 'and' expr= relationalEqExpression -> ^( INFIX $opToken $logicalAndExpression $expr) )* )
			DebugEnterAlt(1);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:103:4: ( relationalEqExpression -> relationalEqExpression ) (opToken= 'and' expr= relationalEqExpression -> ^( INFIX $opToken $logicalAndExpression $expr) )*
			{
			DebugLocation(103, 4);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:103:4: ( relationalEqExpression -> relationalEqExpression )
			DebugEnterAlt(1);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:103:5: relationalEqExpression
			{
			DebugLocation(103, 5);
			PushFollow(Follow._relationalEqExpression_in_logicalAndExpression540);
			relationalEqExpression69=relationalEqExpression();
			PopFollow();

			stream_relationalEqExpression.Add(relationalEqExpression69.Tree);


			{
			// AST REWRITE
			// elements: relationalEqExpression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 103:27: -> relationalEqExpression
			{
				DebugLocation(103, 29);
				adaptor.AddChild(root_0, stream_relationalEqExpression.NextTree());

			}

			retval.Tree = root_0;
			}

			}

			DebugLocation(103, 54);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:103:54: (opToken= 'and' expr= relationalEqExpression -> ^( INFIX $opToken $logicalAndExpression $expr) )*
			try { DebugEnterSubRule(23);
			while (true)
			{
				int alt23=2;
				try { DebugEnterDecision(23, false);
				int LA23_0 = input.LA(1);

				if ((LA23_0==81))
				{
					alt23 = 1;
				}


				} finally { DebugExitDecision(23); }
				switch ( alt23 )
				{
				case 1:
					DebugEnterAlt(1);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:103:55: opToken= 'and' expr= relationalEqExpression
					{
					DebugLocation(103, 62);
					opToken=(CommonToken)Match(input,81,Follow._81_in_logicalAndExpression549);  
					stream_81.Add(opToken);

					DebugLocation(103, 73);
					PushFollow(Follow._relationalEqExpression_in_logicalAndExpression553);
					expr=relationalEqExpression();
					PopFollow();

					stream_relationalEqExpression.Add(expr.Tree);


					{
					// AST REWRITE
					// elements: opToken, logicalAndExpression, expr
					// token labels: opToken
					// rule labels: expr, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					retval.Tree = root_0;
					RewriteRuleITokenStream stream_opToken=new RewriteRuleITokenStream(adaptor,"token opToken",opToken);
					RewriteRuleSubtreeStream stream_expr=new RewriteRuleSubtreeStream(adaptor,"rule expr",expr!=null?expr.Tree:null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (object)adaptor.Nil();
					// 103:96: -> ^( INFIX $opToken $logicalAndExpression $expr)
					{
						DebugLocation(103, 98);
						// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:103:98: ^( INFIX $opToken $logicalAndExpression $expr)
						{
						object root_1 = (object)adaptor.Nil();
						DebugLocation(103, 100);
						root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(INFIX, "INFIX"), root_1);

						DebugLocation(103, 107);
						adaptor.AddChild(root_1, stream_opToken.NextNode());
						DebugLocation(103, 116);
						adaptor.AddChild(root_1, stream_retval.NextTree());
						DebugLocation(103, 138);
						adaptor.AddChild(root_1, stream_expr.NextTree());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}

					}
					break;

				default:
					goto loop23;
				}
			}

			loop23:
				;

			} finally { DebugExitSubRule(23); }


			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("logicalAndExpression", 19);
			LeaveRule("logicalAndExpression", 19);
			LeaveRule_logicalAndExpression();
		}
		DebugLocation(104, 1);
		} finally { DebugExitRule(GrammarFileName, "logicalAndExpression"); }
		return retval;

	}
	// $ANTLR end "logicalAndExpression"

	private sealed partial class relationalEqExpression_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public relationalEqExpression_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_relationalEqExpression();
	partial void LeaveRule_relationalEqExpression();

	// $ANTLR start "relationalEqExpression"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:106:1: relationalEqExpression : ( relationalNotEqExprassion -> relationalNotEqExprassion ) ( (opToken= '=' |opToken= '<>' ) expr= relationalNotEqExprassion -> ^( INFIX $opToken $relationalEqExpression $expr) )* ;
	[GrammarRule("relationalEqExpression")]
	private OCLSyntaxParser.relationalEqExpression_return relationalEqExpression()
	{
		EnterRule_relationalEqExpression();
		EnterRule("relationalEqExpression", 20);
		TraceIn("relationalEqExpression", 20);
		OCLSyntaxParser.relationalEqExpression_return retval = new OCLSyntaxParser.relationalEqExpression_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		CommonToken opToken = default(CommonToken);
		OCLSyntaxParser.relationalNotEqExprassion_return expr = default(OCLSyntaxParser.relationalNotEqExprassion_return);
		OCLSyntaxParser.relationalNotEqExprassion_return relationalNotEqExprassion70 = default(OCLSyntaxParser.relationalNotEqExprassion_return);

		object opToken_tree = default(object);
		RewriteRuleITokenStream stream_57=new RewriteRuleITokenStream(adaptor,"token 57");
		RewriteRuleITokenStream stream_56=new RewriteRuleITokenStream(adaptor,"token 56");
		RewriteRuleSubtreeStream stream_relationalNotEqExprassion=new RewriteRuleSubtreeStream(adaptor,"rule relationalNotEqExprassion");
		try { DebugEnterRule(GrammarFileName, "relationalEqExpression");
		DebugLocation(106, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:107:2: ( ( relationalNotEqExprassion -> relationalNotEqExprassion ) ( (opToken= '=' |opToken= '<>' ) expr= relationalNotEqExprassion -> ^( INFIX $opToken $relationalEqExpression $expr) )* )
			DebugEnterAlt(1);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:107:4: ( relationalNotEqExprassion -> relationalNotEqExprassion ) ( (opToken= '=' |opToken= '<>' ) expr= relationalNotEqExprassion -> ^( INFIX $opToken $relationalEqExpression $expr) )*
			{
			DebugLocation(107, 4);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:107:4: ( relationalNotEqExprassion -> relationalNotEqExprassion )
			DebugEnterAlt(1);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:107:5: relationalNotEqExprassion
			{
			DebugLocation(107, 5);
			PushFollow(Follow._relationalNotEqExprassion_in_relationalEqExpression580);
			relationalNotEqExprassion70=relationalNotEqExprassion();
			PopFollow();

			stream_relationalNotEqExprassion.Add(relationalNotEqExprassion70.Tree);


			{
			// AST REWRITE
			// elements: relationalNotEqExprassion
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 107:30: -> relationalNotEqExprassion
			{
				DebugLocation(107, 32);
				adaptor.AddChild(root_0, stream_relationalNotEqExprassion.NextTree());

			}

			retval.Tree = root_0;
			}

			}

			DebugLocation(107, 59);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:107:59: ( (opToken= '=' |opToken= '<>' ) expr= relationalNotEqExprassion -> ^( INFIX $opToken $relationalEqExpression $expr) )*
			try { DebugEnterSubRule(25);
			while (true)
			{
				int alt25=2;
				try { DebugEnterDecision(25, false);
				int LA25_0 = input.LA(1);

				if ((LA25_0==57))
				{
					alt25 = 1;
				}
				else if ((LA25_0==56))
				{
					alt25 = 1;
				}


				} finally { DebugExitDecision(25); }
				switch ( alt25 )
				{
				case 1:
					DebugEnterAlt(1);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:107:60: (opToken= '=' |opToken= '<>' ) expr= relationalNotEqExprassion
					{
					DebugLocation(107, 60);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:107:60: (opToken= '=' |opToken= '<>' )
					int alt24=2;
					try { DebugEnterSubRule(24);
					try { DebugEnterDecision(24, false);
					int LA24_0 = input.LA(1);

					if ((LA24_0==57))
					{
						alt24 = 1;
					}
					else if ((LA24_0==56))
					{
						alt24 = 2;
					}
					else
					{
						NoViableAltException nvae = new NoViableAltException("", 24, 0, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					} finally { DebugExitDecision(24); }
					switch (alt24)
					{
					case 1:
						DebugEnterAlt(1);
						// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:107:61: opToken= '='
						{
						DebugLocation(107, 68);
						opToken=(CommonToken)Match(input,57,Follow._57_in_relationalEqExpression589);  
						stream_57.Add(opToken);


						}
						break;
					case 2:
						DebugEnterAlt(2);
						// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:107:73: opToken= '<>'
						{
						DebugLocation(107, 80);
						opToken=(CommonToken)Match(input,56,Follow._56_in_relationalEqExpression593);  
						stream_56.Add(opToken);


						}
						break;

					}
					} finally { DebugExitSubRule(24); }

					DebugLocation(107, 91);
					PushFollow(Follow._relationalNotEqExprassion_in_relationalEqExpression598);
					expr=relationalNotEqExprassion();
					PopFollow();

					stream_relationalNotEqExprassion.Add(expr.Tree);


					{
					// AST REWRITE
					// elements: opToken, relationalEqExpression, expr
					// token labels: opToken
					// rule labels: expr, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					retval.Tree = root_0;
					RewriteRuleITokenStream stream_opToken=new RewriteRuleITokenStream(adaptor,"token opToken",opToken);
					RewriteRuleSubtreeStream stream_expr=new RewriteRuleSubtreeStream(adaptor,"rule expr",expr!=null?expr.Tree:null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (object)adaptor.Nil();
					// 107:117: -> ^( INFIX $opToken $relationalEqExpression $expr)
					{
						DebugLocation(107, 119);
						// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:107:119: ^( INFIX $opToken $relationalEqExpression $expr)
						{
						object root_1 = (object)adaptor.Nil();
						DebugLocation(107, 121);
						root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(INFIX, "INFIX"), root_1);

						DebugLocation(107, 128);
						adaptor.AddChild(root_1, stream_opToken.NextNode());
						DebugLocation(107, 137);
						adaptor.AddChild(root_1, stream_retval.NextTree());
						DebugLocation(107, 161);
						adaptor.AddChild(root_1, stream_expr.NextTree());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}

					}
					break;

				default:
					goto loop25;
				}
			}

			loop25:
				;

			} finally { DebugExitSubRule(25); }


			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("relationalEqExpression", 20);
			LeaveRule("relationalEqExpression", 20);
			LeaveRule_relationalEqExpression();
		}
		DebugLocation(108, 1);
		} finally { DebugExitRule(GrammarFileName, "relationalEqExpression"); }
		return retval;

	}
	// $ANTLR end "relationalEqExpression"

	private sealed partial class relationalNotEqExprassion_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public relationalNotEqExprassion_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_relationalNotEqExprassion();
	partial void LeaveRule_relationalNotEqExprassion();

	// $ANTLR start "relationalNotEqExprassion"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:109:1: relationalNotEqExprassion : ( additiveExpression -> additiveExpression ) ( (opToken= '<' |opToken= '>' |opToken= '<=' |opToken= '>=' ) expr= additiveExpression -> ^( INFIX $opToken $relationalNotEqExprassion $expr) )* ;
	[GrammarRule("relationalNotEqExprassion")]
	private OCLSyntaxParser.relationalNotEqExprassion_return relationalNotEqExprassion()
	{
		EnterRule_relationalNotEqExprassion();
		EnterRule("relationalNotEqExprassion", 21);
		TraceIn("relationalNotEqExprassion", 21);
		OCLSyntaxParser.relationalNotEqExprassion_return retval = new OCLSyntaxParser.relationalNotEqExprassion_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		CommonToken opToken = default(CommonToken);
		OCLSyntaxParser.additiveExpression_return expr = default(OCLSyntaxParser.additiveExpression_return);
		OCLSyntaxParser.additiveExpression_return additiveExpression71 = default(OCLSyntaxParser.additiveExpression_return);

		object opToken_tree = default(object);
		RewriteRuleITokenStream stream_54=new RewriteRuleITokenStream(adaptor,"token 54");
		RewriteRuleITokenStream stream_58=new RewriteRuleITokenStream(adaptor,"token 58");
		RewriteRuleITokenStream stream_55=new RewriteRuleITokenStream(adaptor,"token 55");
		RewriteRuleITokenStream stream_59=new RewriteRuleITokenStream(adaptor,"token 59");
		RewriteRuleSubtreeStream stream_additiveExpression=new RewriteRuleSubtreeStream(adaptor,"rule additiveExpression");
		try { DebugEnterRule(GrammarFileName, "relationalNotEqExprassion");
		DebugLocation(109, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:110:2: ( ( additiveExpression -> additiveExpression ) ( (opToken= '<' |opToken= '>' |opToken= '<=' |opToken= '>=' ) expr= additiveExpression -> ^( INFIX $opToken $relationalNotEqExprassion $expr) )* )
			DebugEnterAlt(1);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:110:4: ( additiveExpression -> additiveExpression ) ( (opToken= '<' |opToken= '>' |opToken= '<=' |opToken= '>=' ) expr= additiveExpression -> ^( INFIX $opToken $relationalNotEqExprassion $expr) )*
			{
			DebugLocation(110, 4);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:110:4: ( additiveExpression -> additiveExpression )
			DebugEnterAlt(1);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:110:5: additiveExpression
			{
			DebugLocation(110, 5);
			PushFollow(Follow._additiveExpression_in_relationalNotEqExprassion627);
			additiveExpression71=additiveExpression();
			PopFollow();

			stream_additiveExpression.Add(additiveExpression71.Tree);


			{
			// AST REWRITE
			// elements: additiveExpression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 110:24: -> additiveExpression
			{
				DebugLocation(110, 26);
				adaptor.AddChild(root_0, stream_additiveExpression.NextTree());

			}

			retval.Tree = root_0;
			}

			}

			DebugLocation(110, 46);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:110:46: ( (opToken= '<' |opToken= '>' |opToken= '<=' |opToken= '>=' ) expr= additiveExpression -> ^( INFIX $opToken $relationalNotEqExprassion $expr) )*
			try { DebugEnterSubRule(27);
			while (true)
			{
				int alt27=2;
				try { DebugEnterDecision(27, false);
				switch (input.LA(1))
				{
				case 54:
					{
					alt27 = 1;
					}
					break;
				case 58:
					{
					alt27 = 1;
					}
					break;
				case 55:
					{
					alt27 = 1;
					}
					break;
				case 59:
					{
					alt27 = 1;
					}
					break;

				}

				} finally { DebugExitDecision(27); }
				switch ( alt27 )
				{
				case 1:
					DebugEnterAlt(1);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:110:47: (opToken= '<' |opToken= '>' |opToken= '<=' |opToken= '>=' ) expr= additiveExpression
					{
					DebugLocation(110, 47);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:110:47: (opToken= '<' |opToken= '>' |opToken= '<=' |opToken= '>=' )
					int alt26=4;
					try { DebugEnterSubRule(26);
					try { DebugEnterDecision(26, false);
					switch (input.LA(1))
					{
					case 54:
						{
						alt26 = 1;
						}
						break;
					case 58:
						{
						alt26 = 2;
						}
						break;
					case 55:
						{
						alt26 = 3;
						}
						break;
					case 59:
						{
						alt26 = 4;
						}
						break;
					default:
						{
							NoViableAltException nvae = new NoViableAltException("", 26, 0, input);
							DebugRecognitionException(nvae);
							throw nvae;
						}
					}

					} finally { DebugExitDecision(26); }
					switch (alt26)
					{
					case 1:
						DebugEnterAlt(1);
						// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:110:48: opToken= '<'
						{
						DebugLocation(110, 55);
						opToken=(CommonToken)Match(input,54,Follow._54_in_relationalNotEqExprassion637);  
						stream_54.Add(opToken);


						}
						break;
					case 2:
						DebugEnterAlt(2);
						// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:110:61: opToken= '>'
						{
						DebugLocation(110, 68);
						opToken=(CommonToken)Match(input,58,Follow._58_in_relationalNotEqExprassion642);  
						stream_58.Add(opToken);


						}
						break;
					case 3:
						DebugEnterAlt(3);
						// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:110:74: opToken= '<='
						{
						DebugLocation(110, 81);
						opToken=(CommonToken)Match(input,55,Follow._55_in_relationalNotEqExprassion647);  
						stream_55.Add(opToken);


						}
						break;
					case 4:
						DebugEnterAlt(4);
						// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:110:88: opToken= '>='
						{
						DebugLocation(110, 95);
						opToken=(CommonToken)Match(input,59,Follow._59_in_relationalNotEqExprassion652);  
						stream_59.Add(opToken);


						}
						break;

					}
					} finally { DebugExitSubRule(26); }

					DebugLocation(110, 106);
					PushFollow(Follow._additiveExpression_in_relationalNotEqExprassion657);
					expr=additiveExpression();
					PopFollow();

					stream_additiveExpression.Add(expr.Tree);


					{
					// AST REWRITE
					// elements: opToken, relationalNotEqExprassion, expr
					// token labels: opToken
					// rule labels: expr, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					retval.Tree = root_0;
					RewriteRuleITokenStream stream_opToken=new RewriteRuleITokenStream(adaptor,"token opToken",opToken);
					RewriteRuleSubtreeStream stream_expr=new RewriteRuleSubtreeStream(adaptor,"rule expr",expr!=null?expr.Tree:null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (object)adaptor.Nil();
					// 110:125: -> ^( INFIX $opToken $relationalNotEqExprassion $expr)
					{
						DebugLocation(110, 127);
						// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:110:127: ^( INFIX $opToken $relationalNotEqExprassion $expr)
						{
						object root_1 = (object)adaptor.Nil();
						DebugLocation(110, 129);
						root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(INFIX, "INFIX"), root_1);

						DebugLocation(110, 136);
						adaptor.AddChild(root_1, stream_opToken.NextNode());
						DebugLocation(110, 145);
						adaptor.AddChild(root_1, stream_retval.NextTree());
						DebugLocation(110, 172);
						adaptor.AddChild(root_1, stream_expr.NextTree());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}

					}
					break;

				default:
					goto loop27;
				}
			}

			loop27:
				;

			} finally { DebugExitSubRule(27); }


			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("relationalNotEqExprassion", 21);
			LeaveRule("relationalNotEqExprassion", 21);
			LeaveRule_relationalNotEqExprassion();
		}
		DebugLocation(111, 1);
		} finally { DebugExitRule(GrammarFileName, "relationalNotEqExprassion"); }
		return retval;

	}
	// $ANTLR end "relationalNotEqExprassion"

	private sealed partial class additiveExpression_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public additiveExpression_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_additiveExpression();
	partial void LeaveRule_additiveExpression();

	// $ANTLR start "additiveExpression"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:113:1: additiveExpression : ( multiplicativeExpression -> multiplicativeExpression ) ( (opToken= '+' |opToken= '-' ) expr= multiplicativeExpression -> ^( INFIX $opToken $additiveExpression $expr) )* ;
	[GrammarRule("additiveExpression")]
	private OCLSyntaxParser.additiveExpression_return additiveExpression()
	{
		EnterRule_additiveExpression();
		EnterRule("additiveExpression", 22);
		TraceIn("additiveExpression", 22);
		OCLSyntaxParser.additiveExpression_return retval = new OCLSyntaxParser.additiveExpression_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		CommonToken opToken = default(CommonToken);
		OCLSyntaxParser.multiplicativeExpression_return expr = default(OCLSyntaxParser.multiplicativeExpression_return);
		OCLSyntaxParser.multiplicativeExpression_return multiplicativeExpression72 = default(OCLSyntaxParser.multiplicativeExpression_return);

		object opToken_tree = default(object);
		RewriteRuleITokenStream stream_44=new RewriteRuleITokenStream(adaptor,"token 44");
		RewriteRuleITokenStream stream_46=new RewriteRuleITokenStream(adaptor,"token 46");
		RewriteRuleSubtreeStream stream_multiplicativeExpression=new RewriteRuleSubtreeStream(adaptor,"rule multiplicativeExpression");
		try { DebugEnterRule(GrammarFileName, "additiveExpression");
		DebugLocation(113, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:114:2: ( ( multiplicativeExpression -> multiplicativeExpression ) ( (opToken= '+' |opToken= '-' ) expr= multiplicativeExpression -> ^( INFIX $opToken $additiveExpression $expr) )* )
			DebugEnterAlt(1);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:114:4: ( multiplicativeExpression -> multiplicativeExpression ) ( (opToken= '+' |opToken= '-' ) expr= multiplicativeExpression -> ^( INFIX $opToken $additiveExpression $expr) )*
			{
			DebugLocation(114, 4);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:114:4: ( multiplicativeExpression -> multiplicativeExpression )
			DebugEnterAlt(1);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:114:5: multiplicativeExpression
			{
			DebugLocation(114, 5);
			PushFollow(Follow._multiplicativeExpression_in_additiveExpression685);
			multiplicativeExpression72=multiplicativeExpression();
			PopFollow();

			stream_multiplicativeExpression.Add(multiplicativeExpression72.Tree);


			{
			// AST REWRITE
			// elements: multiplicativeExpression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 114:29: -> multiplicativeExpression
			{
				DebugLocation(114, 31);
				adaptor.AddChild(root_0, stream_multiplicativeExpression.NextTree());

			}

			retval.Tree = root_0;
			}

			}

			DebugLocation(114, 57);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:114:57: ( (opToken= '+' |opToken= '-' ) expr= multiplicativeExpression -> ^( INFIX $opToken $additiveExpression $expr) )*
			try { DebugEnterSubRule(29);
			while (true)
			{
				int alt29=2;
				try { DebugEnterDecision(29, false);
				int LA29_0 = input.LA(1);

				if ((LA29_0==44))
				{
					alt29 = 1;
				}
				else if ((LA29_0==46))
				{
					alt29 = 1;
				}


				} finally { DebugExitDecision(29); }
				switch ( alt29 )
				{
				case 1:
					DebugEnterAlt(1);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:114:58: (opToken= '+' |opToken= '-' ) expr= multiplicativeExpression
					{
					DebugLocation(114, 58);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:114:58: (opToken= '+' |opToken= '-' )
					int alt28=2;
					try { DebugEnterSubRule(28);
					try { DebugEnterDecision(28, false);
					int LA28_0 = input.LA(1);

					if ((LA28_0==44))
					{
						alt28 = 1;
					}
					else if ((LA28_0==46))
					{
						alt28 = 2;
					}
					else
					{
						NoViableAltException nvae = new NoViableAltException("", 28, 0, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					} finally { DebugExitDecision(28); }
					switch (alt28)
					{
					case 1:
						DebugEnterAlt(1);
						// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:114:59: opToken= '+'
						{
						DebugLocation(114, 66);
						opToken=(CommonToken)Match(input,44,Follow._44_in_additiveExpression694);  
						stream_44.Add(opToken);


						}
						break;
					case 2:
						DebugEnterAlt(2);
						// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:114:71: opToken= '-'
						{
						DebugLocation(114, 78);
						opToken=(CommonToken)Match(input,46,Follow._46_in_additiveExpression698);  
						stream_46.Add(opToken);


						}
						break;

					}
					} finally { DebugExitSubRule(28); }

					DebugLocation(114, 88);
					PushFollow(Follow._multiplicativeExpression_in_additiveExpression704);
					expr=multiplicativeExpression();
					PopFollow();

					stream_multiplicativeExpression.Add(expr.Tree);


					{
					// AST REWRITE
					// elements: opToken, additiveExpression, expr
					// token labels: opToken
					// rule labels: expr, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					retval.Tree = root_0;
					RewriteRuleITokenStream stream_opToken=new RewriteRuleITokenStream(adaptor,"token opToken",opToken);
					RewriteRuleSubtreeStream stream_expr=new RewriteRuleSubtreeStream(adaptor,"rule expr",expr!=null?expr.Tree:null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (object)adaptor.Nil();
					// 114:114: -> ^( INFIX $opToken $additiveExpression $expr)
					{
						DebugLocation(114, 116);
						// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:114:116: ^( INFIX $opToken $additiveExpression $expr)
						{
						object root_1 = (object)adaptor.Nil();
						DebugLocation(114, 118);
						root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(INFIX, "INFIX"), root_1);

						DebugLocation(114, 125);
						adaptor.AddChild(root_1, stream_opToken.NextNode());
						DebugLocation(114, 134);
						adaptor.AddChild(root_1, stream_retval.NextTree());
						DebugLocation(114, 154);
						adaptor.AddChild(root_1, stream_expr.NextTree());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}

					}
					break;

				default:
					goto loop29;
				}
			}

			loop29:
				;

			} finally { DebugExitSubRule(29); }


			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("additiveExpression", 22);
			LeaveRule("additiveExpression", 22);
			LeaveRule_additiveExpression();
		}
		DebugLocation(115, 1);
		} finally { DebugExitRule(GrammarFileName, "additiveExpression"); }
		return retval;

	}
	// $ANTLR end "additiveExpression"

	private sealed partial class multiplicativeExpression_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public multiplicativeExpression_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_multiplicativeExpression();
	partial void LeaveRule_multiplicativeExpression();

	// $ANTLR start "multiplicativeExpression"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:117:1: multiplicativeExpression : ( unaryExpression -> unaryExpression ) ( (opToken= '*' |opToken= '/' ) expr= unaryExpression -> ^( INFIX $opToken $multiplicativeExpression $expr) )* ;
	[GrammarRule("multiplicativeExpression")]
	private OCLSyntaxParser.multiplicativeExpression_return multiplicativeExpression()
	{
		EnterRule_multiplicativeExpression();
		EnterRule("multiplicativeExpression", 23);
		TraceIn("multiplicativeExpression", 23);
		OCLSyntaxParser.multiplicativeExpression_return retval = new OCLSyntaxParser.multiplicativeExpression_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		CommonToken opToken = default(CommonToken);
		OCLSyntaxParser.unaryExpression_return expr = default(OCLSyntaxParser.unaryExpression_return);
		OCLSyntaxParser.unaryExpression_return unaryExpression73 = default(OCLSyntaxParser.unaryExpression_return);

		object opToken_tree = default(object);
		RewriteRuleITokenStream stream_UnlimitedNaturalLiteralExp=new RewriteRuleITokenStream(adaptor,"token UnlimitedNaturalLiteralExp");
		RewriteRuleITokenStream stream_50=new RewriteRuleITokenStream(adaptor,"token 50");
		RewriteRuleSubtreeStream stream_unaryExpression=new RewriteRuleSubtreeStream(adaptor,"rule unaryExpression");
		try { DebugEnterRule(GrammarFileName, "multiplicativeExpression");
		DebugLocation(117, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:118:2: ( ( unaryExpression -> unaryExpression ) ( (opToken= '*' |opToken= '/' ) expr= unaryExpression -> ^( INFIX $opToken $multiplicativeExpression $expr) )* )
			DebugEnterAlt(1);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:118:4: ( unaryExpression -> unaryExpression ) ( (opToken= '*' |opToken= '/' ) expr= unaryExpression -> ^( INFIX $opToken $multiplicativeExpression $expr) )*
			{
			DebugLocation(118, 4);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:118:4: ( unaryExpression -> unaryExpression )
			DebugEnterAlt(1);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:118:5: unaryExpression
			{
			DebugLocation(118, 5);
			PushFollow(Follow._unaryExpression_in_multiplicativeExpression733);
			unaryExpression73=unaryExpression();
			PopFollow();

			stream_unaryExpression.Add(unaryExpression73.Tree);


			{
			// AST REWRITE
			// elements: unaryExpression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 118:20: -> unaryExpression
			{
				DebugLocation(118, 22);
				adaptor.AddChild(root_0, stream_unaryExpression.NextTree());

			}

			retval.Tree = root_0;
			}

			}

			DebugLocation(118, 39);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:118:39: ( (opToken= '*' |opToken= '/' ) expr= unaryExpression -> ^( INFIX $opToken $multiplicativeExpression $expr) )*
			try { DebugEnterSubRule(31);
			while (true)
			{
				int alt31=2;
				try { DebugEnterDecision(31, false);
				int LA31_0 = input.LA(1);

				if ((LA31_0==UnlimitedNaturalLiteralExp))
				{
					alt31 = 1;
				}
				else if ((LA31_0==50))
				{
					alt31 = 1;
				}


				} finally { DebugExitDecision(31); }
				switch ( alt31 )
				{
				case 1:
					DebugEnterAlt(1);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:118:40: (opToken= '*' |opToken= '/' ) expr= unaryExpression
					{
					DebugLocation(118, 40);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:118:40: (opToken= '*' |opToken= '/' )
					int alt30=2;
					try { DebugEnterSubRule(30);
					try { DebugEnterDecision(30, false);
					int LA30_0 = input.LA(1);

					if ((LA30_0==UnlimitedNaturalLiteralExp))
					{
						alt30 = 1;
					}
					else if ((LA30_0==50))
					{
						alt30 = 2;
					}
					else
					{
						NoViableAltException nvae = new NoViableAltException("", 30, 0, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					} finally { DebugExitDecision(30); }
					switch (alt30)
					{
					case 1:
						DebugEnterAlt(1);
						// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:118:41: opToken= '*'
						{
						DebugLocation(118, 48);
						opToken=(CommonToken)Match(input,UnlimitedNaturalLiteralExp,Follow._UnlimitedNaturalLiteralExp_in_multiplicativeExpression742);  
						stream_UnlimitedNaturalLiteralExp.Add(opToken);


						}
						break;
					case 2:
						DebugEnterAlt(2);
						// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:118:53: opToken= '/'
						{
						DebugLocation(118, 60);
						opToken=(CommonToken)Match(input,50,Follow._50_in_multiplicativeExpression746);  
						stream_50.Add(opToken);


						}
						break;

					}
					} finally { DebugExitSubRule(30); }

					DebugLocation(118, 70);
					PushFollow(Follow._unaryExpression_in_multiplicativeExpression751);
					expr=unaryExpression();
					PopFollow();

					stream_unaryExpression.Add(expr.Tree);


					{
					// AST REWRITE
					// elements: opToken, multiplicativeExpression, expr
					// token labels: opToken
					// rule labels: expr, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					retval.Tree = root_0;
					RewriteRuleITokenStream stream_opToken=new RewriteRuleITokenStream(adaptor,"token opToken",opToken);
					RewriteRuleSubtreeStream stream_expr=new RewriteRuleSubtreeStream(adaptor,"rule expr",expr!=null?expr.Tree:null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (object)adaptor.Nil();
					// 118:86: -> ^( INFIX $opToken $multiplicativeExpression $expr)
					{
						DebugLocation(118, 88);
						// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:118:88: ^( INFIX $opToken $multiplicativeExpression $expr)
						{
						object root_1 = (object)adaptor.Nil();
						DebugLocation(118, 90);
						root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(INFIX, "INFIX"), root_1);

						DebugLocation(118, 97);
						adaptor.AddChild(root_1, stream_opToken.NextNode());
						DebugLocation(118, 106);
						adaptor.AddChild(root_1, stream_retval.NextTree());
						DebugLocation(118, 132);
						adaptor.AddChild(root_1, stream_expr.NextTree());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}

					}
					break;

				default:
					goto loop31;
				}
			}

			loop31:
				;

			} finally { DebugExitSubRule(31); }


			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("multiplicativeExpression", 23);
			LeaveRule("multiplicativeExpression", 23);
			LeaveRule_multiplicativeExpression();
		}
		DebugLocation(119, 1);
		} finally { DebugExitRule(GrammarFileName, "multiplicativeExpression"); }
		return retval;

	}
	// $ANTLR end "multiplicativeExpression"

	private sealed partial class unaryExpression_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public unaryExpression_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_unaryExpression();
	partial void LeaveRule_unaryExpression();

	// $ANTLR start "unaryExpression"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:121:1: unaryExpression : ( (opToken= '-' |opToken= 'not' ) term= termExpression -> ^( UNARY $opToken $term) | termExpression );
	[GrammarRule("unaryExpression")]
	private OCLSyntaxParser.unaryExpression_return unaryExpression()
	{
		EnterRule_unaryExpression();
		EnterRule("unaryExpression", 24);
		TraceIn("unaryExpression", 24);
		OCLSyntaxParser.unaryExpression_return retval = new OCLSyntaxParser.unaryExpression_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		CommonToken opToken = default(CommonToken);
		OCLSyntaxParser.termExpression_return term = default(OCLSyntaxParser.termExpression_return);
		OCLSyntaxParser.termExpression_return termExpression74 = default(OCLSyntaxParser.termExpression_return);

		object opToken_tree = default(object);
		RewriteRuleITokenStream stream_46=new RewriteRuleITokenStream(adaptor,"token 46");
		RewriteRuleITokenStream stream_95=new RewriteRuleITokenStream(adaptor,"token 95");
		RewriteRuleSubtreeStream stream_termExpression=new RewriteRuleSubtreeStream(adaptor,"rule termExpression");
		try { DebugEnterRule(GrammarFileName, "unaryExpression");
		DebugLocation(121, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:122:2: ( (opToken= '-' |opToken= 'not' ) term= termExpression -> ^( UNARY $opToken $term) | termExpression )
			int alt33=2;
			try { DebugEnterDecision(33, false);
			int LA33_0 = input.LA(1);

			if ((LA33_0==46||LA33_0==95))
			{
				alt33 = 1;
			}
			else if ((LA33_0==BooleanLiteralExp||(LA33_0>=IntegerLiteralExp && LA33_0<=InvalidLiteralExp)||LA33_0==NullLiteralExp||(LA33_0>=RealLiteralExp && LA33_0<=SimpleName)||LA33_0==StringLiteralExp||LA33_0==UnlimitedNaturalLiteralExp||LA33_0==42||(LA33_0>=62 && LA33_0<=76)||LA33_0==88||(LA33_0>=93 && LA33_0<=94)))
			{
				alt33 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 33, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(33); }
			switch (alt33)
			{
			case 1:
				DebugEnterAlt(1);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:122:4: (opToken= '-' |opToken= 'not' ) term= termExpression
				{
				DebugLocation(122, 4);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:122:4: (opToken= '-' |opToken= 'not' )
				int alt32=2;
				try { DebugEnterSubRule(32);
				try { DebugEnterDecision(32, false);
				int LA32_0 = input.LA(1);

				if ((LA32_0==46))
				{
					alt32 = 1;
				}
				else if ((LA32_0==95))
				{
					alt32 = 2;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 32, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				} finally { DebugExitDecision(32); }
				switch (alt32)
				{
				case 1:
					DebugEnterAlt(1);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:122:5: opToken= '-'
					{
					DebugLocation(122, 12);
					opToken=(CommonToken)Match(input,46,Follow._46_in_unaryExpression781);  
					stream_46.Add(opToken);


					}
					break;
				case 2:
					DebugEnterAlt(2);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:122:17: opToken= 'not'
					{
					DebugLocation(122, 24);
					opToken=(CommonToken)Match(input,95,Follow._95_in_unaryExpression785);  
					stream_95.Add(opToken);


					}
					break;

				}
				} finally { DebugExitSubRule(32); }

				DebugLocation(122, 36);
				PushFollow(Follow._termExpression_in_unaryExpression790);
				term=termExpression();
				PopFollow();

				stream_termExpression.Add(term.Tree);


				{
				// AST REWRITE
				// elements: opToken, term
				// token labels: opToken
				// rule labels: term, retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleITokenStream stream_opToken=new RewriteRuleITokenStream(adaptor,"token opToken",opToken);
				RewriteRuleSubtreeStream stream_term=new RewriteRuleSubtreeStream(adaptor,"rule term",term!=null?term.Tree:null);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 122:52: -> ^( UNARY $opToken $term)
				{
					DebugLocation(122, 54);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:122:54: ^( UNARY $opToken $term)
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(122, 56);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(UNARY, "UNARY"), root_1);

					DebugLocation(122, 63);
					adaptor.AddChild(root_1, stream_opToken.NextNode());
					DebugLocation(122, 72);
					adaptor.AddChild(root_1, stream_term.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:123:4: termExpression
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(123, 4);
				PushFollow(Follow._termExpression_in_unaryExpression806);
				termExpression74=termExpression();
				PopFollow();

				adaptor.AddChild(root_0, termExpression74.Tree);

				}
				break;

			}
			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("unaryExpression", 24);
			LeaveRule("unaryExpression", 24);
			LeaveRule_unaryExpression();
		}
		DebugLocation(124, 1);
		} finally { DebugExitRule(GrammarFileName, "unaryExpression"); }
		return retval;

	}
	// $ANTLR end "unaryExpression"

	private sealed partial class termExpression_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public termExpression_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_termExpression();
	partial void LeaveRule_termExpression();

	// $ANTLR start "termExpression"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:126:1: termExpression : ( primaryExperession -> primaryExperession ) ( ( (token= '.' |token= '->' ) expr= propertyCall -> ^( $token $termExpression $expr) ) | ( oclMessageExp -> MESSAGE oclMessageExp ) )* ;
	[GrammarRule("termExpression")]
	private OCLSyntaxParser.termExpression_return termExpression()
	{
		EnterRule_termExpression();
		EnterRule("termExpression", 25);
		TraceIn("termExpression", 25);
		OCLSyntaxParser.termExpression_return retval = new OCLSyntaxParser.termExpression_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		CommonToken token = default(CommonToken);
		OCLSyntaxParser.propertyCall_return expr = default(OCLSyntaxParser.propertyCall_return);
		OCLSyntaxParser.primaryExperession_return primaryExperession75 = default(OCLSyntaxParser.primaryExperession_return);
		OCLSyntaxParser.oclMessageExp_return oclMessageExp76 = default(OCLSyntaxParser.oclMessageExp_return);

		object token_tree = default(object);
		RewriteRuleITokenStream stream_48=new RewriteRuleITokenStream(adaptor,"token 48");
		RewriteRuleITokenStream stream_47=new RewriteRuleITokenStream(adaptor,"token 47");
		RewriteRuleSubtreeStream stream_primaryExperession=new RewriteRuleSubtreeStream(adaptor,"rule primaryExperession");
		RewriteRuleSubtreeStream stream_propertyCall=new RewriteRuleSubtreeStream(adaptor,"rule propertyCall");
		RewriteRuleSubtreeStream stream_oclMessageExp=new RewriteRuleSubtreeStream(adaptor,"rule oclMessageExp");
		try { DebugEnterRule(GrammarFileName, "termExpression");
		DebugLocation(126, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:127:2: ( ( primaryExperession -> primaryExperession ) ( ( (token= '.' |token= '->' ) expr= propertyCall -> ^( $token $termExpression $expr) ) | ( oclMessageExp -> MESSAGE oclMessageExp ) )* )
			DebugEnterAlt(1);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:127:4: ( primaryExperession -> primaryExperession ) ( ( (token= '.' |token= '->' ) expr= propertyCall -> ^( $token $termExpression $expr) ) | ( oclMessageExp -> MESSAGE oclMessageExp ) )*
			{
			DebugLocation(127, 4);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:127:4: ( primaryExperession -> primaryExperession )
			DebugEnterAlt(1);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:127:5: primaryExperession
			{
			DebugLocation(127, 5);
			PushFollow(Follow._primaryExperession_in_termExpression820);
			primaryExperession75=primaryExperession();
			PopFollow();

			stream_primaryExperession.Add(primaryExperession75.Tree);


			{
			// AST REWRITE
			// elements: primaryExperession
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 127:23: -> primaryExperession
			{
				DebugLocation(127, 25);
				adaptor.AddChild(root_0, stream_primaryExperession.NextTree());

			}

			retval.Tree = root_0;
			}

			}

			DebugLocation(127, 45);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:127:45: ( ( (token= '.' |token= '->' ) expr= propertyCall -> ^( $token $termExpression $expr) ) | ( oclMessageExp -> MESSAGE oclMessageExp ) )*
			try { DebugEnterSubRule(35);
			while (true)
			{
				int alt35=3;
				try { DebugEnterDecision(35, false);
				switch (input.LA(1))
				{
				case 48:
					{
					alt35 = 1;
					}
					break;
				case 47:
					{
					alt35 = 1;
					}
					break;
				case 80:
					{
					alt35 = 2;
					}
					break;
				case 79:
					{
					alt35 = 2;
					}
					break;

				}

				} finally { DebugExitDecision(35); }
				switch ( alt35 )
				{
				case 1:
					DebugEnterAlt(1);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:127:47: ( (token= '.' |token= '->' ) expr= propertyCall -> ^( $token $termExpression $expr) )
					{
					DebugLocation(127, 47);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:127:47: ( (token= '.' |token= '->' ) expr= propertyCall -> ^( $token $termExpression $expr) )
					DebugEnterAlt(1);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:127:48: (token= '.' |token= '->' ) expr= propertyCall
					{
					DebugLocation(127, 48);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:127:48: (token= '.' |token= '->' )
					int alt34=2;
					try { DebugEnterSubRule(34);
					try { DebugEnterDecision(34, false);
					int LA34_0 = input.LA(1);

					if ((LA34_0==48))
					{
						alt34 = 1;
					}
					else if ((LA34_0==47))
					{
						alt34 = 2;
					}
					else
					{
						NoViableAltException nvae = new NoViableAltException("", 34, 0, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					} finally { DebugExitDecision(34); }
					switch (alt34)
					{
					case 1:
						DebugEnterAlt(1);
						// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:127:49: token= '.'
						{
						DebugLocation(127, 54);
						token=(CommonToken)Match(input,48,Follow._48_in_termExpression831);  
						stream_48.Add(token);


						}
						break;
					case 2:
						DebugEnterAlt(2);
						// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:127:59: token= '->'
						{
						DebugLocation(127, 64);
						token=(CommonToken)Match(input,47,Follow._47_in_termExpression835);  
						stream_47.Add(token);


						}
						break;

					}
					} finally { DebugExitSubRule(34); }

					DebugLocation(127, 75);
					PushFollow(Follow._propertyCall_in_termExpression840);
					expr=propertyCall();
					PopFollow();

					stream_propertyCall.Add(expr.Tree);


					{
					// AST REWRITE
					// elements: token, termExpression, expr
					// token labels: token
					// rule labels: expr, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					retval.Tree = root_0;
					RewriteRuleITokenStream stream_token=new RewriteRuleITokenStream(adaptor,"token token",token);
					RewriteRuleSubtreeStream stream_expr=new RewriteRuleSubtreeStream(adaptor,"rule expr",expr!=null?expr.Tree:null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (object)adaptor.Nil();
					// 127:89: -> ^( $token $termExpression $expr)
					{
						DebugLocation(127, 92);
						// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:127:92: ^( $token $termExpression $expr)
						{
						object root_1 = (object)adaptor.Nil();
						DebugLocation(127, 95);
						root_1 = (object)adaptor.BecomeRoot(stream_token.NextNode(), root_1);

						DebugLocation(127, 102);
						adaptor.AddChild(root_1, stream_retval.NextTree());
						DebugLocation(127, 118);
						adaptor.AddChild(root_1, stream_expr.NextTree());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}

					}


					}
					break;
				case 2:
					DebugEnterAlt(2);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:128:6: ( oclMessageExp -> MESSAGE oclMessageExp )
					{
					DebugLocation(128, 6);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:128:6: ( oclMessageExp -> MESSAGE oclMessageExp )
					DebugEnterAlt(1);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:128:7: oclMessageExp
					{
					DebugLocation(128, 7);
					PushFollow(Follow._oclMessageExp_in_termExpression862);
					oclMessageExp76=oclMessageExp();
					PopFollow();

					stream_oclMessageExp.Add(oclMessageExp76.Tree);


					{
					// AST REWRITE
					// elements: oclMessageExp
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (object)adaptor.Nil();
					// 128:21: -> MESSAGE oclMessageExp
					{
						DebugLocation(128, 24);
						adaptor.AddChild(root_0, (object)adaptor.Create(MESSAGE, "MESSAGE"));
						DebugLocation(128, 32);
						adaptor.AddChild(root_0, stream_oclMessageExp.NextTree());

					}

					retval.Tree = root_0;
					}

					}


					}
					break;

				default:
					goto loop35;
				}
			}

			loop35:
				;

			} finally { DebugExitSubRule(35); }


			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("termExpression", 25);
			LeaveRule("termExpression", 25);
			LeaveRule_termExpression();
		}
		DebugLocation(131, 1);
		} finally { DebugExitRule(GrammarFileName, "termExpression"); }
		return retval;

	}
	// $ANTLR end "termExpression"

	private sealed partial class primaryExperession_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public primaryExperession_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_primaryExperession();
	partial void LeaveRule_primaryExperession();

	// $ANTLR start "primaryExperession"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:133:1: primaryExperession : ( collectionLiteralExpAndType -> ^( collectionLiteralExpAndType ) | tupleLiteralExp -> ^( tupleLiteralExp ) | primitiveLiteralExp -> ^( PRIMITIVELITERAL primitiveLiteralExp ) | enumAndType -> ^( TYPE enumAndType ) | propertyCall | '(' oclExpression ')' | ifExp | letExp );
	[GrammarRule("primaryExperession")]
	private OCLSyntaxParser.primaryExperession_return primaryExperession()
	{
		EnterRule_primaryExperession();
		EnterRule("primaryExperession", 26);
		TraceIn("primaryExperession", 26);
		OCLSyntaxParser.primaryExperession_return retval = new OCLSyntaxParser.primaryExperession_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		CommonToken char_literal82 = default(CommonToken);
		CommonToken char_literal84 = default(CommonToken);
		OCLSyntaxParser.collectionLiteralExpAndType_return collectionLiteralExpAndType77 = default(OCLSyntaxParser.collectionLiteralExpAndType_return);
		OCLSyntaxParser.tupleLiteralExp_return tupleLiteralExp78 = default(OCLSyntaxParser.tupleLiteralExp_return);
		OCLSyntaxParser.primitiveLiteralExp_return primitiveLiteralExp79 = default(OCLSyntaxParser.primitiveLiteralExp_return);
		OCLSyntaxParser.enumAndType_return enumAndType80 = default(OCLSyntaxParser.enumAndType_return);
		OCLSyntaxParser.propertyCall_return propertyCall81 = default(OCLSyntaxParser.propertyCall_return);
		OCLSyntaxParser.oclExpression_return oclExpression83 = default(OCLSyntaxParser.oclExpression_return);
		OCLSyntaxParser.ifExp_return ifExp85 = default(OCLSyntaxParser.ifExp_return);
		OCLSyntaxParser.letExp_return letExp86 = default(OCLSyntaxParser.letExp_return);

		object char_literal82_tree = default(object);
		object char_literal84_tree = default(object);
		RewriteRuleSubtreeStream stream_collectionLiteralExpAndType=new RewriteRuleSubtreeStream(adaptor,"rule collectionLiteralExpAndType");
		RewriteRuleSubtreeStream stream_tupleLiteralExp=new RewriteRuleSubtreeStream(adaptor,"rule tupleLiteralExp");
		RewriteRuleSubtreeStream stream_primitiveLiteralExp=new RewriteRuleSubtreeStream(adaptor,"rule primitiveLiteralExp");
		RewriteRuleSubtreeStream stream_enumAndType=new RewriteRuleSubtreeStream(adaptor,"rule enumAndType");
		try { DebugEnterRule(GrammarFileName, "primaryExperession");
		DebugLocation(133, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:134:2: ( collectionLiteralExpAndType -> ^( collectionLiteralExpAndType ) | tupleLiteralExp -> ^( tupleLiteralExp ) | primitiveLiteralExp -> ^( PRIMITIVELITERAL primitiveLiteralExp ) | enumAndType -> ^( TYPE enumAndType ) | propertyCall | '(' oclExpression ')' | ifExp | letExp )
			int alt36=8;
			try { DebugEnterDecision(36, false);
			try
			{
				alt36 = dfa36.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(36); }
			switch (alt36)
			{
			case 1:
				DebugEnterAlt(1);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:138:8: collectionLiteralExpAndType
				{
				DebugLocation(138, 8);
				PushFollow(Follow._collectionLiteralExpAndType_in_primaryExperession904);
				collectionLiteralExpAndType77=collectionLiteralExpAndType();
				PopFollow();

				stream_collectionLiteralExpAndType.Add(collectionLiteralExpAndType77.Tree);


				{
				// AST REWRITE
				// elements: collectionLiteralExpAndType
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 139:4: -> ^( collectionLiteralExpAndType )
				{
					DebugLocation(139, 6);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:139:6: ^( collectionLiteralExpAndType )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(139, 9);
					root_1 = (object)adaptor.BecomeRoot(stream_collectionLiteralExpAndType.NextNode(), root_1);

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:140:4: tupleLiteralExp
				{
				DebugLocation(140, 4);
				PushFollow(Follow._tupleLiteralExp_in_primaryExperession919);
				tupleLiteralExp78=tupleLiteralExp();
				PopFollow();

				stream_tupleLiteralExp.Add(tupleLiteralExp78.Tree);


				{
				// AST REWRITE
				// elements: tupleLiteralExp
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 141:4: -> ^( tupleLiteralExp )
				{
					DebugLocation(141, 6);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:141:6: ^( tupleLiteralExp )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(141, 9);
					root_1 = (object)adaptor.BecomeRoot(stream_tupleLiteralExp.NextNode(), root_1);

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:142:4: primitiveLiteralExp
				{
				DebugLocation(142, 4);
				PushFollow(Follow._primitiveLiteralExp_in_primaryExperession934);
				primitiveLiteralExp79=primitiveLiteralExp();
				PopFollow();

				stream_primitiveLiteralExp.Add(primitiveLiteralExp79.Tree);


				{
				// AST REWRITE
				// elements: primitiveLiteralExp
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 143:4: -> ^( PRIMITIVELITERAL primitiveLiteralExp )
				{
					DebugLocation(143, 6);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:143:6: ^( PRIMITIVELITERAL primitiveLiteralExp )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(143, 8);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(PRIMITIVELITERAL, "PRIMITIVELITERAL"), root_1);

					DebugLocation(143, 25);
					adaptor.AddChild(root_1, stream_primitiveLiteralExp.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:145:4: enumAndType
				{
				DebugLocation(145, 4);
				PushFollow(Follow._enumAndType_in_primaryExperession952);
				enumAndType80=enumAndType();
				PopFollow();

				stream_enumAndType.Add(enumAndType80.Tree);


				{
				// AST REWRITE
				// elements: enumAndType
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 146:4: -> ^( TYPE enumAndType )
				{
					DebugLocation(146, 6);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:146:6: ^( TYPE enumAndType )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(146, 8);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(TYPE, "TYPE"), root_1);

					DebugLocation(146, 13);
					adaptor.AddChild(root_1, stream_enumAndType.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:147:4: propertyCall
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(147, 4);
				PushFollow(Follow._propertyCall_in_primaryExperession968);
				propertyCall81=propertyCall();
				PopFollow();

				adaptor.AddChild(root_0, propertyCall81.Tree);

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:148:4: '(' oclExpression ')'
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(148, 7);
				char_literal82=(CommonToken)Match(input,42,Follow._42_in_primaryExperession973); 
				DebugLocation(148, 8);
				PushFollow(Follow._oclExpression_in_primaryExperession975);
				oclExpression83=oclExpression();
				PopFollow();

				adaptor.AddChild(root_0, oclExpression83.Tree);
				DebugLocation(148, 24);
				char_literal84=(CommonToken)Match(input,43,Follow._43_in_primaryExperession976); 

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:149:4: ifExp
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(149, 4);
				PushFollow(Follow._ifExp_in_primaryExperession982);
				ifExp85=ifExp();
				PopFollow();

				adaptor.AddChild(root_0, ifExp85.Tree);

				}
				break;
			case 8:
				DebugEnterAlt(8);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:150:4: letExp
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(150, 4);
				PushFollow(Follow._letExp_in_primaryExperession987);
				letExp86=letExp();
				PopFollow();

				adaptor.AddChild(root_0, letExp86.Tree);

				}
				break;

			}
			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("primaryExperession", 26);
			LeaveRule("primaryExperession", 26);
			LeaveRule_primaryExperession();
		}
		DebugLocation(151, 1);
		} finally { DebugExitRule(GrammarFileName, "primaryExperession"); }
		return retval;

	}
	// $ANTLR end "primaryExperession"

	private sealed partial class propertyCall_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public propertyCall_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_propertyCall();
	partial void LeaveRule_propertyCall();

	// $ANTLR start "propertyCall"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:152:1: propertyCall : ( pathName ( '[' arguments ']' )? ( isMarkedPre )? ( '(' propertyCallParametrs ')' )? -> ^( CALL pathName ( ^( INDEX arguments ) )? ( isMarkedPre )? ( propertyCallParametrs )? ) |it= 'iterate' '(' ( variableDeclaration ( ';' )? )+ '|' oclExpression ')' -> ^( ITERATE[$it] ( variableDeclaration )+ oclExpression ) );
	[GrammarRule("propertyCall")]
	private OCLSyntaxParser.propertyCall_return propertyCall()
	{
		EnterRule_propertyCall();
		EnterRule("propertyCall", 27);
		TraceIn("propertyCall", 27);
		OCLSyntaxParser.propertyCall_return retval = new OCLSyntaxParser.propertyCall_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		CommonToken it = default(CommonToken);
		CommonToken char_literal88 = default(CommonToken);
		CommonToken char_literal90 = default(CommonToken);
		CommonToken char_literal92 = default(CommonToken);
		CommonToken char_literal94 = default(CommonToken);
		CommonToken char_literal95 = default(CommonToken);
		CommonToken char_literal97 = default(CommonToken);
		CommonToken char_literal98 = default(CommonToken);
		CommonToken char_literal100 = default(CommonToken);
		OCLSyntaxParser.pathName_return pathName87 = default(OCLSyntaxParser.pathName_return);
		OCLSyntaxParser.arguments_return arguments89 = default(OCLSyntaxParser.arguments_return);
		OCLSyntaxParser.isMarkedPre_return isMarkedPre91 = default(OCLSyntaxParser.isMarkedPre_return);
		OCLSyntaxParser.propertyCallParametrs_return propertyCallParametrs93 = default(OCLSyntaxParser.propertyCallParametrs_return);
		OCLSyntaxParser.variableDeclaration_return variableDeclaration96 = default(OCLSyntaxParser.variableDeclaration_return);
		OCLSyntaxParser.oclExpression_return oclExpression99 = default(OCLSyntaxParser.oclExpression_return);

		object it_tree = default(object);
		object char_literal88_tree = default(object);
		object char_literal90_tree = default(object);
		object char_literal92_tree = default(object);
		object char_literal94_tree = default(object);
		object char_literal95_tree = default(object);
		object char_literal97_tree = default(object);
		object char_literal98_tree = default(object);
		object char_literal100_tree = default(object);
		RewriteRuleITokenStream stream_77=new RewriteRuleITokenStream(adaptor,"token 77");
		RewriteRuleITokenStream stream_78=new RewriteRuleITokenStream(adaptor,"token 78");
		RewriteRuleITokenStream stream_42=new RewriteRuleITokenStream(adaptor,"token 42");
		RewriteRuleITokenStream stream_43=new RewriteRuleITokenStream(adaptor,"token 43");
		RewriteRuleITokenStream stream_93=new RewriteRuleITokenStream(adaptor,"token 93");
		RewriteRuleITokenStream stream_53=new RewriteRuleITokenStream(adaptor,"token 53");
		RewriteRuleITokenStream stream_103=new RewriteRuleITokenStream(adaptor,"token 103");
		RewriteRuleSubtreeStream stream_pathName=new RewriteRuleSubtreeStream(adaptor,"rule pathName");
		RewriteRuleSubtreeStream stream_arguments=new RewriteRuleSubtreeStream(adaptor,"rule arguments");
		RewriteRuleSubtreeStream stream_isMarkedPre=new RewriteRuleSubtreeStream(adaptor,"rule isMarkedPre");
		RewriteRuleSubtreeStream stream_propertyCallParametrs=new RewriteRuleSubtreeStream(adaptor,"rule propertyCallParametrs");
		RewriteRuleSubtreeStream stream_variableDeclaration=new RewriteRuleSubtreeStream(adaptor,"rule variableDeclaration");
		RewriteRuleSubtreeStream stream_oclExpression=new RewriteRuleSubtreeStream(adaptor,"rule oclExpression");
		try { DebugEnterRule(GrammarFileName, "propertyCall");
		DebugLocation(152, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:153:2: ( pathName ( '[' arguments ']' )? ( isMarkedPre )? ( '(' propertyCallParametrs ')' )? -> ^( CALL pathName ( ^( INDEX arguments ) )? ( isMarkedPre )? ( propertyCallParametrs )? ) |it= 'iterate' '(' ( variableDeclaration ( ';' )? )+ '|' oclExpression ')' -> ^( ITERATE[$it] ( variableDeclaration )+ oclExpression ) )
			int alt42=2;
			try { DebugEnterDecision(42, false);
			int LA42_0 = input.LA(1);

			if ((LA42_0==SimpleName))
			{
				alt42 = 1;
			}
			else if ((LA42_0==93))
			{
				alt42 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 42, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(42); }
			switch (alt42)
			{
			case 1:
				DebugEnterAlt(1);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:153:4: pathName ( '[' arguments ']' )? ( isMarkedPre )? ( '(' propertyCallParametrs ')' )?
				{
				DebugLocation(153, 4);
				PushFollow(Follow._pathName_in_propertyCall997);
				pathName87=pathName();
				PopFollow();

				stream_pathName.Add(pathName87.Tree);
				DebugLocation(153, 13);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:153:13: ( '[' arguments ']' )?
				int alt37=2;
				try { DebugEnterSubRule(37);
				try { DebugEnterDecision(37, false);
				int LA37_0 = input.LA(1);

				if ((LA37_0==77))
				{
					alt37 = 1;
				}
				} finally { DebugExitDecision(37); }
				switch (alt37)
				{
				case 1:
					DebugEnterAlt(1);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:153:14: '[' arguments ']'
					{
					DebugLocation(153, 14);
					char_literal88=(CommonToken)Match(input,77,Follow._77_in_propertyCall1000);  
					stream_77.Add(char_literal88);

					DebugLocation(153, 17);
					PushFollow(Follow._arguments_in_propertyCall1001);
					arguments89=arguments();
					PopFollow();

					stream_arguments.Add(arguments89.Tree);
					DebugLocation(153, 26);
					char_literal90=(CommonToken)Match(input,78,Follow._78_in_propertyCall1002);  
					stream_78.Add(char_literal90);


					}
					break;

				}
				} finally { DebugExitSubRule(37); }

				DebugLocation(153, 32);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:153:32: ( isMarkedPre )?
				int alt38=2;
				try { DebugEnterSubRule(38);
				try { DebugEnterDecision(38, false);
				int LA38_0 = input.LA(1);

				if ((LA38_0==61))
				{
					alt38 = 1;
				}
				} finally { DebugExitDecision(38); }
				switch (alt38)
				{
				case 1:
					DebugEnterAlt(1);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:153:32: isMarkedPre
					{
					DebugLocation(153, 32);
					PushFollow(Follow._isMarkedPre_in_propertyCall1006);
					isMarkedPre91=isMarkedPre();
					PopFollow();

					stream_isMarkedPre.Add(isMarkedPre91.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(38); }

				DebugLocation(153, 45);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:153:45: ( '(' propertyCallParametrs ')' )?
				int alt39=2;
				try { DebugEnterSubRule(39);
				try { DebugEnterDecision(39, false);
				int LA39_0 = input.LA(1);

				if ((LA39_0==42))
				{
					alt39 = 1;
				}
				} finally { DebugExitDecision(39); }
				switch (alt39)
				{
				case 1:
					DebugEnterAlt(1);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:153:46: '(' propertyCallParametrs ')'
					{
					DebugLocation(153, 46);
					char_literal92=(CommonToken)Match(input,42,Follow._42_in_propertyCall1010);  
					stream_42.Add(char_literal92);

					DebugLocation(153, 49);
					PushFollow(Follow._propertyCallParametrs_in_propertyCall1011);
					propertyCallParametrs93=propertyCallParametrs();
					PopFollow();

					stream_propertyCallParametrs.Add(propertyCallParametrs93.Tree);
					DebugLocation(153, 70);
					char_literal94=(CommonToken)Match(input,43,Follow._43_in_propertyCall1012);  
					stream_43.Add(char_literal94);


					}
					break;

				}
				} finally { DebugExitSubRule(39); }



				{
				// AST REWRITE
				// elements: pathName, arguments, isMarkedPre, propertyCallParametrs
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 156:4: -> ^( CALL pathName ( ^( INDEX arguments ) )? ( isMarkedPre )? ( propertyCallParametrs )? )
				{
					DebugLocation(156, 6);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:156:6: ^( CALL pathName ( ^( INDEX arguments ) )? ( isMarkedPre )? ( propertyCallParametrs )? )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(156, 8);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(CALL, "CALL"), root_1);

					DebugLocation(156, 13);
					adaptor.AddChild(root_1, stream_pathName.NextTree());
					DebugLocation(156, 22);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:156:22: ( ^( INDEX arguments ) )?
					if (stream_arguments.HasNext)
					{
						DebugLocation(156, 22);
						// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:156:22: ^( INDEX arguments )
						{
						object root_2 = (object)adaptor.Nil();
						DebugLocation(156, 24);
						root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(INDEX, "INDEX"), root_2);

						DebugLocation(156, 30);
						adaptor.AddChild(root_2, stream_arguments.NextTree());

						adaptor.AddChild(root_1, root_2);
						}

					}
					stream_arguments.Reset();
					DebugLocation(156, 42);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:156:42: ( isMarkedPre )?
					if (stream_isMarkedPre.HasNext)
					{
						DebugLocation(156, 42);
						adaptor.AddChild(root_1, stream_isMarkedPre.NextTree());

					}
					stream_isMarkedPre.Reset();
					DebugLocation(156, 55);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:156:55: ( propertyCallParametrs )?
					if (stream_propertyCallParametrs.HasNext)
					{
						DebugLocation(156, 55);
						adaptor.AddChild(root_1, stream_propertyCallParametrs.NextTree());

					}
					stream_propertyCallParametrs.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:157:3: it= 'iterate' '(' ( variableDeclaration ( ';' )? )+ '|' oclExpression ')'
				{
				DebugLocation(157, 5);
				it=(CommonToken)Match(input,93,Follow._93_in_propertyCall1051);  
				stream_93.Add(it);

				DebugLocation(157, 16);
				char_literal95=(CommonToken)Match(input,42,Follow._42_in_propertyCall1053);  
				stream_42.Add(char_literal95);

				DebugLocation(157, 19);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:157:19: ( variableDeclaration ( ';' )? )+
				int cnt41=0;
				try { DebugEnterSubRule(41);
				while (true)
				{
					int alt41=2;
					try { DebugEnterDecision(41, false);
					int LA41_0 = input.LA(1);

					if ((LA41_0==SimpleName))
					{
						alt41 = 1;
					}


					} finally { DebugExitDecision(41); }
					switch (alt41)
					{
					case 1:
						DebugEnterAlt(1);
						// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:157:20: variableDeclaration ( ';' )?
						{
						DebugLocation(157, 20);
						PushFollow(Follow._variableDeclaration_in_propertyCall1055);
						variableDeclaration96=variableDeclaration();
						PopFollow();

						stream_variableDeclaration.Add(variableDeclaration96.Tree);
						DebugLocation(157, 40);
						// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:157:40: ( ';' )?
						int alt40=2;
						try { DebugEnterSubRule(40);
						try { DebugEnterDecision(40, false);
						int LA40_0 = input.LA(1);

						if ((LA40_0==53))
						{
							alt40 = 1;
						}
						} finally { DebugExitDecision(40); }
						switch (alt40)
						{
						case 1:
							DebugEnterAlt(1);
							// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:157:40: ';'
							{
							DebugLocation(157, 40);
							char_literal97=(CommonToken)Match(input,53,Follow._53_in_propertyCall1057);  
							stream_53.Add(char_literal97);


							}
							break;

						}
						} finally { DebugExitSubRule(40); }


						}
						break;

					default:
						if (cnt41 >= 1)
							goto loop41;

						EarlyExitException eee41 = new EarlyExitException( 41, input );
						DebugRecognitionException(eee41);
						throw eee41;
					}
					cnt41++;
				}
				loop41:
					;

				} finally { DebugExitSubRule(41); }

				DebugLocation(157, 47);
				char_literal98=(CommonToken)Match(input,103,Follow._103_in_propertyCall1062);  
				stream_103.Add(char_literal98);

				DebugLocation(157, 51);
				PushFollow(Follow._oclExpression_in_propertyCall1064);
				oclExpression99=oclExpression();
				PopFollow();

				stream_oclExpression.Add(oclExpression99.Tree);
				DebugLocation(157, 65);
				char_literal100=(CommonToken)Match(input,43,Follow._43_in_propertyCall1066);  
				stream_43.Add(char_literal100);



				{
				// AST REWRITE
				// elements: variableDeclaration, oclExpression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 158:4: -> ^( ITERATE[$it] ( variableDeclaration )+ oclExpression )
				{
					DebugLocation(158, 6);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:158:6: ^( ITERATE[$it] ( variableDeclaration )+ oclExpression )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(158, 8);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(ITERATE, it), root_1);

					DebugLocation(158, 21);
					if (!(stream_variableDeclaration.HasNext))
					{
						throw new RewriteEarlyExitException();
					}
					while ( stream_variableDeclaration.HasNext )
					{
						DebugLocation(158, 21);
						adaptor.AddChild(root_1, stream_variableDeclaration.NextTree());

					}
					stream_variableDeclaration.Reset();
					DebugLocation(158, 43);
					adaptor.AddChild(root_1, stream_oclExpression.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;

			}
			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("propertyCall", 27);
			LeaveRule("propertyCall", 27);
			LeaveRule_propertyCall();
		}
		DebugLocation(164, 1);
		} finally { DebugExitRule(GrammarFileName, "propertyCall"); }
		return retval;

	}
	// $ANTLR end "propertyCall"

	private sealed partial class propertyCallParametrs_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public propertyCallParametrs_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_propertyCallParametrs();
	partial void LeaveRule_propertyCallParametrs();

	// $ANTLR start "propertyCallParametrs"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:165:1: propertyCallParametrs : ( declarePropertyCallParametrs )? ( arguments -> ^( CALLARGS arguments ) )? ;
	[GrammarRule("propertyCallParametrs")]
	private OCLSyntaxParser.propertyCallParametrs_return propertyCallParametrs()
	{
		EnterRule_propertyCallParametrs();
		EnterRule("propertyCallParametrs", 28);
		TraceIn("propertyCallParametrs", 28);
		OCLSyntaxParser.propertyCallParametrs_return retval = new OCLSyntaxParser.propertyCallParametrs_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		OCLSyntaxParser.declarePropertyCallParametrs_return declarePropertyCallParametrs101 = default(OCLSyntaxParser.declarePropertyCallParametrs_return);
		OCLSyntaxParser.arguments_return arguments102 = default(OCLSyntaxParser.arguments_return);

		RewriteRuleSubtreeStream stream_declarePropertyCallParametrs=new RewriteRuleSubtreeStream(adaptor,"rule declarePropertyCallParametrs");
		RewriteRuleSubtreeStream stream_arguments=new RewriteRuleSubtreeStream(adaptor,"rule arguments");
		try { DebugEnterRule(GrammarFileName, "propertyCallParametrs");
		DebugLocation(165, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:166:2: ( ( declarePropertyCallParametrs )? ( arguments -> ^( CALLARGS arguments ) )? )
			DebugEnterAlt(1);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:166:4: ( declarePropertyCallParametrs )? ( arguments -> ^( CALLARGS arguments ) )?
			{
			DebugLocation(166, 4);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:166:4: ( declarePropertyCallParametrs )?
			int alt43=2;
			try { DebugEnterSubRule(43);
			try { DebugEnterDecision(43, false);
			int LA43_0 = input.LA(1);

			if ((LA43_0==SimpleName))
			{
				int LA43_1 = input.LA(2);

				if ((LA43_1==51||LA43_1==103))
				{
					alt43 = 1;
				}
				else if ((LA43_1==45))
				{
					int LA43_4 = input.LA(3);

					if ((LA43_4==SimpleName))
					{
						int LA43_5 = input.LA(4);

						if ((LA43_5==51||LA43_5==103))
						{
							alt43 = 1;
						}
					}
				}
			}
			} finally { DebugExitDecision(43); }
			switch (alt43)
			{
			case 1:
				DebugEnterAlt(1);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:166:4: declarePropertyCallParametrs
				{
				DebugLocation(166, 4);
				PushFollow(Follow._declarePropertyCallParametrs_in_propertyCallParametrs1106);
				declarePropertyCallParametrs101=declarePropertyCallParametrs();
				PopFollow();

				stream_declarePropertyCallParametrs.Add(declarePropertyCallParametrs101.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(43); }

			DebugLocation(166, 34);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:166:34: ( arguments -> ^( CALLARGS arguments ) )?
			int alt44=2;
			try { DebugEnterSubRule(44);
			try { DebugEnterDecision(44, false);
			int LA44_0 = input.LA(1);

			if ((LA44_0==BooleanLiteralExp||(LA44_0>=IntegerLiteralExp && LA44_0<=InvalidLiteralExp)||LA44_0==NullLiteralExp||(LA44_0>=RealLiteralExp && LA44_0<=SimpleName)||LA44_0==StringLiteralExp||LA44_0==UnlimitedNaturalLiteralExp||LA44_0==42||LA44_0==46||(LA44_0>=62 && LA44_0<=76)||LA44_0==88||(LA44_0>=93 && LA44_0<=95)))
			{
				alt44 = 1;
			}
			} finally { DebugExitDecision(44); }
			switch (alt44)
			{
			case 1:
				DebugEnterAlt(1);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:166:35: arguments
				{
				DebugLocation(166, 35);
				PushFollow(Follow._arguments_in_propertyCallParametrs1110);
				arguments102=arguments();
				PopFollow();

				stream_arguments.Add(arguments102.Tree);


				{
				// AST REWRITE
				// elements: arguments
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 166:45: -> ^( CALLARGS arguments )
				{
					DebugLocation(166, 48);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:166:48: ^( CALLARGS arguments )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(166, 50);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(CALLARGS, "CALLARGS"), root_1);

					DebugLocation(166, 59);
					adaptor.AddChild(root_1, stream_arguments.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;

			}
			} finally { DebugExitSubRule(44); }


			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("propertyCallParametrs", 28);
			LeaveRule("propertyCallParametrs", 28);
			LeaveRule_propertyCallParametrs();
		}
		DebugLocation(169, 1);
		} finally { DebugExitRule(GrammarFileName, "propertyCallParametrs"); }
		return retval;

	}
	// $ANTLR end "propertyCallParametrs"

	private sealed partial class declarePropertyCallParametrs_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public declarePropertyCallParametrs_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_declarePropertyCallParametrs();
	partial void LeaveRule_declarePropertyCallParametrs();

	// $ANTLR start "declarePropertyCallParametrs"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:170:1: declarePropertyCallParametrs : (t1= typedef ( ',' t2= typedef )? '|' ) -> ^( VARDECL $t1 ( $t2)? ) ;
	[GrammarRule("declarePropertyCallParametrs")]
	private OCLSyntaxParser.declarePropertyCallParametrs_return declarePropertyCallParametrs()
	{
		EnterRule_declarePropertyCallParametrs();
		EnterRule("declarePropertyCallParametrs", 29);
		TraceIn("declarePropertyCallParametrs", 29);
		OCLSyntaxParser.declarePropertyCallParametrs_return retval = new OCLSyntaxParser.declarePropertyCallParametrs_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		CommonToken char_literal103 = default(CommonToken);
		CommonToken char_literal104 = default(CommonToken);
		OCLSyntaxParser.typedef_return t1 = default(OCLSyntaxParser.typedef_return);
		OCLSyntaxParser.typedef_return t2 = default(OCLSyntaxParser.typedef_return);

		object char_literal103_tree = default(object);
		object char_literal104_tree = default(object);
		RewriteRuleITokenStream stream_45=new RewriteRuleITokenStream(adaptor,"token 45");
		RewriteRuleITokenStream stream_103=new RewriteRuleITokenStream(adaptor,"token 103");
		RewriteRuleSubtreeStream stream_typedef=new RewriteRuleSubtreeStream(adaptor,"rule typedef");
		try { DebugEnterRule(GrammarFileName, "declarePropertyCallParametrs");
		DebugLocation(170, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:171:2: ( (t1= typedef ( ',' t2= typedef )? '|' ) -> ^( VARDECL $t1 ( $t2)? ) )
			DebugEnterAlt(1);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:171:4: (t1= typedef ( ',' t2= typedef )? '|' )
			{
			DebugLocation(171, 4);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:171:4: (t1= typedef ( ',' t2= typedef )? '|' )
			DebugEnterAlt(1);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:171:6: t1= typedef ( ',' t2= typedef )? '|'
			{
			DebugLocation(171, 8);
			PushFollow(Follow._typedef_in_declarePropertyCallParametrs1141);
			t1=typedef();
			PopFollow();

			stream_typedef.Add(t1.Tree);
			DebugLocation(171, 17);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:171:17: ( ',' t2= typedef )?
			int alt45=2;
			try { DebugEnterSubRule(45);
			try { DebugEnterDecision(45, false);
			int LA45_0 = input.LA(1);

			if ((LA45_0==45))
			{
				alt45 = 1;
			}
			} finally { DebugExitDecision(45); }
			switch (alt45)
			{
			case 1:
				DebugEnterAlt(1);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:171:18: ',' t2= typedef
				{
				DebugLocation(171, 18);
				char_literal103=(CommonToken)Match(input,45,Follow._45_in_declarePropertyCallParametrs1144);  
				stream_45.Add(char_literal103);

				DebugLocation(171, 24);
				PushFollow(Follow._typedef_in_declarePropertyCallParametrs1148);
				t2=typedef();
				PopFollow();

				stream_typedef.Add(t2.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(45); }

			DebugLocation(171, 35);
			char_literal104=(CommonToken)Match(input,103,Follow._103_in_declarePropertyCallParametrs1152);  
			stream_103.Add(char_literal104);


			}



			{
			// AST REWRITE
			// elements: t1, t2
			// token labels: 
			// rule labels: t1, t2, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_t1=new RewriteRuleSubtreeStream(adaptor,"rule t1",t1!=null?t1.Tree:null);
			RewriteRuleSubtreeStream stream_t2=new RewriteRuleSubtreeStream(adaptor,"rule t2",t2!=null?t2.Tree:null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 172:3: -> ^( VARDECL $t1 ( $t2)? )
			{
				DebugLocation(172, 6);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:172:6: ^( VARDECL $t1 ( $t2)? )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(172, 8);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(VARDECL, "VARDECL"), root_1);

				DebugLocation(172, 17);
				adaptor.AddChild(root_1, stream_t1.NextTree());
				DebugLocation(172, 21);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:172:21: ( $t2)?
				if (stream_t2.HasNext)
				{
					DebugLocation(172, 21);
					adaptor.AddChild(root_1, stream_t2.NextTree());

				}
				stream_t2.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("declarePropertyCallParametrs", 29);
			LeaveRule("declarePropertyCallParametrs", 29);
			LeaveRule_declarePropertyCallParametrs();
		}
		DebugLocation(174, 1);
		} finally { DebugExitRule(GrammarFileName, "declarePropertyCallParametrs"); }
		return retval;

	}
	// $ANTLR end "declarePropertyCallParametrs"

	private sealed partial class typedef_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public typedef_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_typedef();
	partial void LeaveRule_typedef();

	// $ANTLR start "typedef"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:175:1: typedef : SimpleName ( ':' type )? -> ^( DECL SimpleName ( type )? ) ;
	[GrammarRule("typedef")]
	private OCLSyntaxParser.typedef_return typedef()
	{
		EnterRule_typedef();
		EnterRule("typedef", 30);
		TraceIn("typedef", 30);
		OCLSyntaxParser.typedef_return retval = new OCLSyntaxParser.typedef_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		CommonToken SimpleName105 = default(CommonToken);
		CommonToken char_literal106 = default(CommonToken);
		OCLSyntaxParser.type_return type107 = default(OCLSyntaxParser.type_return);

		object SimpleName105_tree = default(object);
		object char_literal106_tree = default(object);
		RewriteRuleITokenStream stream_SimpleName=new RewriteRuleITokenStream(adaptor,"token SimpleName");
		RewriteRuleITokenStream stream_51=new RewriteRuleITokenStream(adaptor,"token 51");
		RewriteRuleSubtreeStream stream_type=new RewriteRuleSubtreeStream(adaptor,"rule type");
		try { DebugEnterRule(GrammarFileName, "typedef");
		DebugLocation(175, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:176:2: ( SimpleName ( ':' type )? -> ^( DECL SimpleName ( type )? ) )
			DebugEnterAlt(1);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:176:4: SimpleName ( ':' type )?
			{
			DebugLocation(176, 4);
			SimpleName105=(CommonToken)Match(input,SimpleName,Follow._SimpleName_in_typedef1180);  
			stream_SimpleName.Add(SimpleName105);

			DebugLocation(176, 14);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:176:14: ( ':' type )?
			int alt46=2;
			try { DebugEnterSubRule(46);
			try { DebugEnterDecision(46, false);
			int LA46_0 = input.LA(1);

			if ((LA46_0==51))
			{
				alt46 = 1;
			}
			} finally { DebugExitDecision(46); }
			switch (alt46)
			{
			case 1:
				DebugEnterAlt(1);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:176:15: ':' type
				{
				DebugLocation(176, 15);
				char_literal106=(CommonToken)Match(input,51,Follow._51_in_typedef1182);  
				stream_51.Add(char_literal106);

				DebugLocation(176, 18);
				PushFollow(Follow._type_in_typedef1183);
				type107=type();
				PopFollow();

				stream_type.Add(type107.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(46); }



			{
			// AST REWRITE
			// elements: SimpleName, type
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 177:3: -> ^( DECL SimpleName ( type )? )
			{
				DebugLocation(177, 6);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:177:6: ^( DECL SimpleName ( type )? )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(177, 8);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(DECL, "DECL"), root_1);

				DebugLocation(177, 13);
				adaptor.AddChild(root_1, stream_SimpleName.NextNode());
				DebugLocation(177, 24);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:177:24: ( type )?
				if (stream_type.HasNext)
				{
					DebugLocation(177, 24);
					adaptor.AddChild(root_1, stream_type.NextTree());

				}
				stream_type.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("typedef", 30);
			LeaveRule("typedef", 30);
			LeaveRule_typedef();
		}
		DebugLocation(178, 1);
		} finally { DebugExitRule(GrammarFileName, "typedef"); }
		return retval;

	}
	// $ANTLR end "typedef"

	private sealed partial class enumAndType_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public enumAndType_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_enumAndType();
	partial void LeaveRule_enumAndType();

	// $ANTLR start "enumAndType"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:180:1: enumAndType : ( tupleType | primitiveType | oclType );
	[GrammarRule("enumAndType")]
	private OCLSyntaxParser.enumAndType_return enumAndType()
	{
		EnterRule_enumAndType();
		EnterRule("enumAndType", 31);
		TraceIn("enumAndType", 31);
		OCLSyntaxParser.enumAndType_return retval = new OCLSyntaxParser.enumAndType_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		OCLSyntaxParser.tupleType_return tupleType108 = default(OCLSyntaxParser.tupleType_return);
		OCLSyntaxParser.primitiveType_return primitiveType109 = default(OCLSyntaxParser.primitiveType_return);
		OCLSyntaxParser.oclType_return oclType110 = default(OCLSyntaxParser.oclType_return);


		try { DebugEnterRule(GrammarFileName, "enumAndType");
		DebugLocation(180, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:184:2: ( tupleType | primitiveType | oclType )
			int alt47=3;
			try { DebugEnterDecision(47, false);
			switch (input.LA(1))
			{
			case 75:
				{
				alt47 = 1;
				}
				break;
			case 63:
			case 65:
			case 71:
			case 74:
			case 76:
				{
				alt47 = 2;
				}
				break;
			case 66:
			case 67:
			case 68:
			case 69:
				{
				alt47 = 3;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 47, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(47); }
			switch (alt47)
			{
			case 1:
				DebugEnterAlt(1);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:184:4: tupleType
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(184, 4);
				PushFollow(Follow._tupleType_in_enumAndType1220);
				tupleType108=tupleType();
				PopFollow();

				adaptor.AddChild(root_0, tupleType108.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:185:4: primitiveType
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(185, 4);
				PushFollow(Follow._primitiveType_in_enumAndType1228);
				primitiveType109=primitiveType();
				PopFollow();

				adaptor.AddChild(root_0, primitiveType109.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:186:4: oclType
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(186, 4);
				PushFollow(Follow._oclType_in_enumAndType1233);
				oclType110=oclType();
				PopFollow();

				adaptor.AddChild(root_0, oclType110.Tree);

				}
				break;

			}
			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("enumAndType", 31);
			LeaveRule("enumAndType", 31);
			LeaveRule_enumAndType();
		}
		DebugLocation(188, 1);
		} finally { DebugExitRule(GrammarFileName, "enumAndType"); }
		return retval;

	}
	// $ANTLR end "enumAndType"

	private sealed partial class pathName_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public pathName_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_pathName();
	partial void LeaveRule_pathName();

	// $ANTLR start "pathName"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:192:1: pathName : SimpleName ( '::' SimpleName )* -> ^( PATH ( SimpleName )+ ) ;
	[GrammarRule("pathName")]
	private OCLSyntaxParser.pathName_return pathName()
	{
		EnterRule_pathName();
		EnterRule("pathName", 32);
		TraceIn("pathName", 32);
		OCLSyntaxParser.pathName_return retval = new OCLSyntaxParser.pathName_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		CommonToken SimpleName111 = default(CommonToken);
		CommonToken string_literal112 = default(CommonToken);
		CommonToken SimpleName113 = default(CommonToken);

		object SimpleName111_tree = default(object);
		object string_literal112_tree = default(object);
		object SimpleName113_tree = default(object);
		RewriteRuleITokenStream stream_SimpleName=new RewriteRuleITokenStream(adaptor,"token SimpleName");
		RewriteRuleITokenStream stream_52=new RewriteRuleITokenStream(adaptor,"token 52");

		try { DebugEnterRule(GrammarFileName, "pathName");
		DebugLocation(192, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:194:2: ( SimpleName ( '::' SimpleName )* -> ^( PATH ( SimpleName )+ ) )
			DebugEnterAlt(1);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:194:4: SimpleName ( '::' SimpleName )*
			{
			DebugLocation(194, 4);
			SimpleName111=(CommonToken)Match(input,SimpleName,Follow._SimpleName_in_pathName1250);  
			stream_SimpleName.Add(SimpleName111);

			DebugLocation(194, 15);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:194:15: ( '::' SimpleName )*
			try { DebugEnterSubRule(48);
			while (true)
			{
				int alt48=2;
				try { DebugEnterDecision(48, false);
				int LA48_0 = input.LA(1);

				if ((LA48_0==52))
				{
					int LA48_2 = input.LA(2);

					if ((LA48_2==SimpleName))
					{
						int LA48_3 = input.LA(3);

						if ((LA48_3==EOF))
						{
							alt48 = 1;
						}
						else if ((LA48_3==SimpleName||LA48_3==UnlimitedNaturalLiteralExp||(LA48_3>=42 && LA48_3<=59)||LA48_3==61||(LA48_3>=77 && LA48_3<=87)||(LA48_3>=89 && LA48_3<=92)||(LA48_3>=96 && LA48_3<=101)||(LA48_3>=103 && LA48_3<=104)))
						{
							alt48 = 1;
						}


					}


				}


				} finally { DebugExitDecision(48); }
				switch ( alt48 )
				{
				case 1:
					DebugEnterAlt(1);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:194:16: '::' SimpleName
					{
					DebugLocation(194, 16);
					string_literal112=(CommonToken)Match(input,52,Follow._52_in_pathName1253);  
					stream_52.Add(string_literal112);

					DebugLocation(194, 21);
					SimpleName113=(CommonToken)Match(input,SimpleName,Follow._SimpleName_in_pathName1255);  
					stream_SimpleName.Add(SimpleName113);


					}
					break;

				default:
					goto loop48;
				}
			}

			loop48:
				;

			} finally { DebugExitSubRule(48); }



			{
			// AST REWRITE
			// elements: SimpleName
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 195:3: -> ^( PATH ( SimpleName )+ )
			{
				DebugLocation(195, 6);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:195:6: ^( PATH ( SimpleName )+ )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(195, 8);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(PATH, "PATH"), root_1);

				DebugLocation(195, 13);
				if (!(stream_SimpleName.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_SimpleName.HasNext )
				{
					DebugLocation(195, 13);
					adaptor.AddChild(root_1, stream_SimpleName.NextNode());

				}
				stream_SimpleName.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("pathName", 32);
			LeaveRule("pathName", 32);
			LeaveRule_pathName();
		}
		DebugLocation(196, 1);
		} finally { DebugExitRule(GrammarFileName, "pathName"); }
		return retval;

	}
	// $ANTLR end "pathName"

	private sealed partial class collectionLiteralExpAndType_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public collectionLiteralExpAndType_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_collectionLiteralExpAndType();
	partial void LeaveRule_collectionLiteralExpAndType();

	// $ANTLR start "collectionLiteralExpAndType"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:199:1: collectionLiteralExpAndType : ( collectionTypeIdentifier ( '{' ( collectionLiteralParts )? '}' )? -> ^( COLLECTIONLITERAL collectionTypeIdentifier collectionLiteralParts ) | collectionTypeIdentifier ( '(' type ')' ) ( ( '{' collectionLiteralParts '}' -> ^( COLLECTIONLITERAL collectionTypeIdentifier type collectionLiteralParts ) ) | -> ^( COLLECTIONTYPE collectionTypeIdentifier type ) ) );
	[GrammarRule("collectionLiteralExpAndType")]
	private OCLSyntaxParser.collectionLiteralExpAndType_return collectionLiteralExpAndType()
	{
		EnterRule_collectionLiteralExpAndType();
		EnterRule("collectionLiteralExpAndType", 33);
		TraceIn("collectionLiteralExpAndType", 33);
		OCLSyntaxParser.collectionLiteralExpAndType_return retval = new OCLSyntaxParser.collectionLiteralExpAndType_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		CommonToken char_literal115 = default(CommonToken);
		CommonToken char_literal117 = default(CommonToken);
		CommonToken char_literal119 = default(CommonToken);
		CommonToken char_literal121 = default(CommonToken);
		CommonToken char_literal122 = default(CommonToken);
		CommonToken char_literal124 = default(CommonToken);
		OCLSyntaxParser.collectionTypeIdentifier_return collectionTypeIdentifier114 = default(OCLSyntaxParser.collectionTypeIdentifier_return);
		OCLSyntaxParser.collectionLiteralParts_return collectionLiteralParts116 = default(OCLSyntaxParser.collectionLiteralParts_return);
		OCLSyntaxParser.collectionTypeIdentifier_return collectionTypeIdentifier118 = default(OCLSyntaxParser.collectionTypeIdentifier_return);
		OCLSyntaxParser.type_return type120 = default(OCLSyntaxParser.type_return);
		OCLSyntaxParser.collectionLiteralParts_return collectionLiteralParts123 = default(OCLSyntaxParser.collectionLiteralParts_return);

		object char_literal115_tree = default(object);
		object char_literal117_tree = default(object);
		object char_literal119_tree = default(object);
		object char_literal121_tree = default(object);
		object char_literal122_tree = default(object);
		object char_literal124_tree = default(object);
		RewriteRuleITokenStream stream_102=new RewriteRuleITokenStream(adaptor,"token 102");
		RewriteRuleITokenStream stream_104=new RewriteRuleITokenStream(adaptor,"token 104");
		RewriteRuleITokenStream stream_42=new RewriteRuleITokenStream(adaptor,"token 42");
		RewriteRuleITokenStream stream_43=new RewriteRuleITokenStream(adaptor,"token 43");
		RewriteRuleSubtreeStream stream_collectionTypeIdentifier=new RewriteRuleSubtreeStream(adaptor,"rule collectionTypeIdentifier");
		RewriteRuleSubtreeStream stream_collectionLiteralParts=new RewriteRuleSubtreeStream(adaptor,"rule collectionLiteralParts");
		RewriteRuleSubtreeStream stream_type=new RewriteRuleSubtreeStream(adaptor,"rule type");
		try { DebugEnterRule(GrammarFileName, "collectionLiteralExpAndType");
		DebugLocation(199, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:201:2: ( collectionTypeIdentifier ( '{' ( collectionLiteralParts )? '}' )? -> ^( COLLECTIONLITERAL collectionTypeIdentifier collectionLiteralParts ) | collectionTypeIdentifier ( '(' type ')' ) ( ( '{' collectionLiteralParts '}' -> ^( COLLECTIONLITERAL collectionTypeIdentifier type collectionLiteralParts ) ) | -> ^( COLLECTIONTYPE collectionTypeIdentifier type ) ) )
			int alt52=2;
			try { DebugEnterDecision(52, false);
			int LA52_0 = input.LA(1);

			if ((LA52_0==62||LA52_0==64||LA52_0==70||(LA52_0>=72 && LA52_0<=73)))
			{
				int LA52_1 = input.LA(2);

				if ((LA52_1==EOF||LA52_1==SimpleName||LA52_1==UnlimitedNaturalLiteralExp||(LA52_1>=43 && LA52_1<=50)||(LA52_1>=53 && LA52_1<=59)||(LA52_1>=78 && LA52_1<=87)||(LA52_1>=89 && LA52_1<=92)||(LA52_1>=96 && LA52_1<=104)))
				{
					alt52 = 1;
				}
				else if ((LA52_1==42))
				{
					alt52 = 2;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 52, 1, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 52, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(52); }
			switch (alt52)
			{
			case 1:
				DebugEnterAlt(1);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:201:3: collectionTypeIdentifier ( '{' ( collectionLiteralParts )? '}' )?
				{
				DebugLocation(201, 3);
				PushFollow(Follow._collectionTypeIdentifier_in_collectionLiteralExpAndType1284);
				collectionTypeIdentifier114=collectionTypeIdentifier();
				PopFollow();

				stream_collectionTypeIdentifier.Add(collectionTypeIdentifier114.Tree);
				DebugLocation(201, 28);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:201:28: ( '{' ( collectionLiteralParts )? '}' )?
				int alt50=2;
				try { DebugEnterSubRule(50);
				try { DebugEnterDecision(50, false);
				int LA50_0 = input.LA(1);

				if ((LA50_0==102))
				{
					alt50 = 1;
				}
				} finally { DebugExitDecision(50); }
				switch (alt50)
				{
				case 1:
					DebugEnterAlt(1);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:201:29: '{' ( collectionLiteralParts )? '}'
					{
					DebugLocation(201, 29);
					char_literal115=(CommonToken)Match(input,102,Follow._102_in_collectionLiteralExpAndType1287);  
					stream_102.Add(char_literal115);

					DebugLocation(201, 33);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:201:33: ( collectionLiteralParts )?
					int alt49=2;
					try { DebugEnterSubRule(49);
					try { DebugEnterDecision(49, false);
					int LA49_0 = input.LA(1);

					if ((LA49_0==BooleanLiteralExp||(LA49_0>=IntegerLiteralExp && LA49_0<=InvalidLiteralExp)||LA49_0==NullLiteralExp||(LA49_0>=RealLiteralExp && LA49_0<=SimpleName)||LA49_0==StringLiteralExp||LA49_0==UnlimitedNaturalLiteralExp||LA49_0==42||LA49_0==46||(LA49_0>=62 && LA49_0<=76)||LA49_0==88||(LA49_0>=93 && LA49_0<=95)))
					{
						alt49 = 1;
					}
					} finally { DebugExitDecision(49); }
					switch (alt49)
					{
					case 1:
						DebugEnterAlt(1);
						// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:201:33: collectionLiteralParts
						{
						DebugLocation(201, 33);
						PushFollow(Follow._collectionLiteralParts_in_collectionLiteralExpAndType1289);
						collectionLiteralParts116=collectionLiteralParts();
						PopFollow();

						stream_collectionLiteralParts.Add(collectionLiteralParts116.Tree);

						}
						break;

					}
					} finally { DebugExitSubRule(49); }

					DebugLocation(201, 57);
					char_literal117=(CommonToken)Match(input,104,Follow._104_in_collectionLiteralExpAndType1292);  
					stream_104.Add(char_literal117);


					}
					break;

				}
				} finally { DebugExitSubRule(50); }



				{
				// AST REWRITE
				// elements: collectionTypeIdentifier, collectionLiteralParts
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 202:3: -> ^( COLLECTIONLITERAL collectionTypeIdentifier collectionLiteralParts )
				{
					DebugLocation(202, 6);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:202:6: ^( COLLECTIONLITERAL collectionTypeIdentifier collectionLiteralParts )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(202, 8);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(COLLECTIONLITERAL, "COLLECTIONLITERAL"), root_1);

					DebugLocation(202, 26);
					adaptor.AddChild(root_1, stream_collectionTypeIdentifier.NextTree());
					DebugLocation(202, 51);
					adaptor.AddChild(root_1, stream_collectionLiteralParts.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:204:4: collectionTypeIdentifier ( '(' type ')' ) ( ( '{' collectionLiteralParts '}' -> ^( COLLECTIONLITERAL collectionTypeIdentifier type collectionLiteralParts ) ) | -> ^( COLLECTIONTYPE collectionTypeIdentifier type ) )
				{
				DebugLocation(204, 4);
				PushFollow(Follow._collectionTypeIdentifier_in_collectionLiteralExpAndType1313);
				collectionTypeIdentifier118=collectionTypeIdentifier();
				PopFollow();

				stream_collectionTypeIdentifier.Add(collectionTypeIdentifier118.Tree);
				DebugLocation(204, 29);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:204:29: ( '(' type ')' )
				DebugEnterAlt(1);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:204:30: '(' type ')'
				{
				DebugLocation(204, 30);
				char_literal119=(CommonToken)Match(input,42,Follow._42_in_collectionLiteralExpAndType1316);  
				stream_42.Add(char_literal119);

				DebugLocation(204, 34);
				PushFollow(Follow._type_in_collectionLiteralExpAndType1318);
				type120=type();
				PopFollow();

				stream_type.Add(type120.Tree);
				DebugLocation(204, 40);
				char_literal121=(CommonToken)Match(input,43,Follow._43_in_collectionLiteralExpAndType1321);  
				stream_43.Add(char_literal121);


				}

				DebugLocation(205, 2);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:205:2: ( ( '{' collectionLiteralParts '}' -> ^( COLLECTIONLITERAL collectionTypeIdentifier type collectionLiteralParts ) ) | -> ^( COLLECTIONTYPE collectionTypeIdentifier type ) )
				int alt51=2;
				try { DebugEnterSubRule(51);
				try { DebugEnterDecision(51, false);
				int LA51_0 = input.LA(1);

				if ((LA51_0==102))
				{
					alt51 = 1;
				}
				else if ((LA51_0==EOF||LA51_0==SimpleName||LA51_0==UnlimitedNaturalLiteralExp||(LA51_0>=43 && LA51_0<=50)||(LA51_0>=53 && LA51_0<=59)||(LA51_0>=78 && LA51_0<=87)||(LA51_0>=89 && LA51_0<=92)||(LA51_0>=96 && LA51_0<=101)||(LA51_0>=103 && LA51_0<=104)))
				{
					alt51 = 2;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 51, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				} finally { DebugExitDecision(51); }
				switch (alt51)
				{
				case 1:
					DebugEnterAlt(1);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:206:3: ( '{' collectionLiteralParts '}' -> ^( COLLECTIONLITERAL collectionTypeIdentifier type collectionLiteralParts ) )
					{
					DebugLocation(206, 3);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:206:3: ( '{' collectionLiteralParts '}' -> ^( COLLECTIONLITERAL collectionTypeIdentifier type collectionLiteralParts ) )
					DebugEnterAlt(1);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:206:4: '{' collectionLiteralParts '}'
					{
					DebugLocation(206, 4);
					char_literal122=(CommonToken)Match(input,102,Follow._102_in_collectionLiteralExpAndType1331);  
					stream_102.Add(char_literal122);

					DebugLocation(206, 8);
					PushFollow(Follow._collectionLiteralParts_in_collectionLiteralExpAndType1333);
					collectionLiteralParts123=collectionLiteralParts();
					PopFollow();

					stream_collectionLiteralParts.Add(collectionLiteralParts123.Tree);
					DebugLocation(206, 31);
					char_literal124=(CommonToken)Match(input,104,Follow._104_in_collectionLiteralExpAndType1335);  
					stream_104.Add(char_literal124);



					{
					// AST REWRITE
					// elements: collectionTypeIdentifier, type, collectionLiteralParts
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (object)adaptor.Nil();
					// 207:4: -> ^( COLLECTIONLITERAL collectionTypeIdentifier type collectionLiteralParts )
					{
						DebugLocation(207, 7);
						// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:207:7: ^( COLLECTIONLITERAL collectionTypeIdentifier type collectionLiteralParts )
						{
						object root_1 = (object)adaptor.Nil();
						DebugLocation(207, 9);
						root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(COLLECTIONLITERAL, "COLLECTIONLITERAL"), root_1);

						DebugLocation(207, 27);
						adaptor.AddChild(root_1, stream_collectionTypeIdentifier.NextTree());
						DebugLocation(207, 52);
						adaptor.AddChild(root_1, stream_type.NextTree());
						DebugLocation(207, 57);
						adaptor.AddChild(root_1, stream_collectionLiteralParts.NextTree());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}

					}


					}
					break;
				case 2:
					DebugEnterAlt(2);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:209:5: 
					{

					{
					// AST REWRITE
					// elements: collectionTypeIdentifier, type
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (object)adaptor.Nil();
					// 209:5: -> ^( COLLECTIONTYPE collectionTypeIdentifier type )
					{
						DebugLocation(209, 7);
						// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:209:7: ^( COLLECTIONTYPE collectionTypeIdentifier type )
						{
						object root_1 = (object)adaptor.Nil();
						DebugLocation(209, 9);
						root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(COLLECTIONTYPE, "COLLECTIONTYPE"), root_1);

						DebugLocation(209, 24);
						adaptor.AddChild(root_1, stream_collectionTypeIdentifier.NextTree());
						DebugLocation(209, 49);
						adaptor.AddChild(root_1, stream_type.NextTree());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}

					}
					break;

				}
				} finally { DebugExitSubRule(51); }


				}
				break;

			}
			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("collectionLiteralExpAndType", 33);
			LeaveRule("collectionLiteralExpAndType", 33);
			LeaveRule_collectionLiteralExpAndType();
		}
		DebugLocation(211, 1);
		} finally { DebugExitRule(GrammarFileName, "collectionLiteralExpAndType"); }
		return retval;

	}
	// $ANTLR end "collectionLiteralExpAndType"

	private sealed partial class enumLiteralExp_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public enumLiteralExp_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_enumLiteralExp();
	partial void LeaveRule_enumLiteralExp();

	// $ANTLR start "enumLiteralExp"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:213:1: enumLiteralExp : pathName '::' SimpleName ;
	[GrammarRule("enumLiteralExp")]
	private OCLSyntaxParser.enumLiteralExp_return enumLiteralExp()
	{
		EnterRule_enumLiteralExp();
		EnterRule("enumLiteralExp", 34);
		TraceIn("enumLiteralExp", 34);
		OCLSyntaxParser.enumLiteralExp_return retval = new OCLSyntaxParser.enumLiteralExp_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		CommonToken string_literal126 = default(CommonToken);
		CommonToken SimpleName127 = default(CommonToken);
		OCLSyntaxParser.pathName_return pathName125 = default(OCLSyntaxParser.pathName_return);

		object string_literal126_tree = default(object);
		object SimpleName127_tree = default(object);

		try { DebugEnterRule(GrammarFileName, "enumLiteralExp");
		DebugLocation(213, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:214:2: ( pathName '::' SimpleName )
			DebugEnterAlt(1);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:214:3: pathName '::' SimpleName
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(214, 3);
			PushFollow(Follow._pathName_in_enumLiteralExp1382);
			pathName125=pathName();
			PopFollow();

			adaptor.AddChild(root_0, pathName125.Tree);
			DebugLocation(214, 11);
			string_literal126=(CommonToken)Match(input,52,Follow._52_in_enumLiteralExp1383); 
			string_literal126_tree = (object)adaptor.Create(string_literal126);
			adaptor.AddChild(root_0, string_literal126_tree);

			DebugLocation(214, 16);
			SimpleName127=(CommonToken)Match(input,SimpleName,Follow._SimpleName_in_enumLiteralExp1385); 
			SimpleName127_tree = (object)adaptor.Create(SimpleName127);
			adaptor.AddChild(root_0, SimpleName127_tree);


			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("enumLiteralExp", 34);
			LeaveRule("enumLiteralExp", 34);
			LeaveRule_enumLiteralExp();
		}
		DebugLocation(215, 1);
		} finally { DebugExitRule(GrammarFileName, "enumLiteralExp"); }
		return retval;

	}
	// $ANTLR end "enumLiteralExp"

	private sealed partial class collectionLiteralExp_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public collectionLiteralExp_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_collectionLiteralExp();
	partial void LeaveRule_collectionLiteralExp();

	// $ANTLR start "collectionLiteralExp"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:217:1: collectionLiteralExp : ( collectionTypeIdentifier '{' ( collectionLiteralParts )? '}' | collectionType '{' ( collectionLiteralParts )? '}' );
	[GrammarRule("collectionLiteralExp")]
	private OCLSyntaxParser.collectionLiteralExp_return collectionLiteralExp()
	{
		EnterRule_collectionLiteralExp();
		EnterRule("collectionLiteralExp", 35);
		TraceIn("collectionLiteralExp", 35);
		OCLSyntaxParser.collectionLiteralExp_return retval = new OCLSyntaxParser.collectionLiteralExp_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		CommonToken char_literal129 = default(CommonToken);
		CommonToken char_literal131 = default(CommonToken);
		CommonToken char_literal133 = default(CommonToken);
		CommonToken char_literal135 = default(CommonToken);
		OCLSyntaxParser.collectionTypeIdentifier_return collectionTypeIdentifier128 = default(OCLSyntaxParser.collectionTypeIdentifier_return);
		OCLSyntaxParser.collectionLiteralParts_return collectionLiteralParts130 = default(OCLSyntaxParser.collectionLiteralParts_return);
		OCLSyntaxParser.collectionType_return collectionType132 = default(OCLSyntaxParser.collectionType_return);
		OCLSyntaxParser.collectionLiteralParts_return collectionLiteralParts134 = default(OCLSyntaxParser.collectionLiteralParts_return);

		object char_literal129_tree = default(object);
		object char_literal131_tree = default(object);
		object char_literal133_tree = default(object);
		object char_literal135_tree = default(object);

		try { DebugEnterRule(GrammarFileName, "collectionLiteralExp");
		DebugLocation(217, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:218:2: ( collectionTypeIdentifier '{' ( collectionLiteralParts )? '}' | collectionType '{' ( collectionLiteralParts )? '}' )
			int alt55=2;
			try { DebugEnterDecision(55, false);
			int LA55_0 = input.LA(1);

			if ((LA55_0==62||LA55_0==64||LA55_0==70||(LA55_0>=72 && LA55_0<=73)))
			{
				int LA55_1 = input.LA(2);

				if ((LA55_1==102))
				{
					alt55 = 1;
				}
				else if ((LA55_1==42))
				{
					alt55 = 2;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 55, 1, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 55, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(55); }
			switch (alt55)
			{
			case 1:
				DebugEnterAlt(1);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:218:3: collectionTypeIdentifier '{' ( collectionLiteralParts )? '}'
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(218, 3);
				PushFollow(Follow._collectionTypeIdentifier_in_collectionLiteralExp1397);
				collectionTypeIdentifier128=collectionTypeIdentifier();
				PopFollow();

				adaptor.AddChild(root_0, collectionTypeIdentifier128.Tree);
				DebugLocation(218, 29);
				char_literal129=(CommonToken)Match(input,102,Follow._102_in_collectionLiteralExp1400); 
				char_literal129_tree = (object)adaptor.Create(char_literal129);
				adaptor.AddChild(root_0, char_literal129_tree);

				DebugLocation(218, 33);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:218:33: ( collectionLiteralParts )?
				int alt53=2;
				try { DebugEnterSubRule(53);
				try { DebugEnterDecision(53, false);
				int LA53_0 = input.LA(1);

				if ((LA53_0==BooleanLiteralExp||(LA53_0>=IntegerLiteralExp && LA53_0<=InvalidLiteralExp)||LA53_0==NullLiteralExp||(LA53_0>=RealLiteralExp && LA53_0<=SimpleName)||LA53_0==StringLiteralExp||LA53_0==UnlimitedNaturalLiteralExp||LA53_0==42||LA53_0==46||(LA53_0>=62 && LA53_0<=76)||LA53_0==88||(LA53_0>=93 && LA53_0<=95)))
				{
					alt53 = 1;
				}
				} finally { DebugExitDecision(53); }
				switch (alt53)
				{
				case 1:
					DebugEnterAlt(1);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:218:33: collectionLiteralParts
					{
					DebugLocation(218, 33);
					PushFollow(Follow._collectionLiteralParts_in_collectionLiteralExp1402);
					collectionLiteralParts130=collectionLiteralParts();
					PopFollow();

					adaptor.AddChild(root_0, collectionLiteralParts130.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(53); }

				DebugLocation(218, 57);
				char_literal131=(CommonToken)Match(input,104,Follow._104_in_collectionLiteralExp1405); 
				char_literal131_tree = (object)adaptor.Create(char_literal131);
				adaptor.AddChild(root_0, char_literal131_tree);


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:219:3: collectionType '{' ( collectionLiteralParts )? '}'
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(219, 3);
				PushFollow(Follow._collectionType_in_collectionLiteralExp1409);
				collectionType132=collectionType();
				PopFollow();

				adaptor.AddChild(root_0, collectionType132.Tree);
				DebugLocation(219, 18);
				char_literal133=(CommonToken)Match(input,102,Follow._102_in_collectionLiteralExp1411); 
				char_literal133_tree = (object)adaptor.Create(char_literal133);
				adaptor.AddChild(root_0, char_literal133_tree);

				DebugLocation(219, 22);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:219:22: ( collectionLiteralParts )?
				int alt54=2;
				try { DebugEnterSubRule(54);
				try { DebugEnterDecision(54, false);
				int LA54_0 = input.LA(1);

				if ((LA54_0==BooleanLiteralExp||(LA54_0>=IntegerLiteralExp && LA54_0<=InvalidLiteralExp)||LA54_0==NullLiteralExp||(LA54_0>=RealLiteralExp && LA54_0<=SimpleName)||LA54_0==StringLiteralExp||LA54_0==UnlimitedNaturalLiteralExp||LA54_0==42||LA54_0==46||(LA54_0>=62 && LA54_0<=76)||LA54_0==88||(LA54_0>=93 && LA54_0<=95)))
				{
					alt54 = 1;
				}
				} finally { DebugExitDecision(54); }
				switch (alt54)
				{
				case 1:
					DebugEnterAlt(1);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:219:22: collectionLiteralParts
					{
					DebugLocation(219, 22);
					PushFollow(Follow._collectionLiteralParts_in_collectionLiteralExp1413);
					collectionLiteralParts134=collectionLiteralParts();
					PopFollow();

					adaptor.AddChild(root_0, collectionLiteralParts134.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(54); }

				DebugLocation(219, 46);
				char_literal135=(CommonToken)Match(input,104,Follow._104_in_collectionLiteralExp1416); 
				char_literal135_tree = (object)adaptor.Create(char_literal135);
				adaptor.AddChild(root_0, char_literal135_tree);


				}
				break;

			}
			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("collectionLiteralExp", 35);
			LeaveRule("collectionLiteralExp", 35);
			LeaveRule_collectionLiteralExp();
		}
		DebugLocation(220, 1);
		} finally { DebugExitRule(GrammarFileName, "collectionLiteralExp"); }
		return retval;

	}
	// $ANTLR end "collectionLiteralExp"

	private sealed partial class collectionTypeIdentifier_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public collectionTypeIdentifier_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_collectionTypeIdentifier();
	partial void LeaveRule_collectionTypeIdentifier();

	// $ANTLR start "collectionTypeIdentifier"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:227:1: collectionTypeIdentifier : ( 'Set' | 'Bag' | 'Sequence' | 'Collection' | 'OrderedSet' );
	[GrammarRule("collectionTypeIdentifier")]
	private OCLSyntaxParser.collectionTypeIdentifier_return collectionTypeIdentifier()
	{
		EnterRule_collectionTypeIdentifier();
		EnterRule("collectionTypeIdentifier", 36);
		TraceIn("collectionTypeIdentifier", 36);
		OCLSyntaxParser.collectionTypeIdentifier_return retval = new OCLSyntaxParser.collectionTypeIdentifier_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		CommonToken set136 = default(CommonToken);

		object set136_tree = default(object);

		try { DebugEnterRule(GrammarFileName, "collectionTypeIdentifier");
		DebugLocation(227, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:228:2: ( 'Set' | 'Bag' | 'Sequence' | 'Collection' | 'OrderedSet' )
			DebugEnterAlt(1);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(228, 2);
			set136=(CommonToken)input.LT(1);
			if (input.LA(1)==62||input.LA(1)==64||input.LA(1)==70||(input.LA(1)>=72 && input.LA(1)<=73))
			{
				input.Consume();
				adaptor.AddChild(root_0, (object)adaptor.Create(set136));
				state.errorRecovery=false;
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("collectionTypeIdentifier", 36);
			LeaveRule("collectionTypeIdentifier", 36);
			LeaveRule_collectionTypeIdentifier();
		}
		DebugLocation(233, 1);
		} finally { DebugExitRule(GrammarFileName, "collectionTypeIdentifier"); }
		return retval;

	}
	// $ANTLR end "collectionTypeIdentifier"

	private sealed partial class collectionLiteralParts_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public collectionLiteralParts_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_collectionLiteralParts();
	partial void LeaveRule_collectionLiteralParts();

	// $ANTLR start "collectionLiteralParts"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:235:1: collectionLiteralParts : collectionLiteralPart ( ',' collectionLiteralPart )* ;
	[GrammarRule("collectionLiteralParts")]
	private OCLSyntaxParser.collectionLiteralParts_return collectionLiteralParts()
	{
		EnterRule_collectionLiteralParts();
		EnterRule("collectionLiteralParts", 37);
		TraceIn("collectionLiteralParts", 37);
		OCLSyntaxParser.collectionLiteralParts_return retval = new OCLSyntaxParser.collectionLiteralParts_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		CommonToken char_literal138 = default(CommonToken);
		OCLSyntaxParser.collectionLiteralPart_return collectionLiteralPart137 = default(OCLSyntaxParser.collectionLiteralPart_return);
		OCLSyntaxParser.collectionLiteralPart_return collectionLiteralPart139 = default(OCLSyntaxParser.collectionLiteralPart_return);

		object char_literal138_tree = default(object);

		try { DebugEnterRule(GrammarFileName, "collectionLiteralParts");
		DebugLocation(235, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:236:2: ( collectionLiteralPart ( ',' collectionLiteralPart )* )
			DebugEnterAlt(1);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:236:4: collectionLiteralPart ( ',' collectionLiteralPart )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(236, 4);
			PushFollow(Follow._collectionLiteralPart_in_collectionLiteralParts1463);
			collectionLiteralPart137=collectionLiteralPart();
			PopFollow();

			adaptor.AddChild(root_0, collectionLiteralPart137.Tree);
			DebugLocation(236, 26);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:236:26: ( ',' collectionLiteralPart )*
			try { DebugEnterSubRule(56);
			while (true)
			{
				int alt56=2;
				try { DebugEnterDecision(56, false);
				int LA56_0 = input.LA(1);

				if ((LA56_0==45))
				{
					alt56 = 1;
				}


				} finally { DebugExitDecision(56); }
				switch ( alt56 )
				{
				case 1:
					DebugEnterAlt(1);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:236:28: ',' collectionLiteralPart
					{
					DebugLocation(236, 31);
					char_literal138=(CommonToken)Match(input,45,Follow._45_in_collectionLiteralParts1467); 
					DebugLocation(236, 33);
					PushFollow(Follow._collectionLiteralPart_in_collectionLiteralParts1470);
					collectionLiteralPart139=collectionLiteralPart();
					PopFollow();

					adaptor.AddChild(root_0, collectionLiteralPart139.Tree);

					}
					break;

				default:
					goto loop56;
				}
			}

			loop56:
				;

			} finally { DebugExitSubRule(56); }


			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("collectionLiteralParts", 37);
			LeaveRule("collectionLiteralParts", 37);
			LeaveRule_collectionLiteralParts();
		}
		DebugLocation(237, 1);
		} finally { DebugExitRule(GrammarFileName, "collectionLiteralParts"); }
		return retval;

	}
	// $ANTLR end "collectionLiteralParts"

	private sealed partial class collectionLiteralPart_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public collectionLiteralPart_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_collectionLiteralPart();
	partial void LeaveRule_collectionLiteralPart();

	// $ANTLR start "collectionLiteralPart"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:239:1: collectionLiteralPart : exp1= oclExpression ( ( '..' exp2= oclExpression ) -> ^( COLLPART $exp1 $exp2) | -> ^( COLLPART $exp1) ) ;
	[GrammarRule("collectionLiteralPart")]
	private OCLSyntaxParser.collectionLiteralPart_return collectionLiteralPart()
	{
		EnterRule_collectionLiteralPart();
		EnterRule("collectionLiteralPart", 38);
		TraceIn("collectionLiteralPart", 38);
		OCLSyntaxParser.collectionLiteralPart_return retval = new OCLSyntaxParser.collectionLiteralPart_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		CommonToken string_literal140 = default(CommonToken);
		OCLSyntaxParser.oclExpression_return exp1 = default(OCLSyntaxParser.oclExpression_return);
		OCLSyntaxParser.oclExpression_return exp2 = default(OCLSyntaxParser.oclExpression_return);

		object string_literal140_tree = default(object);
		RewriteRuleITokenStream stream_49=new RewriteRuleITokenStream(adaptor,"token 49");
		RewriteRuleSubtreeStream stream_oclExpression=new RewriteRuleSubtreeStream(adaptor,"rule oclExpression");
		try { DebugEnterRule(GrammarFileName, "collectionLiteralPart");
		DebugLocation(239, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:240:2: (exp1= oclExpression ( ( '..' exp2= oclExpression ) -> ^( COLLPART $exp1 $exp2) | -> ^( COLLPART $exp1) ) )
			DebugEnterAlt(1);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:240:4: exp1= oclExpression ( ( '..' exp2= oclExpression ) -> ^( COLLPART $exp1 $exp2) | -> ^( COLLPART $exp1) )
			{
			DebugLocation(240, 8);
			PushFollow(Follow._oclExpression_in_collectionLiteralPart1487);
			exp1=oclExpression();
			PopFollow();

			stream_oclExpression.Add(exp1.Tree);
			DebugLocation(240, 23);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:240:23: ( ( '..' exp2= oclExpression ) -> ^( COLLPART $exp1 $exp2) | -> ^( COLLPART $exp1) )
			int alt57=2;
			try { DebugEnterSubRule(57);
			try { DebugEnterDecision(57, false);
			int LA57_0 = input.LA(1);

			if ((LA57_0==49))
			{
				alt57 = 1;
			}
			else if ((LA57_0==45||LA57_0==104))
			{
				alt57 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 57, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(57); }
			switch (alt57)
			{
			case 1:
				DebugEnterAlt(1);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:240:24: ( '..' exp2= oclExpression )
				{
				DebugLocation(240, 24);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:240:24: ( '..' exp2= oclExpression )
				DebugEnterAlt(1);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:240:25: '..' exp2= oclExpression
				{
				DebugLocation(240, 25);
				string_literal140=(CommonToken)Match(input,49,Follow._49_in_collectionLiteralPart1491);  
				stream_49.Add(string_literal140);

				DebugLocation(240, 34);
				PushFollow(Follow._oclExpression_in_collectionLiteralPart1495);
				exp2=oclExpression();
				PopFollow();

				stream_oclExpression.Add(exp2.Tree);

				}



				{
				// AST REWRITE
				// elements: exp1, exp2
				// token labels: 
				// rule labels: exp1, exp2, retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_exp1=new RewriteRuleSubtreeStream(adaptor,"rule exp1",exp1!=null?exp1.Tree:null);
				RewriteRuleSubtreeStream stream_exp2=new RewriteRuleSubtreeStream(adaptor,"rule exp2",exp2!=null?exp2.Tree:null);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 240:49: -> ^( COLLPART $exp1 $exp2)
				{
					DebugLocation(240, 51);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:240:51: ^( COLLPART $exp1 $exp2)
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(240, 53);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(COLLPART, "COLLPART"), root_1);

					DebugLocation(240, 63);
					adaptor.AddChild(root_1, stream_exp1.NextTree());
					DebugLocation(240, 69);
					adaptor.AddChild(root_1, stream_exp2.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:240:75: 
				{

				{
				// AST REWRITE
				// elements: exp1
				// token labels: 
				// rule labels: exp1, retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_exp1=new RewriteRuleSubtreeStream(adaptor,"rule exp1",exp1!=null?exp1.Tree:null);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 240:75: -> ^( COLLPART $exp1)
				{
					DebugLocation(240, 77);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:240:77: ^( COLLPART $exp1)
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(240, 79);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(COLLPART, "COLLPART"), root_1);

					DebugLocation(240, 89);
					adaptor.AddChild(root_1, stream_exp1.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;

			}
			} finally { DebugExitSubRule(57); }


			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("collectionLiteralPart", 38);
			LeaveRule("collectionLiteralPart", 38);
			LeaveRule_collectionLiteralPart();
		}
		DebugLocation(241, 1);
		} finally { DebugExitRule(GrammarFileName, "collectionLiteralPart"); }
		return retval;

	}
	// $ANTLR end "collectionLiteralPart"

	private sealed partial class primitiveLiteralExp_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public primitiveLiteralExp_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_primitiveLiteralExp();
	partial void LeaveRule_primitiveLiteralExp();

	// $ANTLR start "primitiveLiteralExp"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:244:1: primitiveLiteralExp : ( IntegerLiteralExp | RealLiteralExp | StringLiteralExp | BooleanLiteralExp | UnlimitedNaturalLiteralExp | NullLiteralExp | InvalidLiteralExp );
	[GrammarRule("primitiveLiteralExp")]
	private OCLSyntaxParser.primitiveLiteralExp_return primitiveLiteralExp()
	{
		EnterRule_primitiveLiteralExp();
		EnterRule("primitiveLiteralExp", 39);
		TraceIn("primitiveLiteralExp", 39);
		OCLSyntaxParser.primitiveLiteralExp_return retval = new OCLSyntaxParser.primitiveLiteralExp_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		CommonToken set141 = default(CommonToken);

		object set141_tree = default(object);

		try { DebugEnterRule(GrammarFileName, "primitiveLiteralExp");
		DebugLocation(244, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:245:2: ( IntegerLiteralExp | RealLiteralExp | StringLiteralExp | BooleanLiteralExp | UnlimitedNaturalLiteralExp | NullLiteralExp | InvalidLiteralExp )
			DebugEnterAlt(1);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(245, 2);
			set141=(CommonToken)input.LT(1);
			if (input.LA(1)==BooleanLiteralExp||(input.LA(1)>=IntegerLiteralExp && input.LA(1)<=InvalidLiteralExp)||input.LA(1)==NullLiteralExp||input.LA(1)==RealLiteralExp||input.LA(1)==StringLiteralExp||input.LA(1)==UnlimitedNaturalLiteralExp)
			{
				input.Consume();
				adaptor.AddChild(root_0, (object)adaptor.Create(set141));
				state.errorRecovery=false;
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("primitiveLiteralExp", 39);
			LeaveRule("primitiveLiteralExp", 39);
			LeaveRule_primitiveLiteralExp();
		}
		DebugLocation(252, 1);
		} finally { DebugExitRule(GrammarFileName, "primitiveLiteralExp"); }
		return retval;

	}
	// $ANTLR end "primitiveLiteralExp"

	private sealed partial class tupleLiteralExp_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public tupleLiteralExp_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_tupleLiteralExp();
	partial void LeaveRule_tupleLiteralExp();

	// $ANTLR start "tupleLiteralExp"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:253:1: tupleLiteralExp : roottoken= 'Tuple' '{' variableDeclarationList '}' -> ^( TUPLELITERAL[$roottoken] $roottoken variableDeclarationList ) ;
	[GrammarRule("tupleLiteralExp")]
	private OCLSyntaxParser.tupleLiteralExp_return tupleLiteralExp()
	{
		EnterRule_tupleLiteralExp();
		EnterRule("tupleLiteralExp", 40);
		TraceIn("tupleLiteralExp", 40);
		OCLSyntaxParser.tupleLiteralExp_return retval = new OCLSyntaxParser.tupleLiteralExp_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		CommonToken roottoken = default(CommonToken);
		CommonToken char_literal142 = default(CommonToken);
		CommonToken char_literal144 = default(CommonToken);
		OCLSyntaxParser.variableDeclarationList_return variableDeclarationList143 = default(OCLSyntaxParser.variableDeclarationList_return);

		object roottoken_tree = default(object);
		object char_literal142_tree = default(object);
		object char_literal144_tree = default(object);
		RewriteRuleITokenStream stream_75=new RewriteRuleITokenStream(adaptor,"token 75");
		RewriteRuleITokenStream stream_102=new RewriteRuleITokenStream(adaptor,"token 102");
		RewriteRuleITokenStream stream_104=new RewriteRuleITokenStream(adaptor,"token 104");
		RewriteRuleSubtreeStream stream_variableDeclarationList=new RewriteRuleSubtreeStream(adaptor,"rule variableDeclarationList");
		try { DebugEnterRule(GrammarFileName, "tupleLiteralExp");
		DebugLocation(253, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:255:2: (roottoken= 'Tuple' '{' variableDeclarationList '}' -> ^( TUPLELITERAL[$roottoken] $roottoken variableDeclarationList ) )
			DebugEnterAlt(1);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:255:4: roottoken= 'Tuple' '{' variableDeclarationList '}'
			{
			DebugLocation(255, 13);
			roottoken=(CommonToken)Match(input,75,Follow._75_in_tupleLiteralExp1580);  
			stream_75.Add(roottoken);

			DebugLocation(255, 22);
			char_literal142=(CommonToken)Match(input,102,Follow._102_in_tupleLiteralExp1582);  
			stream_102.Add(char_literal142);

			DebugLocation(255, 26);
			PushFollow(Follow._variableDeclarationList_in_tupleLiteralExp1584);
			variableDeclarationList143=variableDeclarationList();
			PopFollow();

			stream_variableDeclarationList.Add(variableDeclarationList143.Tree);
			DebugLocation(255, 50);
			char_literal144=(CommonToken)Match(input,104,Follow._104_in_tupleLiteralExp1586);  
			stream_104.Add(char_literal144);



			{
			// AST REWRITE
			// elements: roottoken, variableDeclarationList
			// token labels: roottoken
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleITokenStream stream_roottoken=new RewriteRuleITokenStream(adaptor,"token roottoken",roottoken);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 255:54: -> ^( TUPLELITERAL[$roottoken] $roottoken variableDeclarationList )
			{
				DebugLocation(255, 57);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:255:57: ^( TUPLELITERAL[$roottoken] $roottoken variableDeclarationList )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(255, 59);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(TUPLELITERAL, roottoken), root_1);

				DebugLocation(255, 85);
				adaptor.AddChild(root_1, stream_roottoken.NextNode());
				DebugLocation(255, 95);
				adaptor.AddChild(root_1, stream_variableDeclarationList.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("tupleLiteralExp", 40);
			LeaveRule("tupleLiteralExp", 40);
			LeaveRule_tupleLiteralExp();
		}
		DebugLocation(256, 1);
		} finally { DebugExitRule(GrammarFileName, "tupleLiteralExp"); }
		return retval;

	}
	// $ANTLR end "tupleLiteralExp"

	private sealed partial class typeLiteralExp_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public typeLiteralExp_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_typeLiteralExp();
	partial void LeaveRule_typeLiteralExp();

	// $ANTLR start "typeLiteralExp"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:258:1: typeLiteralExp : type ;
	[GrammarRule("typeLiteralExp")]
	private OCLSyntaxParser.typeLiteralExp_return typeLiteralExp()
	{
		EnterRule_typeLiteralExp();
		EnterRule("typeLiteralExp", 41);
		TraceIn("typeLiteralExp", 41);
		OCLSyntaxParser.typeLiteralExp_return retval = new OCLSyntaxParser.typeLiteralExp_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		OCLSyntaxParser.type_return type145 = default(OCLSyntaxParser.type_return);


		try { DebugEnterRule(GrammarFileName, "typeLiteralExp");
		DebugLocation(258, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:259:2: ( type )
			DebugEnterAlt(1);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:259:3: type
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(259, 3);
			PushFollow(Follow._type_in_typeLiteralExp1610);
			type145=type();
			PopFollow();

			adaptor.AddChild(root_0, type145.Tree);

			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("typeLiteralExp", 41);
			LeaveRule("typeLiteralExp", 41);
			LeaveRule_typeLiteralExp();
		}
		DebugLocation(260, 1);
		} finally { DebugExitRule(GrammarFileName, "typeLiteralExp"); }
		return retval;

	}
	// $ANTLR end "typeLiteralExp"

	private sealed partial class variableDeclaration_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public variableDeclaration_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_variableDeclaration();
	partial void LeaveRule_variableDeclaration();

	// $ANTLR start "variableDeclaration"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:262:1: variableDeclaration : SimpleName ( ':' type )? ( '=' oclExpression )? -> ^( DECL SimpleName ( type )? ( oclExpression )? ) ;
	[GrammarRule("variableDeclaration")]
	private OCLSyntaxParser.variableDeclaration_return variableDeclaration()
	{
		EnterRule_variableDeclaration();
		EnterRule("variableDeclaration", 42);
		TraceIn("variableDeclaration", 42);
		OCLSyntaxParser.variableDeclaration_return retval = new OCLSyntaxParser.variableDeclaration_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		CommonToken SimpleName146 = default(CommonToken);
		CommonToken char_literal147 = default(CommonToken);
		CommonToken char_literal149 = default(CommonToken);
		OCLSyntaxParser.type_return type148 = default(OCLSyntaxParser.type_return);
		OCLSyntaxParser.oclExpression_return oclExpression150 = default(OCLSyntaxParser.oclExpression_return);

		object SimpleName146_tree = default(object);
		object char_literal147_tree = default(object);
		object char_literal149_tree = default(object);
		RewriteRuleITokenStream stream_SimpleName=new RewriteRuleITokenStream(adaptor,"token SimpleName");
		RewriteRuleITokenStream stream_51=new RewriteRuleITokenStream(adaptor,"token 51");
		RewriteRuleITokenStream stream_57=new RewriteRuleITokenStream(adaptor,"token 57");
		RewriteRuleSubtreeStream stream_type=new RewriteRuleSubtreeStream(adaptor,"rule type");
		RewriteRuleSubtreeStream stream_oclExpression=new RewriteRuleSubtreeStream(adaptor,"rule oclExpression");
		try { DebugEnterRule(GrammarFileName, "variableDeclaration");
		DebugLocation(262, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:263:2: ( SimpleName ( ':' type )? ( '=' oclExpression )? -> ^( DECL SimpleName ( type )? ( oclExpression )? ) )
			DebugEnterAlt(1);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:263:3: SimpleName ( ':' type )? ( '=' oclExpression )?
			{
			DebugLocation(263, 3);
			SimpleName146=(CommonToken)Match(input,SimpleName,Follow._SimpleName_in_variableDeclaration1620);  
			stream_SimpleName.Add(SimpleName146);

			DebugLocation(263, 14);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:263:14: ( ':' type )?
			int alt58=2;
			try { DebugEnterSubRule(58);
			try { DebugEnterDecision(58, false);
			int LA58_0 = input.LA(1);

			if ((LA58_0==51))
			{
				alt58 = 1;
			}
			} finally { DebugExitDecision(58); }
			switch (alt58)
			{
			case 1:
				DebugEnterAlt(1);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:263:15: ':' type
				{
				DebugLocation(263, 15);
				char_literal147=(CommonToken)Match(input,51,Follow._51_in_variableDeclaration1623);  
				stream_51.Add(char_literal147);

				DebugLocation(263, 19);
				PushFollow(Follow._type_in_variableDeclaration1625);
				type148=type();
				PopFollow();

				stream_type.Add(type148.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(58); }

			DebugLocation(263, 26);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:263:26: ( '=' oclExpression )?
			int alt59=2;
			try { DebugEnterSubRule(59);
			try { DebugEnterDecision(59, false);
			int LA59_0 = input.LA(1);

			if ((LA59_0==57))
			{
				alt59 = 1;
			}
			} finally { DebugExitDecision(59); }
			switch (alt59)
			{
			case 1:
				DebugEnterAlt(1);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:263:28: '=' oclExpression
				{
				DebugLocation(263, 28);
				char_literal149=(CommonToken)Match(input,57,Follow._57_in_variableDeclaration1631);  
				stream_57.Add(char_literal149);

				DebugLocation(263, 32);
				PushFollow(Follow._oclExpression_in_variableDeclaration1633);
				oclExpression150=oclExpression();
				PopFollow();

				stream_oclExpression.Add(oclExpression150.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(59); }



			{
			// AST REWRITE
			// elements: SimpleName, type, oclExpression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 263:49: -> ^( DECL SimpleName ( type )? ( oclExpression )? )
			{
				DebugLocation(263, 52);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:263:52: ^( DECL SimpleName ( type )? ( oclExpression )? )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(263, 54);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(DECL, "DECL"), root_1);

				DebugLocation(263, 59);
				adaptor.AddChild(root_1, stream_SimpleName.NextNode());
				DebugLocation(263, 70);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:263:70: ( type )?
				if (stream_type.HasNext)
				{
					DebugLocation(263, 70);
					adaptor.AddChild(root_1, stream_type.NextTree());

				}
				stream_type.Reset();
				DebugLocation(263, 76);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:263:76: ( oclExpression )?
				if (stream_oclExpression.HasNext)
				{
					DebugLocation(263, 76);
					adaptor.AddChild(root_1, stream_oclExpression.NextTree());

				}
				stream_oclExpression.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("variableDeclaration", 42);
			LeaveRule("variableDeclaration", 42);
			LeaveRule_variableDeclaration();
		}
		DebugLocation(264, 1);
		} finally { DebugExitRule(GrammarFileName, "variableDeclaration"); }
		return retval;

	}
	// $ANTLR end "variableDeclaration"

	private sealed partial class type_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public type_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_type();
	partial void LeaveRule_type();

	// $ANTLR start "type"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:266:1: type : ( pathName | collectionType | tupleType | primitiveType | oclType );
	[GrammarRule("type")]
	private OCLSyntaxParser.type_return type()
	{
		EnterRule_type();
		EnterRule("type", 43);
		TraceIn("type", 43);
		OCLSyntaxParser.type_return retval = new OCLSyntaxParser.type_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		OCLSyntaxParser.pathName_return pathName151 = default(OCLSyntaxParser.pathName_return);
		OCLSyntaxParser.collectionType_return collectionType152 = default(OCLSyntaxParser.collectionType_return);
		OCLSyntaxParser.tupleType_return tupleType153 = default(OCLSyntaxParser.tupleType_return);
		OCLSyntaxParser.primitiveType_return primitiveType154 = default(OCLSyntaxParser.primitiveType_return);
		OCLSyntaxParser.oclType_return oclType155 = default(OCLSyntaxParser.oclType_return);


		try { DebugEnterRule(GrammarFileName, "type");
		DebugLocation(266, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:267:2: ( pathName | collectionType | tupleType | primitiveType | oclType )
			int alt60=5;
			try { DebugEnterDecision(60, false);
			switch (input.LA(1))
			{
			case SimpleName:
				{
				alt60 = 1;
				}
				break;
			case 62:
			case 64:
			case 70:
			case 72:
			case 73:
				{
				alt60 = 2;
				}
				break;
			case 75:
				{
				alt60 = 3;
				}
				break;
			case 63:
			case 65:
			case 71:
			case 74:
			case 76:
				{
				alt60 = 4;
				}
				break;
			case 66:
			case 67:
			case 68:
			case 69:
				{
				alt60 = 5;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 60, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(60); }
			switch (alt60)
			{
			case 1:
				DebugEnterAlt(1);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:267:4: pathName
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(267, 4);
				PushFollow(Follow._pathName_in_type1662);
				pathName151=pathName();
				PopFollow();

				adaptor.AddChild(root_0, pathName151.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:268:4: collectionType
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(268, 4);
				PushFollow(Follow._collectionType_in_type1670);
				collectionType152=collectionType();
				PopFollow();

				adaptor.AddChild(root_0, collectionType152.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:269:4: tupleType
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(269, 4);
				PushFollow(Follow._tupleType_in_type1676);
				tupleType153=tupleType();
				PopFollow();

				adaptor.AddChild(root_0, tupleType153.Tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:270:4: primitiveType
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(270, 4);
				PushFollow(Follow._primitiveType_in_type1683);
				primitiveType154=primitiveType();
				PopFollow();

				adaptor.AddChild(root_0, primitiveType154.Tree);

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:271:4: oclType
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(271, 4);
				PushFollow(Follow._oclType_in_type1690);
				oclType155=oclType();
				PopFollow();

				adaptor.AddChild(root_0, oclType155.Tree);

				}
				break;

			}
			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("type", 43);
			LeaveRule("type", 43);
			LeaveRule_type();
		}
		DebugLocation(272, 1);
		} finally { DebugExitRule(GrammarFileName, "type"); }
		return retval;

	}
	// $ANTLR end "type"

	private sealed partial class primitiveType_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public primitiveType_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_primitiveType();
	partial void LeaveRule_primitiveType();

	// $ANTLR start "primitiveType"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:274:1: primitiveType : ( 'Boolean' | 'Integer' | 'Real' | 'String' | 'UnlimitedNatural' );
	[GrammarRule("primitiveType")]
	private OCLSyntaxParser.primitiveType_return primitiveType()
	{
		EnterRule_primitiveType();
		EnterRule("primitiveType", 44);
		TraceIn("primitiveType", 44);
		OCLSyntaxParser.primitiveType_return retval = new OCLSyntaxParser.primitiveType_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		CommonToken set156 = default(CommonToken);

		object set156_tree = default(object);

		try { DebugEnterRule(GrammarFileName, "primitiveType");
		DebugLocation(274, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:275:2: ( 'Boolean' | 'Integer' | 'Real' | 'String' | 'UnlimitedNatural' )
			DebugEnterAlt(1);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(275, 2);
			set156=(CommonToken)input.LT(1);
			if (input.LA(1)==63||input.LA(1)==65||input.LA(1)==71||input.LA(1)==74||input.LA(1)==76)
			{
				input.Consume();
				adaptor.AddChild(root_0, (object)adaptor.Create(set156));
				state.errorRecovery=false;
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("primitiveType", 44);
			LeaveRule("primitiveType", 44);
			LeaveRule_primitiveType();
		}
		DebugLocation(280, 1);
		} finally { DebugExitRule(GrammarFileName, "primitiveType"); }
		return retval;

	}
	// $ANTLR end "primitiveType"

	private sealed partial class oclType_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public oclType_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_oclType();
	partial void LeaveRule_oclType();

	// $ANTLR start "oclType"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:282:1: oclType : ( 'OclAny' | 'OclInvalid' | 'OclMessage' | 'OclVoid' );
	[GrammarRule("oclType")]
	private OCLSyntaxParser.oclType_return oclType()
	{
		EnterRule_oclType();
		EnterRule("oclType", 45);
		TraceIn("oclType", 45);
		OCLSyntaxParser.oclType_return retval = new OCLSyntaxParser.oclType_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		CommonToken set157 = default(CommonToken);

		object set157_tree = default(object);

		try { DebugEnterRule(GrammarFileName, "oclType");
		DebugLocation(282, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:283:2: ( 'OclAny' | 'OclInvalid' | 'OclMessage' | 'OclVoid' )
			DebugEnterAlt(1);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(283, 2);
			set157=(CommonToken)input.LT(1);
			if ((input.LA(1)>=66 && input.LA(1)<=69))
			{
				input.Consume();
				adaptor.AddChild(root_0, (object)adaptor.Create(set157));
				state.errorRecovery=false;
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("oclType", 45);
			LeaveRule("oclType", 45);
			LeaveRule_oclType();
		}
		DebugLocation(287, 1);
		} finally { DebugExitRule(GrammarFileName, "oclType"); }
		return retval;

	}
	// $ANTLR end "oclType"

	private sealed partial class collectionType_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public collectionType_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_collectionType();
	partial void LeaveRule_collectionType();

	// $ANTLR start "collectionType"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:289:1: collectionType : collectionTypeIdentifier '(' type ')' -> COLLTYPE collectionTypeIdentifier type ;
	[GrammarRule("collectionType")]
	private OCLSyntaxParser.collectionType_return collectionType()
	{
		EnterRule_collectionType();
		EnterRule("collectionType", 46);
		TraceIn("collectionType", 46);
		OCLSyntaxParser.collectionType_return retval = new OCLSyntaxParser.collectionType_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		CommonToken char_literal159 = default(CommonToken);
		CommonToken char_literal161 = default(CommonToken);
		OCLSyntaxParser.collectionTypeIdentifier_return collectionTypeIdentifier158 = default(OCLSyntaxParser.collectionTypeIdentifier_return);
		OCLSyntaxParser.type_return type160 = default(OCLSyntaxParser.type_return);

		object char_literal159_tree = default(object);
		object char_literal161_tree = default(object);
		RewriteRuleITokenStream stream_42=new RewriteRuleITokenStream(adaptor,"token 42");
		RewriteRuleITokenStream stream_43=new RewriteRuleITokenStream(adaptor,"token 43");
		RewriteRuleSubtreeStream stream_collectionTypeIdentifier=new RewriteRuleSubtreeStream(adaptor,"rule collectionTypeIdentifier");
		RewriteRuleSubtreeStream stream_type=new RewriteRuleSubtreeStream(adaptor,"rule type");
		try { DebugEnterRule(GrammarFileName, "collectionType");
		DebugLocation(289, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:290:2: ( collectionTypeIdentifier '(' type ')' -> COLLTYPE collectionTypeIdentifier type )
			DebugEnterAlt(1);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:290:4: collectionTypeIdentifier '(' type ')'
			{
			DebugLocation(290, 4);
			PushFollow(Follow._collectionTypeIdentifier_in_collectionType1796);
			collectionTypeIdentifier158=collectionTypeIdentifier();
			PopFollow();

			stream_collectionTypeIdentifier.Add(collectionTypeIdentifier158.Tree);
			DebugLocation(290, 29);
			char_literal159=(CommonToken)Match(input,42,Follow._42_in_collectionType1798);  
			stream_42.Add(char_literal159);

			DebugLocation(290, 33);
			PushFollow(Follow._type_in_collectionType1800);
			type160=type();
			PopFollow();

			stream_type.Add(type160.Tree);
			DebugLocation(290, 39);
			char_literal161=(CommonToken)Match(input,43,Follow._43_in_collectionType1803);  
			stream_43.Add(char_literal161);



			{
			// AST REWRITE
			// elements: collectionTypeIdentifier, type
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 290:43: -> COLLTYPE collectionTypeIdentifier type
			{
				DebugLocation(290, 46);
				adaptor.AddChild(root_0, (object)adaptor.Create(COLLTYPE, "COLLTYPE"));
				DebugLocation(290, 56);
				adaptor.AddChild(root_0, stream_collectionTypeIdentifier.NextTree());
				DebugLocation(290, 81);
				adaptor.AddChild(root_0, stream_type.NextTree());

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("collectionType", 46);
			LeaveRule("collectionType", 46);
			LeaveRule_collectionType();
		}
		DebugLocation(291, 1);
		} finally { DebugExitRule(GrammarFileName, "collectionType"); }
		return retval;

	}
	// $ANTLR end "collectionType"

	private sealed partial class tupleType_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public tupleType_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_tupleType();
	partial void LeaveRule_tupleType();

	// $ANTLR start "tupleType"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:293:1: tupleType : 'Tuple' '(' ( variableDeclarationList )? ')' ;
	[GrammarRule("tupleType")]
	private OCLSyntaxParser.tupleType_return tupleType()
	{
		EnterRule_tupleType();
		EnterRule("tupleType", 47);
		TraceIn("tupleType", 47);
		OCLSyntaxParser.tupleType_return retval = new OCLSyntaxParser.tupleType_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		CommonToken string_literal162 = default(CommonToken);
		CommonToken char_literal163 = default(CommonToken);
		CommonToken char_literal165 = default(CommonToken);
		OCLSyntaxParser.variableDeclarationList_return variableDeclarationList164 = default(OCLSyntaxParser.variableDeclarationList_return);

		object string_literal162_tree = default(object);
		object char_literal163_tree = default(object);
		object char_literal165_tree = default(object);

		try { DebugEnterRule(GrammarFileName, "tupleType");
		DebugLocation(293, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:294:2: ( 'Tuple' '(' ( variableDeclarationList )? ')' )
			DebugEnterAlt(1);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:294:4: 'Tuple' '(' ( variableDeclarationList )? ')'
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(294, 11);
			string_literal162=(CommonToken)Match(input,75,Follow._75_in_tupleType1826); 
			string_literal162_tree = (object)adaptor.Create(string_literal162);
			root_0 = (object)adaptor.BecomeRoot(string_literal162_tree, root_0);

			DebugLocation(294, 16);
			char_literal163=(CommonToken)Match(input,42,Follow._42_in_tupleType1829); 
			DebugLocation(294, 18);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:294:18: ( variableDeclarationList )?
			int alt61=2;
			try { DebugEnterSubRule(61);
			try { DebugEnterDecision(61, false);
			int LA61_0 = input.LA(1);

			if ((LA61_0==SimpleName))
			{
				alt61 = 1;
			}
			} finally { DebugExitDecision(61); }
			switch (alt61)
			{
			case 1:
				DebugEnterAlt(1);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:294:18: variableDeclarationList
				{
				DebugLocation(294, 18);
				PushFollow(Follow._variableDeclarationList_in_tupleType1832);
				variableDeclarationList164=variableDeclarationList();
				PopFollow();

				adaptor.AddChild(root_0, variableDeclarationList164.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(61); }

			DebugLocation(294, 46);
			char_literal165=(CommonToken)Match(input,43,Follow._43_in_tupleType1835); 

			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("tupleType", 47);
			LeaveRule("tupleType", 47);
			LeaveRule_tupleType();
		}
		DebugLocation(295, 1);
		} finally { DebugExitRule(GrammarFileName, "tupleType"); }
		return retval;

	}
	// $ANTLR end "tupleType"

	private sealed partial class variableDeclarationList_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public variableDeclarationList_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_variableDeclarationList();
	partial void LeaveRule_variableDeclarationList();

	// $ANTLR start "variableDeclarationList"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:298:1: variableDeclarationList : variableDeclaration ( ',' variableDeclaration )* ;
	[GrammarRule("variableDeclarationList")]
	private OCLSyntaxParser.variableDeclarationList_return variableDeclarationList()
	{
		EnterRule_variableDeclarationList();
		EnterRule("variableDeclarationList", 48);
		TraceIn("variableDeclarationList", 48);
		OCLSyntaxParser.variableDeclarationList_return retval = new OCLSyntaxParser.variableDeclarationList_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		CommonToken char_literal167 = default(CommonToken);
		OCLSyntaxParser.variableDeclaration_return variableDeclaration166 = default(OCLSyntaxParser.variableDeclaration_return);
		OCLSyntaxParser.variableDeclaration_return variableDeclaration168 = default(OCLSyntaxParser.variableDeclaration_return);

		object char_literal167_tree = default(object);

		try { DebugEnterRule(GrammarFileName, "variableDeclarationList");
		DebugLocation(298, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:299:2: ( variableDeclaration ( ',' variableDeclaration )* )
			DebugEnterAlt(1);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:299:4: variableDeclaration ( ',' variableDeclaration )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(299, 4);
			PushFollow(Follow._variableDeclaration_in_variableDeclarationList1850);
			variableDeclaration166=variableDeclaration();
			PopFollow();

			adaptor.AddChild(root_0, variableDeclaration166.Tree);
			DebugLocation(299, 24);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:299:24: ( ',' variableDeclaration )*
			try { DebugEnterSubRule(62);
			while (true)
			{
				int alt62=2;
				try { DebugEnterDecision(62, false);
				int LA62_0 = input.LA(1);

				if ((LA62_0==45))
				{
					alt62 = 1;
				}


				} finally { DebugExitDecision(62); }
				switch ( alt62 )
				{
				case 1:
					DebugEnterAlt(1);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:299:25: ',' variableDeclaration
					{
					DebugLocation(299, 28);
					char_literal167=(CommonToken)Match(input,45,Follow._45_in_variableDeclarationList1853); 
					DebugLocation(299, 30);
					PushFollow(Follow._variableDeclaration_in_variableDeclarationList1856);
					variableDeclaration168=variableDeclaration();
					PopFollow();

					adaptor.AddChild(root_0, variableDeclaration168.Tree);

					}
					break;

				default:
					goto loop62;
				}
			}

			loop62:
				;

			} finally { DebugExitSubRule(62); }


			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("variableDeclarationList", 48);
			LeaveRule("variableDeclarationList", 48);
			LeaveRule_variableDeclarationList();
		}
		DebugLocation(300, 1);
		} finally { DebugExitRule(GrammarFileName, "variableDeclarationList"); }
		return retval;

	}
	// $ANTLR end "variableDeclarationList"

	private sealed partial class isMarkedPre_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public isMarkedPre_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_isMarkedPre();
	partial void LeaveRule_isMarkedPre();

	// $ANTLR start "isMarkedPre"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:301:1: isMarkedPre : '@' 'pre' ;
	[GrammarRule("isMarkedPre")]
	private OCLSyntaxParser.isMarkedPre_return isMarkedPre()
	{
		EnterRule_isMarkedPre();
		EnterRule("isMarkedPre", 49);
		TraceIn("isMarkedPre", 49);
		OCLSyntaxParser.isMarkedPre_return retval = new OCLSyntaxParser.isMarkedPre_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		CommonToken char_literal169 = default(CommonToken);
		CommonToken string_literal170 = default(CommonToken);

		object char_literal169_tree = default(object);
		object string_literal170_tree = default(object);

		try { DebugEnterRule(GrammarFileName, "isMarkedPre");
		DebugLocation(301, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:302:2: ( '@' 'pre' )
			DebugEnterAlt(1);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:302:4: '@' 'pre'
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(302, 7);
			char_literal169=(CommonToken)Match(input,61,Follow._61_in_isMarkedPre1871); 
			DebugLocation(302, 14);
			string_literal170=(CommonToken)Match(input,98,Follow._98_in_isMarkedPre1874); 
			string_literal170_tree = (object)adaptor.Create(string_literal170);
			root_0 = (object)adaptor.BecomeRoot(string_literal170_tree, root_0);


			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("isMarkedPre", 49);
			LeaveRule("isMarkedPre", 49);
			LeaveRule_isMarkedPre();
		}
		DebugLocation(303, 1);
		} finally { DebugExitRule(GrammarFileName, "isMarkedPre"); }
		return retval;

	}
	// $ANTLR end "isMarkedPre"

	private sealed partial class arguments_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public arguments_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_arguments();
	partial void LeaveRule_arguments();

	// $ANTLR start "arguments"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:305:1: arguments : exp1= oclExpression ( ',' exp2= oclExpression )* ;
	[GrammarRule("arguments")]
	private OCLSyntaxParser.arguments_return arguments()
	{
		EnterRule_arguments();
		EnterRule("arguments", 50);
		TraceIn("arguments", 50);
		OCLSyntaxParser.arguments_return retval = new OCLSyntaxParser.arguments_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		CommonToken char_literal171 = default(CommonToken);
		OCLSyntaxParser.oclExpression_return exp1 = default(OCLSyntaxParser.oclExpression_return);
		OCLSyntaxParser.oclExpression_return exp2 = default(OCLSyntaxParser.oclExpression_return);

		object char_literal171_tree = default(object);

		try { DebugEnterRule(GrammarFileName, "arguments");
		DebugLocation(305, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:306:2: (exp1= oclExpression ( ',' exp2= oclExpression )* )
			DebugEnterAlt(1);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:306:4: exp1= oclExpression ( ',' exp2= oclExpression )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(306, 9);
			PushFollow(Follow._oclExpression_in_arguments1892);
			exp1=oclExpression();
			PopFollow();

			adaptor.AddChild(root_0, exp1.Tree);
			DebugLocation(306, 26);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:306:26: ( ',' exp2= oclExpression )*
			try { DebugEnterSubRule(63);
			while (true)
			{
				int alt63=2;
				try { DebugEnterDecision(63, false);
				int LA63_0 = input.LA(1);

				if ((LA63_0==45))
				{
					alt63 = 1;
				}


				} finally { DebugExitDecision(63); }
				switch ( alt63 )
				{
				case 1:
					DebugEnterAlt(1);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:306:28: ',' exp2= oclExpression
					{
					DebugLocation(306, 31);
					char_literal171=(CommonToken)Match(input,45,Follow._45_in_arguments1897); 
					DebugLocation(306, 37);
					PushFollow(Follow._oclExpression_in_arguments1902);
					exp2=oclExpression();
					PopFollow();

					adaptor.AddChild(root_0, exp2.Tree);

					}
					break;

				default:
					goto loop63;
				}
			}

			loop63:
				;

			} finally { DebugExitSubRule(63); }


			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("arguments", 50);
			LeaveRule("arguments", 50);
			LeaveRule_arguments();
		}
		DebugLocation(307, 1);
		} finally { DebugExitRule(GrammarFileName, "arguments"); }
		return retval;

	}
	// $ANTLR end "arguments"

	private sealed partial class letExp_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public letExp_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_letExp();
	partial void LeaveRule_letExp();

	// $ANTLR start "letExp"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:310:1: letExp : 'let' variableDeclaration letExpSub -> ^( LET variableDeclaration letExpSub ) ;
	[GrammarRule("letExp")]
	private OCLSyntaxParser.letExp_return letExp()
	{
		EnterRule_letExp();
		EnterRule("letExp", 51);
		TraceIn("letExp", 51);
		OCLSyntaxParser.letExp_return retval = new OCLSyntaxParser.letExp_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		CommonToken string_literal172 = default(CommonToken);
		OCLSyntaxParser.variableDeclaration_return variableDeclaration173 = default(OCLSyntaxParser.variableDeclaration_return);
		OCLSyntaxParser.letExpSub_return letExpSub174 = default(OCLSyntaxParser.letExpSub_return);

		object string_literal172_tree = default(object);
		RewriteRuleITokenStream stream_94=new RewriteRuleITokenStream(adaptor,"token 94");
		RewriteRuleSubtreeStream stream_variableDeclaration=new RewriteRuleSubtreeStream(adaptor,"rule variableDeclaration");
		RewriteRuleSubtreeStream stream_letExpSub=new RewriteRuleSubtreeStream(adaptor,"rule letExpSub");
		try { DebugEnterRule(GrammarFileName, "letExp");
		DebugLocation(310, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:311:2: ( 'let' variableDeclaration letExpSub -> ^( LET variableDeclaration letExpSub ) )
			DebugEnterAlt(1);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:311:4: 'let' variableDeclaration letExpSub
			{
			DebugLocation(311, 4);
			string_literal172=(CommonToken)Match(input,94,Follow._94_in_letExp1918);  
			stream_94.Add(string_literal172);

			DebugLocation(311, 10);
			PushFollow(Follow._variableDeclaration_in_letExp1920);
			variableDeclaration173=variableDeclaration();
			PopFollow();

			stream_variableDeclaration.Add(variableDeclaration173.Tree);
			DebugLocation(311, 30);
			PushFollow(Follow._letExpSub_in_letExp1922);
			letExpSub174=letExpSub();
			PopFollow();

			stream_letExpSub.Add(letExpSub174.Tree);


			{
			// AST REWRITE
			// elements: variableDeclaration, letExpSub
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 311:40: -> ^( LET variableDeclaration letExpSub )
			{
				DebugLocation(311, 43);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:311:43: ^( LET variableDeclaration letExpSub )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(311, 45);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(LET, "LET"), root_1);

				DebugLocation(311, 49);
				adaptor.AddChild(root_1, stream_variableDeclaration.NextTree());
				DebugLocation(311, 69);
				adaptor.AddChild(root_1, stream_letExpSub.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("letExp", 51);
			LeaveRule("letExp", 51);
			LeaveRule_letExp();
		}
		DebugLocation(312, 1);
		} finally { DebugExitRule(GrammarFileName, "letExp"); }
		return retval;

	}
	// $ANTLR end "letExp"

	private sealed partial class letExpSub_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public letExpSub_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_letExpSub();
	partial void LeaveRule_letExpSub();

	// $ANTLR start "letExpSub"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:314:1: letExpSub : ( ',' variableDeclaration letExpSub -> ^( LET variableDeclaration letExpSub ) | 'in' ( options {greedy=false; } : oclExpression ) -> oclExpression );
	[GrammarRule("letExpSub")]
	private OCLSyntaxParser.letExpSub_return letExpSub()
	{
		EnterRule_letExpSub();
		EnterRule("letExpSub", 52);
		TraceIn("letExpSub", 52);
		OCLSyntaxParser.letExpSub_return retval = new OCLSyntaxParser.letExpSub_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		CommonToken char_literal175 = default(CommonToken);
		CommonToken string_literal178 = default(CommonToken);
		OCLSyntaxParser.variableDeclaration_return variableDeclaration176 = default(OCLSyntaxParser.variableDeclaration_return);
		OCLSyntaxParser.letExpSub_return letExpSub177 = default(OCLSyntaxParser.letExpSub_return);
		OCLSyntaxParser.oclExpression_return oclExpression179 = default(OCLSyntaxParser.oclExpression_return);

		object char_literal175_tree = default(object);
		object string_literal178_tree = default(object);
		RewriteRuleITokenStream stream_45=new RewriteRuleITokenStream(adaptor,"token 45");
		RewriteRuleITokenStream stream_90=new RewriteRuleITokenStream(adaptor,"token 90");
		RewriteRuleSubtreeStream stream_variableDeclaration=new RewriteRuleSubtreeStream(adaptor,"rule variableDeclaration");
		RewriteRuleSubtreeStream stream_letExpSub=new RewriteRuleSubtreeStream(adaptor,"rule letExpSub");
		RewriteRuleSubtreeStream stream_oclExpression=new RewriteRuleSubtreeStream(adaptor,"rule oclExpression");
		try { DebugEnterRule(GrammarFileName, "letExpSub");
		DebugLocation(314, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:315:2: ( ',' variableDeclaration letExpSub -> ^( LET variableDeclaration letExpSub ) | 'in' ( options {greedy=false; } : oclExpression ) -> oclExpression )
			int alt64=2;
			try { DebugEnterDecision(64, false);
			int LA64_0 = input.LA(1);

			if ((LA64_0==45))
			{
				alt64 = 1;
			}
			else if ((LA64_0==90))
			{
				alt64 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 64, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(64); }
			switch (alt64)
			{
			case 1:
				DebugEnterAlt(1);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:315:4: ',' variableDeclaration letExpSub
				{
				DebugLocation(315, 4);
				char_literal175=(CommonToken)Match(input,45,Follow._45_in_letExpSub1944);  
				stream_45.Add(char_literal175);

				DebugLocation(315, 8);
				PushFollow(Follow._variableDeclaration_in_letExpSub1946);
				variableDeclaration176=variableDeclaration();
				PopFollow();

				stream_variableDeclaration.Add(variableDeclaration176.Tree);
				DebugLocation(315, 28);
				PushFollow(Follow._letExpSub_in_letExpSub1948);
				letExpSub177=letExpSub();
				PopFollow();

				stream_letExpSub.Add(letExpSub177.Tree);


				{
				// AST REWRITE
				// elements: variableDeclaration, letExpSub
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 315:38: -> ^( LET variableDeclaration letExpSub )
				{
					DebugLocation(315, 41);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:315:41: ^( LET variableDeclaration letExpSub )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(315, 43);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(LET, "LET"), root_1);

					DebugLocation(315, 47);
					adaptor.AddChild(root_1, stream_variableDeclaration.NextTree());
					DebugLocation(315, 67);
					adaptor.AddChild(root_1, stream_letExpSub.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:316:4: 'in' ( options {greedy=false; } : oclExpression )
				{
				DebugLocation(316, 4);
				string_literal178=(CommonToken)Match(input,90,Follow._90_in_letExpSub1963);  
				stream_90.Add(string_literal178);

				DebugLocation(316, 9);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:316:9: ( options {greedy=false; } : oclExpression )
				DebugEnterAlt(1);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:316:35: oclExpression
				{
				DebugLocation(316, 35);
				PushFollow(Follow._oclExpression_in_letExpSub1974);
				oclExpression179=oclExpression();
				PopFollow();

				stream_oclExpression.Add(oclExpression179.Tree);

				}



				{
				// AST REWRITE
				// elements: oclExpression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 316:50: -> oclExpression
				{
					DebugLocation(316, 53);
					adaptor.AddChild(root_0, stream_oclExpression.NextTree());

				}

				retval.Tree = root_0;
				}

				}
				break;

			}
			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("letExpSub", 52);
			LeaveRule("letExpSub", 52);
			LeaveRule_letExpSub();
		}
		DebugLocation(317, 1);
		} finally { DebugExitRule(GrammarFileName, "letExpSub"); }
		return retval;

	}
	// $ANTLR end "letExpSub"

	private sealed partial class oclMessageExp_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public oclMessageExp_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_oclMessageExp();
	partial void LeaveRule_oclMessageExp();

	// $ANTLR start "oclMessageExp"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:319:1: oclMessageExp : ( '^^' SimpleName '(' ( oclMessageArguments )? ')' | '^' SimpleName '(' ( oclMessageArguments )? ')' );
	[GrammarRule("oclMessageExp")]
	private OCLSyntaxParser.oclMessageExp_return oclMessageExp()
	{
		EnterRule_oclMessageExp();
		EnterRule("oclMessageExp", 53);
		TraceIn("oclMessageExp", 53);
		OCLSyntaxParser.oclMessageExp_return retval = new OCLSyntaxParser.oclMessageExp_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		CommonToken string_literal180 = default(CommonToken);
		CommonToken SimpleName181 = default(CommonToken);
		CommonToken char_literal182 = default(CommonToken);
		CommonToken char_literal184 = default(CommonToken);
		CommonToken char_literal185 = default(CommonToken);
		CommonToken SimpleName186 = default(CommonToken);
		CommonToken char_literal187 = default(CommonToken);
		CommonToken char_literal189 = default(CommonToken);
		OCLSyntaxParser.oclMessageArguments_return oclMessageArguments183 = default(OCLSyntaxParser.oclMessageArguments_return);
		OCLSyntaxParser.oclMessageArguments_return oclMessageArguments188 = default(OCLSyntaxParser.oclMessageArguments_return);

		object string_literal180_tree = default(object);
		object SimpleName181_tree = default(object);
		object char_literal182_tree = default(object);
		object char_literal184_tree = default(object);
		object char_literal185_tree = default(object);
		object SimpleName186_tree = default(object);
		object char_literal187_tree = default(object);
		object char_literal189_tree = default(object);

		try { DebugEnterRule(GrammarFileName, "oclMessageExp");
		DebugLocation(319, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:320:2: ( '^^' SimpleName '(' ( oclMessageArguments )? ')' | '^' SimpleName '(' ( oclMessageArguments )? ')' )
			int alt67=2;
			try { DebugEnterDecision(67, false);
			int LA67_0 = input.LA(1);

			if ((LA67_0==80))
			{
				alt67 = 1;
			}
			else if ((LA67_0==79))
			{
				alt67 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 67, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(67); }
			switch (alt67)
			{
			case 1:
				DebugEnterAlt(1);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:320:4: '^^' SimpleName '(' ( oclMessageArguments )? ')'
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(320, 4);
				string_literal180=(CommonToken)Match(input,80,Follow._80_in_oclMessageExp1990); 
				string_literal180_tree = (object)adaptor.Create(string_literal180);
				adaptor.AddChild(root_0, string_literal180_tree);

				DebugLocation(320, 9);
				SimpleName181=(CommonToken)Match(input,SimpleName,Follow._SimpleName_in_oclMessageExp1992); 
				SimpleName181_tree = (object)adaptor.Create(SimpleName181);
				adaptor.AddChild(root_0, SimpleName181_tree);

				DebugLocation(320, 20);
				char_literal182=(CommonToken)Match(input,42,Follow._42_in_oclMessageExp1994); 
				char_literal182_tree = (object)adaptor.Create(char_literal182);
				adaptor.AddChild(root_0, char_literal182_tree);

				DebugLocation(320, 24);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:320:24: ( oclMessageArguments )?
				int alt65=2;
				try { DebugEnterSubRule(65);
				try { DebugEnterDecision(65, false);
				int LA65_0 = input.LA(1);

				if ((LA65_0==BooleanLiteralExp||(LA65_0>=IntegerLiteralExp && LA65_0<=InvalidLiteralExp)||LA65_0==NullLiteralExp||(LA65_0>=RealLiteralExp && LA65_0<=SimpleName)||LA65_0==StringLiteralExp||LA65_0==UnlimitedNaturalLiteralExp||LA65_0==42||LA65_0==46||LA65_0==60||(LA65_0>=62 && LA65_0<=76)||LA65_0==88||(LA65_0>=93 && LA65_0<=95)))
				{
					alt65 = 1;
				}
				} finally { DebugExitDecision(65); }
				switch (alt65)
				{
				case 1:
					DebugEnterAlt(1);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:320:24: oclMessageArguments
					{
					DebugLocation(320, 24);
					PushFollow(Follow._oclMessageArguments_in_oclMessageExp1996);
					oclMessageArguments183=oclMessageArguments();
					PopFollow();

					adaptor.AddChild(root_0, oclMessageArguments183.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(65); }

				DebugLocation(320, 45);
				char_literal184=(CommonToken)Match(input,43,Follow._43_in_oclMessageExp1999); 
				char_literal184_tree = (object)adaptor.Create(char_literal184);
				adaptor.AddChild(root_0, char_literal184_tree);


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:321:4: '^' SimpleName '(' ( oclMessageArguments )? ')'
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(321, 4);
				char_literal185=(CommonToken)Match(input,79,Follow._79_in_oclMessageExp2004); 
				char_literal185_tree = (object)adaptor.Create(char_literal185);
				adaptor.AddChild(root_0, char_literal185_tree);

				DebugLocation(321, 8);
				SimpleName186=(CommonToken)Match(input,SimpleName,Follow._SimpleName_in_oclMessageExp2006); 
				SimpleName186_tree = (object)adaptor.Create(SimpleName186);
				adaptor.AddChild(root_0, SimpleName186_tree);

				DebugLocation(321, 19);
				char_literal187=(CommonToken)Match(input,42,Follow._42_in_oclMessageExp2008); 
				char_literal187_tree = (object)adaptor.Create(char_literal187);
				adaptor.AddChild(root_0, char_literal187_tree);

				DebugLocation(321, 23);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:321:23: ( oclMessageArguments )?
				int alt66=2;
				try { DebugEnterSubRule(66);
				try { DebugEnterDecision(66, false);
				int LA66_0 = input.LA(1);

				if ((LA66_0==BooleanLiteralExp||(LA66_0>=IntegerLiteralExp && LA66_0<=InvalidLiteralExp)||LA66_0==NullLiteralExp||(LA66_0>=RealLiteralExp && LA66_0<=SimpleName)||LA66_0==StringLiteralExp||LA66_0==UnlimitedNaturalLiteralExp||LA66_0==42||LA66_0==46||LA66_0==60||(LA66_0>=62 && LA66_0<=76)||LA66_0==88||(LA66_0>=93 && LA66_0<=95)))
				{
					alt66 = 1;
				}
				} finally { DebugExitDecision(66); }
				switch (alt66)
				{
				case 1:
					DebugEnterAlt(1);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:321:23: oclMessageArguments
					{
					DebugLocation(321, 23);
					PushFollow(Follow._oclMessageArguments_in_oclMessageExp2010);
					oclMessageArguments188=oclMessageArguments();
					PopFollow();

					adaptor.AddChild(root_0, oclMessageArguments188.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(66); }

				DebugLocation(321, 44);
				char_literal189=(CommonToken)Match(input,43,Follow._43_in_oclMessageExp2013); 
				char_literal189_tree = (object)adaptor.Create(char_literal189);
				adaptor.AddChild(root_0, char_literal189_tree);


				}
				break;

			}
			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("oclMessageExp", 53);
			LeaveRule("oclMessageExp", 53);
			LeaveRule_oclMessageExp();
		}
		DebugLocation(322, 1);
		} finally { DebugExitRule(GrammarFileName, "oclMessageExp"); }
		return retval;

	}
	// $ANTLR end "oclMessageExp"

	private sealed partial class oclMessageArguments_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public oclMessageArguments_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_oclMessageArguments();
	partial void LeaveRule_oclMessageArguments();

	// $ANTLR start "oclMessageArguments"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:323:1: oclMessageArguments : oclMessageArg ( ',' oclMessageArguments )? ;
	[GrammarRule("oclMessageArguments")]
	private OCLSyntaxParser.oclMessageArguments_return oclMessageArguments()
	{
		EnterRule_oclMessageArguments();
		EnterRule("oclMessageArguments", 54);
		TraceIn("oclMessageArguments", 54);
		OCLSyntaxParser.oclMessageArguments_return retval = new OCLSyntaxParser.oclMessageArguments_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		CommonToken char_literal191 = default(CommonToken);
		OCLSyntaxParser.oclMessageArg_return oclMessageArg190 = default(OCLSyntaxParser.oclMessageArg_return);
		OCLSyntaxParser.oclMessageArguments_return oclMessageArguments192 = default(OCLSyntaxParser.oclMessageArguments_return);

		object char_literal191_tree = default(object);

		try { DebugEnterRule(GrammarFileName, "oclMessageArguments");
		DebugLocation(323, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:324:2: ( oclMessageArg ( ',' oclMessageArguments )? )
			DebugEnterAlt(1);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:324:4: oclMessageArg ( ',' oclMessageArguments )?
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(324, 4);
			PushFollow(Follow._oclMessageArg_in_oclMessageArguments2023);
			oclMessageArg190=oclMessageArg();
			PopFollow();

			adaptor.AddChild(root_0, oclMessageArg190.Tree);
			DebugLocation(324, 18);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:324:18: ( ',' oclMessageArguments )?
			int alt68=2;
			try { DebugEnterSubRule(68);
			try { DebugEnterDecision(68, false);
			int LA68_0 = input.LA(1);

			if ((LA68_0==45))
			{
				alt68 = 1;
			}
			} finally { DebugExitDecision(68); }
			switch (alt68)
			{
			case 1:
				DebugEnterAlt(1);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:324:20: ',' oclMessageArguments
				{
				DebugLocation(324, 20);
				char_literal191=(CommonToken)Match(input,45,Follow._45_in_oclMessageArguments2027); 
				char_literal191_tree = (object)adaptor.Create(char_literal191);
				adaptor.AddChild(root_0, char_literal191_tree);

				DebugLocation(324, 24);
				PushFollow(Follow._oclMessageArguments_in_oclMessageArguments2029);
				oclMessageArguments192=oclMessageArguments();
				PopFollow();

				adaptor.AddChild(root_0, oclMessageArguments192.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(68); }


			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("oclMessageArguments", 54);
			LeaveRule("oclMessageArguments", 54);
			LeaveRule_oclMessageArguments();
		}
		DebugLocation(325, 1);
		} finally { DebugExitRule(GrammarFileName, "oclMessageArguments"); }
		return retval;

	}
	// $ANTLR end "oclMessageArguments"

	private sealed partial class oclMessageArg_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public oclMessageArg_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_oclMessageArg();
	partial void LeaveRule_oclMessageArg();

	// $ANTLR start "oclMessageArg"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:327:1: oclMessageArg : ( '?' ( ':' type )? | oclExpression );
	[GrammarRule("oclMessageArg")]
	private OCLSyntaxParser.oclMessageArg_return oclMessageArg()
	{
		EnterRule_oclMessageArg();
		EnterRule("oclMessageArg", 55);
		TraceIn("oclMessageArg", 55);
		OCLSyntaxParser.oclMessageArg_return retval = new OCLSyntaxParser.oclMessageArg_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		CommonToken char_literal193 = default(CommonToken);
		CommonToken char_literal194 = default(CommonToken);
		OCLSyntaxParser.type_return type195 = default(OCLSyntaxParser.type_return);
		OCLSyntaxParser.oclExpression_return oclExpression196 = default(OCLSyntaxParser.oclExpression_return);

		object char_literal193_tree = default(object);
		object char_literal194_tree = default(object);

		try { DebugEnterRule(GrammarFileName, "oclMessageArg");
		DebugLocation(327, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:328:2: ( '?' ( ':' type )? | oclExpression )
			int alt70=2;
			try { DebugEnterDecision(70, false);
			int LA70_0 = input.LA(1);

			if ((LA70_0==60))
			{
				alt70 = 1;
			}
			else if ((LA70_0==BooleanLiteralExp||(LA70_0>=IntegerLiteralExp && LA70_0<=InvalidLiteralExp)||LA70_0==NullLiteralExp||(LA70_0>=RealLiteralExp && LA70_0<=SimpleName)||LA70_0==StringLiteralExp||LA70_0==UnlimitedNaturalLiteralExp||LA70_0==42||LA70_0==46||(LA70_0>=62 && LA70_0<=76)||LA70_0==88||(LA70_0>=93 && LA70_0<=95)))
			{
				alt70 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 70, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(70); }
			switch (alt70)
			{
			case 1:
				DebugEnterAlt(1);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:328:4: '?' ( ':' type )?
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(328, 4);
				char_literal193=(CommonToken)Match(input,60,Follow._60_in_oclMessageArg2044); 
				char_literal193_tree = (object)adaptor.Create(char_literal193);
				adaptor.AddChild(root_0, char_literal193_tree);

				DebugLocation(328, 8);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:328:8: ( ':' type )?
				int alt69=2;
				try { DebugEnterSubRule(69);
				try { DebugEnterDecision(69, false);
				int LA69_0 = input.LA(1);

				if ((LA69_0==51))
				{
					alt69 = 1;
				}
				} finally { DebugExitDecision(69); }
				switch (alt69)
				{
				case 1:
					DebugEnterAlt(1);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:328:9: ':' type
					{
					DebugLocation(328, 9);
					char_literal194=(CommonToken)Match(input,51,Follow._51_in_oclMessageArg2047); 
					char_literal194_tree = (object)adaptor.Create(char_literal194);
					adaptor.AddChild(root_0, char_literal194_tree);

					DebugLocation(328, 13);
					PushFollow(Follow._type_in_oclMessageArg2049);
					type195=type();
					PopFollow();

					adaptor.AddChild(root_0, type195.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(69); }


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:329:4: oclExpression
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(329, 4);
				PushFollow(Follow._oclExpression_in_oclMessageArg2056);
				oclExpression196=oclExpression();
				PopFollow();

				adaptor.AddChild(root_0, oclExpression196.Tree);

				}
				break;

			}
			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("oclMessageArg", 55);
			LeaveRule("oclMessageArg", 55);
			LeaveRule_oclMessageArg();
		}
		DebugLocation(330, 1);
		} finally { DebugExitRule(GrammarFileName, "oclMessageArg"); }
		return retval;

	}
	// $ANTLR end "oclMessageArg"

	private sealed partial class ifExp_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public ifExp_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_ifExp();
	partial void LeaveRule_ifExp();

	// $ANTLR start "ifExp"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:332:1: ifExp : 'if' oclExpression 'then' oclExpression 'else' oclExpression 'endif' -> ^( 'if' ( oclExpression )+ ) ;
	[GrammarRule("ifExp")]
	private OCLSyntaxParser.ifExp_return ifExp()
	{
		EnterRule_ifExp();
		EnterRule("ifExp", 56);
		TraceIn("ifExp", 56);
		OCLSyntaxParser.ifExp_return retval = new OCLSyntaxParser.ifExp_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		CommonToken string_literal197 = default(CommonToken);
		CommonToken string_literal199 = default(CommonToken);
		CommonToken string_literal201 = default(CommonToken);
		CommonToken string_literal203 = default(CommonToken);
		OCLSyntaxParser.oclExpression_return oclExpression198 = default(OCLSyntaxParser.oclExpression_return);
		OCLSyntaxParser.oclExpression_return oclExpression200 = default(OCLSyntaxParser.oclExpression_return);
		OCLSyntaxParser.oclExpression_return oclExpression202 = default(OCLSyntaxParser.oclExpression_return);

		object string_literal197_tree = default(object);
		object string_literal199_tree = default(object);
		object string_literal201_tree = default(object);
		object string_literal203_tree = default(object);
		RewriteRuleITokenStream stream_88=new RewriteRuleITokenStream(adaptor,"token 88");
		RewriteRuleITokenStream stream_100=new RewriteRuleITokenStream(adaptor,"token 100");
		RewriteRuleITokenStream stream_86=new RewriteRuleITokenStream(adaptor,"token 86");
		RewriteRuleITokenStream stream_87=new RewriteRuleITokenStream(adaptor,"token 87");
		RewriteRuleSubtreeStream stream_oclExpression=new RewriteRuleSubtreeStream(adaptor,"rule oclExpression");
		try { DebugEnterRule(GrammarFileName, "ifExp");
		DebugLocation(332, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:333:2: ( 'if' oclExpression 'then' oclExpression 'else' oclExpression 'endif' -> ^( 'if' ( oclExpression )+ ) )
			DebugEnterAlt(1);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:333:4: 'if' oclExpression 'then' oclExpression 'else' oclExpression 'endif'
			{
			DebugLocation(333, 4);
			string_literal197=(CommonToken)Match(input,88,Follow._88_in_ifExp2068);  
			stream_88.Add(string_literal197);

			DebugLocation(333, 9);
			PushFollow(Follow._oclExpression_in_ifExp2070);
			oclExpression198=oclExpression();
			PopFollow();

			stream_oclExpression.Add(oclExpression198.Tree);
			DebugLocation(333, 23);
			string_literal199=(CommonToken)Match(input,100,Follow._100_in_ifExp2072);  
			stream_100.Add(string_literal199);

			DebugLocation(333, 30);
			PushFollow(Follow._oclExpression_in_ifExp2074);
			oclExpression200=oclExpression();
			PopFollow();

			stream_oclExpression.Add(oclExpression200.Tree);
			DebugLocation(333, 44);
			string_literal201=(CommonToken)Match(input,86,Follow._86_in_ifExp2076);  
			stream_86.Add(string_literal201);

			DebugLocation(333, 51);
			PushFollow(Follow._oclExpression_in_ifExp2078);
			oclExpression202=oclExpression();
			PopFollow();

			stream_oclExpression.Add(oclExpression202.Tree);
			DebugLocation(333, 65);
			string_literal203=(CommonToken)Match(input,87,Follow._87_in_ifExp2080);  
			stream_87.Add(string_literal203);



			{
			// AST REWRITE
			// elements: 88, oclExpression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 333:73: -> ^( 'if' ( oclExpression )+ )
			{
				DebugLocation(333, 76);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:333:76: ^( 'if' ( oclExpression )+ )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(333, 78);
				root_1 = (object)adaptor.BecomeRoot(stream_88.NextNode(), root_1);

				DebugLocation(333, 83);
				if (!(stream_oclExpression.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_oclExpression.HasNext )
				{
					DebugLocation(333, 83);
					adaptor.AddChild(root_1, stream_oclExpression.NextTree());

				}
				stream_oclExpression.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("ifExp", 56);
			LeaveRule("ifExp", 56);
			LeaveRule_ifExp();
		}
		DebugLocation(334, 1);
		} finally { DebugExitRule(GrammarFileName, "ifExp"); }
		return retval;

	}
	// $ANTLR end "ifExp"
	#endregion Rules


	#region DFA
	private DFA2 dfa2;
	private DFA36 dfa36;

	protected override void InitDFAs()
	{
		base.InitDFAs();
		dfa2 = new DFA2( this );
		dfa36 = new DFA36( this );
	}

	private class DFA2 : DFA
	{
		private const string DFA2_eotS =
			"\xA\xFFFF";
		private const string DFA2_eofS =
			"\x2\xFFFF\x1\x4\x3\xFFFF\x1\x4\x2\xFFFF\x1\x4";
		private const string DFA2_minS =
			"\x1\x53\x1\x20\x1\x2A\x1\x20\x2\xFFFF\x1\x2A\x1\x20\x1\xFFFF\x1\x2A";
		private const string DFA2_maxS =
			"\x1\x53\x1\x20\x1\x63\x1\x20\x2\xFFFF\x1\x63\x1\x20\x1\xFFFF\x1\x63";
		private const string DFA2_acceptS =
			"\x4\xFFFF\x1\x2\x1\x3\x2\xFFFF\x1\x1\x1\xFFFF";
		private const string DFA2_specialS =
			"\xA\xFFFF}>";
		private static readonly string[] DFA2_transitionS =
			{
				"\x1\x1",
				"\x1\x2",
				"\x1\x5\x8\xFFFF\x1\x4\x1\x3\x1E\xFFFF\x2\x4\x7\xFFFF\x1\x4\x6\xFFFF"+
				"\x1\x4",
				"\x1\x6",
				"",
				"",
				"\x1\x5\x8\xFFFF\x1\x8\x1\x7\x1E\xFFFF\x2\x4\x7\xFFFF\x1\x4\x6\xFFFF"+
				"\x1\x4",
				"\x1\x9",
				"",
				"\x1\x5\x8\xFFFF\x1\x8\x1\x7\x1E\xFFFF\x2\x4\x7\xFFFF\x1\x4\x6\xFFFF"+
				"\x1\x4"
			};

		private static readonly short[] DFA2_eot = DFA.UnpackEncodedString(DFA2_eotS);
		private static readonly short[] DFA2_eof = DFA.UnpackEncodedString(DFA2_eofS);
		private static readonly char[] DFA2_min = DFA.UnpackEncodedStringToUnsignedChars(DFA2_minS);
		private static readonly char[] DFA2_max = DFA.UnpackEncodedStringToUnsignedChars(DFA2_maxS);
		private static readonly short[] DFA2_accept = DFA.UnpackEncodedString(DFA2_acceptS);
		private static readonly short[] DFA2_special = DFA.UnpackEncodedString(DFA2_specialS);
		private static readonly short[][] DFA2_transition;

		static DFA2()
		{
			int numStates = DFA2_transitionS.Length;
			DFA2_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA2_transition[i] = DFA.UnpackEncodedString(DFA2_transitionS[i]);
			}
		}

		public DFA2( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 2;
			this.eot = DFA2_eot;
			this.eof = DFA2_eof;
			this.min = DFA2_min;
			this.max = DFA2_max;
			this.accept = DFA2_accept;
			this.special = DFA2_special;
			this.transition = DFA2_transition;
		}

		public override string Description { get { return "26:1: public contextDeclaration : ( propertyContextDecl | classifierContextDecl | operationContextDecl );"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA36 : DFA
	{
		private const string DFA36_eotS =
			"\xA\xFFFF";
		private const string DFA36_eofS =
			"\xA\xFFFF";
		private const string DFA36_minS =
			"\x1\x4\x1\xFFFF\x1\x2A\x7\xFFFF";
		private const string DFA36_maxS =
			"\x1\x5E\x1\xFFFF\x1\x66\x7\xFFFF";
		private const string DFA36_acceptS =
			"\x1\xFFFF\x1\x1\x1\xFFFF\x1\x3\x1\x4\x1\x5\x1\x6\x1\x7\x1\x8\x1\x2";
		private const string DFA36_specialS =
			"\xA\xFFFF}>";
		private static readonly string[] DFA36_transitionS =
			{
				"\x1\x3\xE\xFFFF\x2\x3\x6\xFFFF\x1\x3\x3\xFFFF\x1\x3\x1\x5\x1\xFFFF\x1"+
				"\x3\x3\xFFFF\x1\x3\x3\xFFFF\x1\x6\x13\xFFFF\x1\x1\x1\x4\x1\x1\x5\x4"+
				"\x1\x1\x1\x4\x2\x1\x1\x4\x1\x2\x1\x4\xB\xFFFF\x1\x7\x4\xFFFF\x1\x5\x1"+
				"\x8",
				"",
				"\x1\x4\x3B\xFFFF\x1\x9",
				"",
				"",
				"",
				"",
				"",
				"",
				""
			};

		private static readonly short[] DFA36_eot = DFA.UnpackEncodedString(DFA36_eotS);
		private static readonly short[] DFA36_eof = DFA.UnpackEncodedString(DFA36_eofS);
		private static readonly char[] DFA36_min = DFA.UnpackEncodedStringToUnsignedChars(DFA36_minS);
		private static readonly char[] DFA36_max = DFA.UnpackEncodedStringToUnsignedChars(DFA36_maxS);
		private static readonly short[] DFA36_accept = DFA.UnpackEncodedString(DFA36_acceptS);
		private static readonly short[] DFA36_special = DFA.UnpackEncodedString(DFA36_specialS);
		private static readonly short[][] DFA36_transition;

		static DFA36()
		{
			int numStates = DFA36_transitionS.Length;
			DFA36_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA36_transition[i] = DFA.UnpackEncodedString(DFA36_transitionS[i]);
			}
		}

		public DFA36( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 36;
			this.eot = DFA36_eot;
			this.eof = DFA36_eof;
			this.min = DFA36_min;
			this.max = DFA36_max;
			this.accept = DFA36_accept;
			this.special = DFA36_special;
			this.transition = DFA36_transition;
		}

		public override string Description { get { return "133:1: primaryExperession : ( collectionLiteralExpAndType -> ^( collectionLiteralExpAndType ) | tupleLiteralExp -> ^( tupleLiteralExp ) | primitiveLiteralExp -> ^( PRIMITIVELITERAL primitiveLiteralExp ) | enumAndType -> ^( TYPE enumAndType ) | propertyCall | '(' oclExpression ')' | ifExp | letExp );"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}


	#endregion DFA

	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _contextDeclaration_in_contextDeclarationList105 = new BitSet(new ulong[]{0x2UL,0x80000UL});
		public static readonly BitSet _propertyContextDecl_in_contextDeclaration119 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _classifierContextDecl_in_contextDeclaration123 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _operationContextDecl_in_contextDeclaration127 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _propertyContextHead_in_propertyContextDecl137 = new BitSet(new ulong[]{0x2UL,0x8200000UL});
		public static readonly BitSet _initOrDerValue_in_propertyContextDecl139 = new BitSet(new ulong[]{0x2UL,0x8200000UL});
		public static readonly BitSet _83_in_propertyContextHead150 = new BitSet(new ulong[]{0x100000000UL});
		public static readonly BitSet _SimpleName_in_propertyContextHead152 = new BitSet(new ulong[]{0x10000000000000UL});
		public static readonly BitSet _52_in_propertyContextHead154 = new BitSet(new ulong[]{0x100000000UL});
		public static readonly BitSet _pathName_in_propertyContextHead156 = new BitSet(new ulong[]{0x8000000000000UL});
		public static readonly BitSet _51_in_propertyContextHead158 = new BitSet(new ulong[]{0xC000000100000000UL,0x1FFFUL});
		public static readonly BitSet _type_in_propertyContextHead160 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _operationContextHead_in_operationContextDecl170 = new BitSet(new ulong[]{0x2UL,0x600040000UL});
		public static readonly BitSet _prePostOrBodyDecl_in_operationContextDecl172 = new BitSet(new ulong[]{0x2UL,0x600040000UL});
		public static readonly BitSet _83_in_operationContextHead183 = new BitSet(new ulong[]{0x100000000UL});
		public static readonly BitSet _operation_in_operationContextHead185 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _classifierContextHead_in_classifierContextDecl195 = new BitSet(new ulong[]{0x2UL,0x810100000UL});
		public static readonly BitSet _invOrDef_in_classifierContextDecl198 = new BitSet(new ulong[]{0x2UL,0x810100000UL});
		public static readonly BitSet _83_in_classifierContextHead211 = new BitSet(new ulong[]{0x100000000UL});
		public static readonly BitSet _pathName_in_classifierContextHead213 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _83_in_classifierContextHead219 = new BitSet(new ulong[]{0x100000000UL});
		public static readonly BitSet _SimpleName_in_classifierContextHead221 = new BitSet(new ulong[]{0x8000000000000UL});
		public static readonly BitSet _51_in_classifierContextHead222 = new BitSet(new ulong[]{0x100000000UL});
		public static readonly BitSet _pathName_in_classifierContextHead223 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _91_in_initOrDerValue234 = new BitSet(new ulong[]{0x8000000000000UL});
		public static readonly BitSet _51_in_initOrDerValue236 = new BitSet(new ulong[]{0xC000444588180010UL,0xE1001FFFUL});
		public static readonly BitSet _oclExpression_in_initOrDerValue238 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _85_in_initOrDerValue243 = new BitSet(new ulong[]{0x8000000000000UL});
		public static readonly BitSet _51_in_initOrDerValue245 = new BitSet(new ulong[]{0xC000444588180010UL,0xE1001FFFUL});
		public static readonly BitSet _oclExpression_in_initOrDerValue247 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _92_in_invOrDef258 = new BitSet(new ulong[]{0x8000100000000UL});
		public static readonly BitSet _SimpleName_in_invOrDef261 = new BitSet(new ulong[]{0x8000000000000UL});
		public static readonly BitSet _51_in_invOrDef266 = new BitSet(new ulong[]{0xC000444588180010UL,0xE1001FFFUL});
		public static readonly BitSet _oclExpression_in_invOrDef268 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _99_in_invOrDef274 = new BitSet(new ulong[]{0x0UL,0x100000UL});
		public static readonly BitSet _84_in_invOrDef277 = new BitSet(new ulong[]{0x8000100000000UL});
		public static readonly BitSet _SimpleName_in_invOrDef279 = new BitSet(new ulong[]{0x8000000000000UL});
		public static readonly BitSet _51_in_invOrDef282 = new BitSet(new ulong[]{0x100000000UL});
		public static readonly BitSet _defExpression_in_invOrDef284 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _98_in_prePostOrBodyDecl294 = new BitSet(new ulong[]{0x8000100000000UL});
		public static readonly BitSet _SimpleName_in_prePostOrBodyDecl297 = new BitSet(new ulong[]{0x8000000000000UL});
		public static readonly BitSet _51_in_prePostOrBodyDecl301 = new BitSet(new ulong[]{0xC000444588180010UL,0xE1001FFFUL});
		public static readonly BitSet _oclExpression_in_prePostOrBodyDecl303 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _97_in_prePostOrBodyDecl308 = new BitSet(new ulong[]{0x8000100000000UL});
		public static readonly BitSet _SimpleName_in_prePostOrBodyDecl311 = new BitSet(new ulong[]{0x8000000000000UL});
		public static readonly BitSet _51_in_prePostOrBodyDecl315 = new BitSet(new ulong[]{0xC000444588180010UL,0xE1001FFFUL});
		public static readonly BitSet _oclExpression_in_prePostOrBodyDecl317 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _82_in_prePostOrBodyDecl322 = new BitSet(new ulong[]{0x8000100000000UL});
		public static readonly BitSet _SimpleName_in_prePostOrBodyDecl325 = new BitSet(new ulong[]{0x8000000000000UL});
		public static readonly BitSet _51_in_prePostOrBodyDecl329 = new BitSet(new ulong[]{0xC000444588180010UL,0xE1001FFFUL});
		public static readonly BitSet _oclExpression_in_prePostOrBodyDecl331 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _pathName_in_operation342 = new BitSet(new ulong[]{0x40000000000UL});
		public static readonly BitSet _42_in_operation346 = new BitSet(new ulong[]{0x80100000000UL});
		public static readonly BitSet _parameters_in_operation348 = new BitSet(new ulong[]{0x80000000000UL});
		public static readonly BitSet _43_in_operation351 = new BitSet(new ulong[]{0x8000000000002UL});
		public static readonly BitSet _51_in_operation354 = new BitSet(new ulong[]{0xC000000100000000UL,0x1FFFUL});
		public static readonly BitSet _type_in_operation356 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _variableDeclaration_in_parameters368 = new BitSet(new ulong[]{0x200000000002UL});
		public static readonly BitSet _45_in_parameters371 = new BitSet(new ulong[]{0x100000000UL});
		public static readonly BitSet _parameters_in_parameters373 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _variableDeclaration_in_defExpression386 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _operation_in_defExpression391 = new BitSet(new ulong[]{0x200000000000000UL});
		public static readonly BitSet _57_in_defExpression393 = new BitSet(new ulong[]{0xC000444588180010UL,0xE1001FFFUL});
		public static readonly BitSet _oclExpression_in_defExpression395 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _logicalImpliesExpression_in_oclExpression408 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _logicalXorExpression_in_logicalImpliesExpression424 = new BitSet(new ulong[]{0x2UL,0x2000000UL});
		public static readonly BitSet _89_in_logicalImpliesExpression433 = new BitSet(new ulong[]{0xC000444588180010UL,0xE1001FFFUL});
		public static readonly BitSet _logicalXorExpression_in_logicalImpliesExpression437 = new BitSet(new ulong[]{0x2UL,0x2000000UL});
		public static readonly BitSet _logicalOrExpression_in_logicalXorExpression464 = new BitSet(new ulong[]{0x2UL,0x2000000000UL});
		public static readonly BitSet _101_in_logicalXorExpression472 = new BitSet(new ulong[]{0xC000444588180010UL,0xE1001FFFUL});
		public static readonly BitSet _logicalOrExpression_in_logicalXorExpression476 = new BitSet(new ulong[]{0x2UL,0x2000000000UL});
		public static readonly BitSet _logicalAndExpression_in_logicalOrExpression502 = new BitSet(new ulong[]{0x2UL,0x100000000UL});
		public static readonly BitSet _96_in_logicalOrExpression510 = new BitSet(new ulong[]{0xC000444588180010UL,0xE1001FFFUL});
		public static readonly BitSet _logicalAndExpression_in_logicalOrExpression514 = new BitSet(new ulong[]{0x2UL,0x100000000UL});
		public static readonly BitSet _relationalEqExpression_in_logicalAndExpression540 = new BitSet(new ulong[]{0x2UL,0x20000UL});
		public static readonly BitSet _81_in_logicalAndExpression549 = new BitSet(new ulong[]{0xC000444588180010UL,0xE1001FFFUL});
		public static readonly BitSet _relationalEqExpression_in_logicalAndExpression553 = new BitSet(new ulong[]{0x2UL,0x20000UL});
		public static readonly BitSet _relationalNotEqExprassion_in_relationalEqExpression580 = new BitSet(new ulong[]{0x300000000000002UL});
		public static readonly BitSet _57_in_relationalEqExpression589 = new BitSet(new ulong[]{0xC000444588180010UL,0xE1001FFFUL});
		public static readonly BitSet _56_in_relationalEqExpression593 = new BitSet(new ulong[]{0xC000444588180010UL,0xE1001FFFUL});
		public static readonly BitSet _relationalNotEqExprassion_in_relationalEqExpression598 = new BitSet(new ulong[]{0x300000000000002UL});
		public static readonly BitSet _additiveExpression_in_relationalNotEqExprassion627 = new BitSet(new ulong[]{0xCC0000000000002UL});
		public static readonly BitSet _54_in_relationalNotEqExprassion637 = new BitSet(new ulong[]{0xC000444588180010UL,0xE1001FFFUL});
		public static readonly BitSet _58_in_relationalNotEqExprassion642 = new BitSet(new ulong[]{0xC000444588180010UL,0xE1001FFFUL});
		public static readonly BitSet _55_in_relationalNotEqExprassion647 = new BitSet(new ulong[]{0xC000444588180010UL,0xE1001FFFUL});
		public static readonly BitSet _59_in_relationalNotEqExprassion652 = new BitSet(new ulong[]{0xC000444588180010UL,0xE1001FFFUL});
		public static readonly BitSet _additiveExpression_in_relationalNotEqExprassion657 = new BitSet(new ulong[]{0xCC0000000000002UL});
		public static readonly BitSet _multiplicativeExpression_in_additiveExpression685 = new BitSet(new ulong[]{0x500000000002UL});
		public static readonly BitSet _44_in_additiveExpression694 = new BitSet(new ulong[]{0xC000444588180010UL,0xE1001FFFUL});
		public static readonly BitSet _46_in_additiveExpression698 = new BitSet(new ulong[]{0xC000444588180010UL,0xE1001FFFUL});
		public static readonly BitSet _multiplicativeExpression_in_additiveExpression704 = new BitSet(new ulong[]{0x500000000002UL});
		public static readonly BitSet _unaryExpression_in_multiplicativeExpression733 = new BitSet(new ulong[]{0x4004000000002UL});
		public static readonly BitSet _UnlimitedNaturalLiteralExp_in_multiplicativeExpression742 = new BitSet(new ulong[]{0xC000444588180010UL,0xE1001FFFUL});
		public static readonly BitSet _50_in_multiplicativeExpression746 = new BitSet(new ulong[]{0xC000444588180010UL,0xE1001FFFUL});
		public static readonly BitSet _unaryExpression_in_multiplicativeExpression751 = new BitSet(new ulong[]{0x4004000000002UL});
		public static readonly BitSet _46_in_unaryExpression781 = new BitSet(new ulong[]{0xC000444588180010UL,0xE1001FFFUL});
		public static readonly BitSet _95_in_unaryExpression785 = new BitSet(new ulong[]{0xC000444588180010UL,0xE1001FFFUL});
		public static readonly BitSet _termExpression_in_unaryExpression790 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _termExpression_in_unaryExpression806 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _primaryExperession_in_termExpression820 = new BitSet(new ulong[]{0x1800000000002UL,0x18000UL});
		public static readonly BitSet _48_in_termExpression831 = new BitSet(new ulong[]{0x100000000UL,0x20000000UL});
		public static readonly BitSet _47_in_termExpression835 = new BitSet(new ulong[]{0x100000000UL,0x20000000UL});
		public static readonly BitSet _propertyCall_in_termExpression840 = new BitSet(new ulong[]{0x1800000000002UL,0x18000UL});
		public static readonly BitSet _oclMessageExp_in_termExpression862 = new BitSet(new ulong[]{0x1800000000002UL,0x18000UL});
		public static readonly BitSet _collectionLiteralExpAndType_in_primaryExperession904 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _tupleLiteralExp_in_primaryExperession919 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _primitiveLiteralExp_in_primaryExperession934 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _enumAndType_in_primaryExperession952 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _propertyCall_in_primaryExperession968 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _42_in_primaryExperession973 = new BitSet(new ulong[]{0xC000444588180010UL,0xE1001FFFUL});
		public static readonly BitSet _oclExpression_in_primaryExperession975 = new BitSet(new ulong[]{0x80000000000UL});
		public static readonly BitSet _43_in_primaryExperession976 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ifExp_in_primaryExperession982 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _letExp_in_primaryExperession987 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _pathName_in_propertyCall997 = new BitSet(new ulong[]{0x2000040000000002UL,0x2000UL});
		public static readonly BitSet _77_in_propertyCall1000 = new BitSet(new ulong[]{0xC000444588180010UL,0xE1001FFFUL});
		public static readonly BitSet _arguments_in_propertyCall1001 = new BitSet(new ulong[]{0x0UL,0x4000UL});
		public static readonly BitSet _78_in_propertyCall1002 = new BitSet(new ulong[]{0x2000040000000002UL});
		public static readonly BitSet _isMarkedPre_in_propertyCall1006 = new BitSet(new ulong[]{0x40000000002UL});
		public static readonly BitSet _42_in_propertyCall1010 = new BitSet(new ulong[]{0xC0004C4588180010UL,0xE1001FFFUL});
		public static readonly BitSet _propertyCallParametrs_in_propertyCall1011 = new BitSet(new ulong[]{0x80000000000UL});
		public static readonly BitSet _43_in_propertyCall1012 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _93_in_propertyCall1051 = new BitSet(new ulong[]{0x40000000000UL});
		public static readonly BitSet _42_in_propertyCall1053 = new BitSet(new ulong[]{0x100000000UL});
		public static readonly BitSet _variableDeclaration_in_propertyCall1055 = new BitSet(new ulong[]{0x20000100000000UL,0x8000000000UL});
		public static readonly BitSet _53_in_propertyCall1057 = new BitSet(new ulong[]{0x100000000UL,0x8000000000UL});
		public static readonly BitSet _103_in_propertyCall1062 = new BitSet(new ulong[]{0xC000444588180010UL,0xE1001FFFUL});
		public static readonly BitSet _oclExpression_in_propertyCall1064 = new BitSet(new ulong[]{0x80000000000UL});
		public static readonly BitSet _43_in_propertyCall1066 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _declarePropertyCallParametrs_in_propertyCallParametrs1106 = new BitSet(new ulong[]{0xC000444588180012UL,0xE1001FFFUL});
		public static readonly BitSet _arguments_in_propertyCallParametrs1110 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _typedef_in_declarePropertyCallParametrs1141 = new BitSet(new ulong[]{0x200000000000UL,0x8000000000UL});
		public static readonly BitSet _45_in_declarePropertyCallParametrs1144 = new BitSet(new ulong[]{0x100000000UL});
		public static readonly BitSet _typedef_in_declarePropertyCallParametrs1148 = new BitSet(new ulong[]{0x0UL,0x8000000000UL});
		public static readonly BitSet _103_in_declarePropertyCallParametrs1152 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SimpleName_in_typedef1180 = new BitSet(new ulong[]{0x8000000000002UL});
		public static readonly BitSet _51_in_typedef1182 = new BitSet(new ulong[]{0xC000000100000000UL,0x1FFFUL});
		public static readonly BitSet _type_in_typedef1183 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _tupleType_in_enumAndType1220 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _primitiveType_in_enumAndType1228 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _oclType_in_enumAndType1233 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SimpleName_in_pathName1250 = new BitSet(new ulong[]{0x10000000000002UL});
		public static readonly BitSet _52_in_pathName1253 = new BitSet(new ulong[]{0x100000000UL});
		public static readonly BitSet _SimpleName_in_pathName1255 = new BitSet(new ulong[]{0x10000000000002UL});
		public static readonly BitSet _collectionTypeIdentifier_in_collectionLiteralExpAndType1284 = new BitSet(new ulong[]{0x2UL,0x4000000000UL});
		public static readonly BitSet _102_in_collectionLiteralExpAndType1287 = new BitSet(new ulong[]{0xC000444588180010UL,0x100E1001FFFUL});
		public static readonly BitSet _collectionLiteralParts_in_collectionLiteralExpAndType1289 = new BitSet(new ulong[]{0x0UL,0x10000000000UL});
		public static readonly BitSet _104_in_collectionLiteralExpAndType1292 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _collectionTypeIdentifier_in_collectionLiteralExpAndType1313 = new BitSet(new ulong[]{0x40000000000UL});
		public static readonly BitSet _42_in_collectionLiteralExpAndType1316 = new BitSet(new ulong[]{0xC000000100000000UL,0x1FFFUL});
		public static readonly BitSet _type_in_collectionLiteralExpAndType1318 = new BitSet(new ulong[]{0x80000000000UL});
		public static readonly BitSet _43_in_collectionLiteralExpAndType1321 = new BitSet(new ulong[]{0x2UL,0x4000000000UL});
		public static readonly BitSet _102_in_collectionLiteralExpAndType1331 = new BitSet(new ulong[]{0xC000444588180010UL,0xE1001FFFUL});
		public static readonly BitSet _collectionLiteralParts_in_collectionLiteralExpAndType1333 = new BitSet(new ulong[]{0x0UL,0x10000000000UL});
		public static readonly BitSet _104_in_collectionLiteralExpAndType1335 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _pathName_in_enumLiteralExp1382 = new BitSet(new ulong[]{0x10000000000000UL});
		public static readonly BitSet _52_in_enumLiteralExp1383 = new BitSet(new ulong[]{0x100000000UL});
		public static readonly BitSet _SimpleName_in_enumLiteralExp1385 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _collectionTypeIdentifier_in_collectionLiteralExp1397 = new BitSet(new ulong[]{0x0UL,0x4000000000UL});
		public static readonly BitSet _102_in_collectionLiteralExp1400 = new BitSet(new ulong[]{0xC000444588180010UL,0x100E1001FFFUL});
		public static readonly BitSet _collectionLiteralParts_in_collectionLiteralExp1402 = new BitSet(new ulong[]{0x0UL,0x10000000000UL});
		public static readonly BitSet _104_in_collectionLiteralExp1405 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _collectionType_in_collectionLiteralExp1409 = new BitSet(new ulong[]{0x0UL,0x4000000000UL});
		public static readonly BitSet _102_in_collectionLiteralExp1411 = new BitSet(new ulong[]{0xC000444588180010UL,0x100E1001FFFUL});
		public static readonly BitSet _collectionLiteralParts_in_collectionLiteralExp1413 = new BitSet(new ulong[]{0x0UL,0x10000000000UL});
		public static readonly BitSet _104_in_collectionLiteralExp1416 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _set_in_collectionTypeIdentifier1432 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _collectionLiteralPart_in_collectionLiteralParts1463 = new BitSet(new ulong[]{0x200000000002UL});
		public static readonly BitSet _45_in_collectionLiteralParts1467 = new BitSet(new ulong[]{0xC000444588180010UL,0xE1001FFFUL});
		public static readonly BitSet _collectionLiteralPart_in_collectionLiteralParts1470 = new BitSet(new ulong[]{0x200000000002UL});
		public static readonly BitSet _oclExpression_in_collectionLiteralPart1487 = new BitSet(new ulong[]{0x2000000000002UL});
		public static readonly BitSet _49_in_collectionLiteralPart1491 = new BitSet(new ulong[]{0xC000444588180010UL,0xE1001FFFUL});
		public static readonly BitSet _oclExpression_in_collectionLiteralPart1495 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _set_in_primitiveLiteralExp1527 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _75_in_tupleLiteralExp1580 = new BitSet(new ulong[]{0x0UL,0x4000000000UL});
		public static readonly BitSet _102_in_tupleLiteralExp1582 = new BitSet(new ulong[]{0x100000000UL});
		public static readonly BitSet _variableDeclarationList_in_tupleLiteralExp1584 = new BitSet(new ulong[]{0x0UL,0x10000000000UL});
		public static readonly BitSet _104_in_tupleLiteralExp1586 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _type_in_typeLiteralExp1610 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SimpleName_in_variableDeclaration1620 = new BitSet(new ulong[]{0x208000000000002UL});
		public static readonly BitSet _51_in_variableDeclaration1623 = new BitSet(new ulong[]{0xC000000100000000UL,0x1FFFUL});
		public static readonly BitSet _type_in_variableDeclaration1625 = new BitSet(new ulong[]{0x200000000000002UL});
		public static readonly BitSet _57_in_variableDeclaration1631 = new BitSet(new ulong[]{0xC000444588180010UL,0xE1001FFFUL});
		public static readonly BitSet _oclExpression_in_variableDeclaration1633 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _pathName_in_type1662 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _collectionType_in_type1670 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _tupleType_in_type1676 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _primitiveType_in_type1683 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _oclType_in_type1690 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _set_in_primitiveType1704 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _set_in_oclType1754 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _collectionTypeIdentifier_in_collectionType1796 = new BitSet(new ulong[]{0x40000000000UL});
		public static readonly BitSet _42_in_collectionType1798 = new BitSet(new ulong[]{0xC000000100000000UL,0x1FFFUL});
		public static readonly BitSet _type_in_collectionType1800 = new BitSet(new ulong[]{0x80000000000UL});
		public static readonly BitSet _43_in_collectionType1803 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _75_in_tupleType1826 = new BitSet(new ulong[]{0x40000000000UL});
		public static readonly BitSet _42_in_tupleType1829 = new BitSet(new ulong[]{0x80100000000UL});
		public static readonly BitSet _variableDeclarationList_in_tupleType1832 = new BitSet(new ulong[]{0x80000000000UL});
		public static readonly BitSet _43_in_tupleType1835 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _variableDeclaration_in_variableDeclarationList1850 = new BitSet(new ulong[]{0x200000000002UL});
		public static readonly BitSet _45_in_variableDeclarationList1853 = new BitSet(new ulong[]{0x100000000UL});
		public static readonly BitSet _variableDeclaration_in_variableDeclarationList1856 = new BitSet(new ulong[]{0x200000000002UL});
		public static readonly BitSet _61_in_isMarkedPre1871 = new BitSet(new ulong[]{0x0UL,0x400000000UL});
		public static readonly BitSet _98_in_isMarkedPre1874 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _oclExpression_in_arguments1892 = new BitSet(new ulong[]{0x200000000002UL});
		public static readonly BitSet _45_in_arguments1897 = new BitSet(new ulong[]{0xC000444588180010UL,0xE1001FFFUL});
		public static readonly BitSet _oclExpression_in_arguments1902 = new BitSet(new ulong[]{0x200000000002UL});
		public static readonly BitSet _94_in_letExp1918 = new BitSet(new ulong[]{0x100000000UL});
		public static readonly BitSet _variableDeclaration_in_letExp1920 = new BitSet(new ulong[]{0x200000000000UL,0x4000000UL});
		public static readonly BitSet _letExpSub_in_letExp1922 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _45_in_letExpSub1944 = new BitSet(new ulong[]{0x100000000UL});
		public static readonly BitSet _variableDeclaration_in_letExpSub1946 = new BitSet(new ulong[]{0x200000000000UL,0x4000000UL});
		public static readonly BitSet _letExpSub_in_letExpSub1948 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _90_in_letExpSub1963 = new BitSet(new ulong[]{0xC000444588180010UL,0xE1001FFFUL});
		public static readonly BitSet _oclExpression_in_letExpSub1974 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _80_in_oclMessageExp1990 = new BitSet(new ulong[]{0x100000000UL});
		public static readonly BitSet _SimpleName_in_oclMessageExp1992 = new BitSet(new ulong[]{0x40000000000UL});
		public static readonly BitSet _42_in_oclMessageExp1994 = new BitSet(new ulong[]{0xD0004C4588180010UL,0xE1001FFFUL});
		public static readonly BitSet _oclMessageArguments_in_oclMessageExp1996 = new BitSet(new ulong[]{0x80000000000UL});
		public static readonly BitSet _43_in_oclMessageExp1999 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _79_in_oclMessageExp2004 = new BitSet(new ulong[]{0x100000000UL});
		public static readonly BitSet _SimpleName_in_oclMessageExp2006 = new BitSet(new ulong[]{0x40000000000UL});
		public static readonly BitSet _42_in_oclMessageExp2008 = new BitSet(new ulong[]{0xD0004C4588180010UL,0xE1001FFFUL});
		public static readonly BitSet _oclMessageArguments_in_oclMessageExp2010 = new BitSet(new ulong[]{0x80000000000UL});
		public static readonly BitSet _43_in_oclMessageExp2013 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _oclMessageArg_in_oclMessageArguments2023 = new BitSet(new ulong[]{0x200000000002UL});
		public static readonly BitSet _45_in_oclMessageArguments2027 = new BitSet(new ulong[]{0xD000444588180010UL,0xE1001FFFUL});
		public static readonly BitSet _oclMessageArguments_in_oclMessageArguments2029 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _60_in_oclMessageArg2044 = new BitSet(new ulong[]{0x8000000000002UL});
		public static readonly BitSet _51_in_oclMessageArg2047 = new BitSet(new ulong[]{0xC000000100000000UL,0x1FFFUL});
		public static readonly BitSet _type_in_oclMessageArg2049 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _oclExpression_in_oclMessageArg2056 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _88_in_ifExp2068 = new BitSet(new ulong[]{0xC000444588180010UL,0xE1001FFFUL});
		public static readonly BitSet _oclExpression_in_ifExp2070 = new BitSet(new ulong[]{0x0UL,0x1000000000UL});
		public static readonly BitSet _100_in_ifExp2072 = new BitSet(new ulong[]{0xC000444588180010UL,0xE1001FFFUL});
		public static readonly BitSet _oclExpression_in_ifExp2074 = new BitSet(new ulong[]{0x0UL,0x400000UL});
		public static readonly BitSet _86_in_ifExp2076 = new BitSet(new ulong[]{0xC000444588180010UL,0xE1001FFFUL});
		public static readonly BitSet _oclExpression_in_ifExp2078 = new BitSet(new ulong[]{0x0UL,0x800000UL});
		public static readonly BitSet _87_in_ifExp2080 = new BitSet(new ulong[]{0x2UL});

	}
	#endregion Follow sets
}

} // namespace Exolutio.Model.OCL.Compiler

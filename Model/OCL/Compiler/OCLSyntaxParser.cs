//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.3.1.7705
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.3.1.7705 ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3 2012-06-12 18:28:24

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162


using System.Collections.Generic;
using Antlr.Runtime;


using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;

namespace Exolutio.Model.OCL.Compiler
{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.3.1.7705")]
[System.CLSCompliant(false)]
public partial class OCLSyntaxParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ACC", "ARGS", "BODY", "CALL", "CALLARGS", "CLASSIFIERCONDITION", "CLASSIFIERHEAD", "CLASSLITERAL", "COLLECTIONLITERAL", "COLLECTIONTYPE", "COLLPART", "COLLPARTRANGE", "COLLTYPE", "CONDITION", "Char", "DECL", "DEF", "DERIVATE", "DoubleDot", "EVOLUTIONHEAD", "EscapeSequence", "ExponentPart", "Hex", "IF", "INDEX", "INFIX", "INIT", "INV", "ITERATE", "IntegerLiteralExp", "InvalidLiteralExp", "LET", "LINE_COMMENT", "MESSAGE", "NESTED_ML_COMMENT", "NameChar", "NameStartChar", "NullLiteralExp", "Num", "OPERATION", "OPERATIONCONDITION", "OPERATIONHEAD", "PATH", "POST", "PRE", "PRIMITIVELITERAL", "PROPERTYCONDITION", "PROPERTYHEAD", "RealLiteralExp", "SimpleName", "StringChar", "StringLiteralExp", "TUPLELITERAL", "TYPE", "UNARY", "UnlimitedNaturalLiteralExp", "VARDECL", "WS", "WhiteSpaceChar", "'('", "')'", "'+'", "','", "'-'", "'->'", "'.'", "'/'", "':'", "'::'", "';'", "'<'", "'<='", "'<>'", "'='", "'>'", "'>='", "'?'", "'@'", "'Bag'", "'Boolean'", "'Collection'", "'Integer'", "'OclAny'", "'OclInvalid'", "'OclMessage'", "'OclVoid'", "'OrderedSet'", "'Real'", "'Sequence'", "'Set'", "'String'", "'Tuple'", "'UnlimitedNatural'", "'['", "']'", "'^'", "'^^'", "'and'", "'body'", "'context'", "'def'", "'derive'", "'else'", "'endif'", "'false'", "'if'", "'implies'", "'in'", "'init'", "'inv'", "'iterate'", "'let'", "'message'", "'new'", "'not'", "'or'", "'post'", "'pre'", "'source version'", "'static'", "'then'", "'true'", "'xor'", "'{'", "'|'", "'}'"
	};
	public const int EOF=-1;
	public const int ACC=4;
	public const int ARGS=5;
	public const int BODY=6;
	public const int CALL=7;
	public const int CALLARGS=8;
	public const int CLASSIFIERCONDITION=9;
	public const int CLASSIFIERHEAD=10;
	public const int CLASSLITERAL=11;
	public const int COLLECTIONLITERAL=12;
	public const int COLLECTIONTYPE=13;
	public const int COLLPART=14;
	public const int COLLPARTRANGE=15;
	public const int COLLTYPE=16;
	public const int CONDITION=17;
	public const int Char=18;
	public const int DECL=19;
	public const int DEF=20;
	public const int DERIVATE=21;
	public const int DoubleDot=22;
	public const int EVOLUTIONHEAD=23;
	public const int EscapeSequence=24;
	public const int ExponentPart=25;
	public const int Hex=26;
	public const int IF=27;
	public const int INDEX=28;
	public const int INFIX=29;
	public const int INIT=30;
	public const int INV=31;
	public const int ITERATE=32;
	public const int IntegerLiteralExp=33;
	public const int InvalidLiteralExp=34;
	public const int LET=35;
	public const int LINE_COMMENT=36;
	public const int MESSAGE=37;
	public const int NESTED_ML_COMMENT=38;
	public const int NameChar=39;
	public const int NameStartChar=40;
	public const int NullLiteralExp=41;
	public const int Num=42;
	public const int OPERATION=43;
	public const int OPERATIONCONDITION=44;
	public const int OPERATIONHEAD=45;
	public const int PATH=46;
	public const int POST=47;
	public const int PRE=48;
	public const int PRIMITIVELITERAL=49;
	public const int PROPERTYCONDITION=50;
	public const int PROPERTYHEAD=51;
	public const int RealLiteralExp=52;
	public const int SimpleName=53;
	public const int StringChar=54;
	public const int StringLiteralExp=55;
	public const int TUPLELITERAL=56;
	public const int TYPE=57;
	public const int UNARY=58;
	public const int UnlimitedNaturalLiteralExp=59;
	public const int VARDECL=60;
	public const int WS=61;
	public const int WhiteSpaceChar=62;
	public const int T__63=63;
	public const int T__64=64;
	public const int T__65=65;
	public const int T__66=66;
	public const int T__67=67;
	public const int T__68=68;
	public const int T__69=69;
	public const int T__70=70;
	public const int T__71=71;
	public const int T__72=72;
	public const int T__73=73;
	public const int T__74=74;
	public const int T__75=75;
	public const int T__76=76;
	public const int T__77=77;
	public const int T__78=78;
	public const int T__79=79;
	public const int T__80=80;
	public const int T__81=81;
	public const int T__82=82;
	public const int T__83=83;
	public const int T__84=84;
	public const int T__85=85;
	public const int T__86=86;
	public const int T__87=87;
	public const int T__88=88;
	public const int T__89=89;
	public const int T__90=90;
	public const int T__91=91;
	public const int T__92=92;
	public const int T__93=93;
	public const int T__94=94;
	public const int T__95=95;
	public const int T__96=96;
	public const int T__97=97;
	public const int T__98=98;
	public const int T__99=99;
	public const int T__100=100;
	public const int T__101=101;
	public const int T__102=102;
	public const int T__103=103;
	public const int T__104=104;
	public const int T__105=105;
	public const int T__106=106;
	public const int T__107=107;
	public const int T__108=108;
	public const int T__109=109;
	public const int T__110=110;
	public const int T__111=111;
	public const int T__112=112;
	public const int T__113=113;
	public const int T__114=114;
	public const int T__115=115;
	public const int T__116=116;
	public const int T__117=117;
	public const int T__118=118;
	public const int T__119=119;
	public const int T__120=120;
	public const int T__121=121;
	public const int T__122=122;
	public const int T__123=123;
	public const int T__124=124;
	public const int T__125=125;
	public const int T__126=126;
	public const int T__127=127;
	public const int T__128=128;
	public const int T__129=129;

	// delegates
	// delegators

	public OCLSyntaxParser( ITokenStream input )
		: this( input, new RecognizerSharedState() )
	{
	}
	public OCLSyntaxParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		ITreeAdaptor treeAdaptor = default(ITreeAdaptor);
		CreateTreeAdaptor(ref treeAdaptor);

		TreeAdaptor = treeAdaptor ?? new CommonTreeAdaptor();


		OnCreated();
	}
		
	// Implement this function in your helper file to use a custom tree adaptor
	partial void CreateTreeAdaptor(ref ITreeAdaptor adaptor);

	private ITreeAdaptor adaptor;

	public ITreeAdaptor TreeAdaptor
	{
		get
		{
			return adaptor;
		}

		set
		{
			this.adaptor = value;
		}
	}

	public override string[] TokenNames { get { return OCLSyntaxParser.tokenNames; } }
	public override string GrammarFileName { get { return "..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	public sealed partial class evolutionDeclarationList_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public evolutionDeclarationList_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_evolutionDeclarationList();
	partial void LeaveRule_evolutionDeclarationList();

	// $ANTLR start "evolutionDeclarationList"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:24:1: public evolutionDeclarationList : 'source version' SimpleName ( contextDeclarationE )* EOF -> ^( EVOLUTIONHEAD SimpleName ( contextDeclarationE )* ) ;
	[GrammarRule("evolutionDeclarationList")]
	public OCLSyntaxParser.evolutionDeclarationList_return evolutionDeclarationList()
	{
		EnterRule_evolutionDeclarationList();
		EnterRule("evolutionDeclarationList", 1);
		TraceIn("evolutionDeclarationList", 1);
		OCLSyntaxParser.evolutionDeclarationList_return retval = new OCLSyntaxParser.evolutionDeclarationList_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		CommonToken string_literal1 = default(CommonToken);
		CommonToken SimpleName2 = default(CommonToken);
		CommonToken EOF4 = default(CommonToken);
		OCLSyntaxParser.contextDeclarationE_return contextDeclarationE3 = default(OCLSyntaxParser.contextDeclarationE_return);

		object string_literal1_tree = default(object);
		object SimpleName2_tree = default(object);
		object EOF4_tree = default(object);
		RewriteRuleITokenStream stream_122=new RewriteRuleITokenStream(adaptor,"token 122");
		RewriteRuleITokenStream stream_SimpleName=new RewriteRuleITokenStream(adaptor,"token SimpleName");
		RewriteRuleITokenStream stream_EOF=new RewriteRuleITokenStream(adaptor,"token EOF");
		RewriteRuleSubtreeStream stream_contextDeclarationE=new RewriteRuleSubtreeStream(adaptor,"rule contextDeclarationE");
		try { DebugEnterRule(GrammarFileName, "evolutionDeclarationList");
		DebugLocation(24, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:25:2: ( 'source version' SimpleName ( contextDeclarationE )* EOF -> ^( EVOLUTIONHEAD SimpleName ( contextDeclarationE )* ) )
			DebugEnterAlt(1);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:25:3: 'source version' SimpleName ( contextDeclarationE )* EOF
			{
			DebugLocation(25, 3);
			string_literal1=(CommonToken)Match(input,122,Follow._122_in_evolutionDeclarationList175); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_122.Add(string_literal1);

			DebugLocation(25, 20);
			SimpleName2=(CommonToken)Match(input,SimpleName,Follow._SimpleName_in_evolutionDeclarationList177); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_SimpleName.Add(SimpleName2);

			DebugLocation(25, 31);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:25:31: ( contextDeclarationE )*
			try { DebugEnterSubRule(1);
			while (true)
			{
				int alt1=2;
				try { DebugEnterDecision(1, false);
				int LA1_0 = input.LA(1);

				if ((LA1_0==103))
				{
					alt1 = 1;
				}


				} finally { DebugExitDecision(1); }
				switch ( alt1 )
				{
				case 1:
					DebugEnterAlt(1);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:25:31: contextDeclarationE
					{
					DebugLocation(25, 31);
					PushFollow(Follow._contextDeclarationE_in_evolutionDeclarationList179);
					contextDeclarationE3=contextDeclarationE();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_contextDeclarationE.Add(contextDeclarationE3.Tree);

					}
					break;

				default:
					goto loop1;
				}
			}

			loop1:
				;

			} finally { DebugExitSubRule(1); }

			DebugLocation(25, 52);
			EOF4=(CommonToken)Match(input,EOF,Follow._EOF_in_evolutionDeclarationList182); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_EOF.Add(EOF4);



			{
			// AST REWRITE
			// elements: SimpleName, contextDeclarationE
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 25:56: -> ^( EVOLUTIONHEAD SimpleName ( contextDeclarationE )* )
			{
				DebugLocation(25, 59);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:25:59: ^( EVOLUTIONHEAD SimpleName ( contextDeclarationE )* )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(25, 61);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(EVOLUTIONHEAD, "EVOLUTIONHEAD"), root_1);

				DebugLocation(25, 75);
				adaptor.AddChild(root_1, stream_SimpleName.NextNode());
				DebugLocation(25, 86);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:25:86: ( contextDeclarationE )*
				while ( stream_contextDeclarationE.HasNext )
				{
					DebugLocation(25, 86);
					adaptor.AddChild(root_1, stream_contextDeclarationE.NextTree());

				}
				stream_contextDeclarationE.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("evolutionDeclarationList", 1);
			LeaveRule("evolutionDeclarationList", 1);
			LeaveRule_evolutionDeclarationList();
		}
		DebugLocation(26, 1);
		} finally { DebugExitRule(GrammarFileName, "evolutionDeclarationList"); }
		return retval;

	}
	// $ANTLR end "evolutionDeclarationList"

	public sealed partial class contextDeclarationList_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public contextDeclarationList_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_contextDeclarationList();
	partial void LeaveRule_contextDeclarationList();

	// $ANTLR start "contextDeclarationList"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:29:1: public contextDeclarationList : ( contextDeclaration )* EOF -> ^( CONDITION ( contextDeclaration )* ) ;
	[GrammarRule("contextDeclarationList")]
	public OCLSyntaxParser.contextDeclarationList_return contextDeclarationList()
	{
		EnterRule_contextDeclarationList();
		EnterRule("contextDeclarationList", 2);
		TraceIn("contextDeclarationList", 2);
		OCLSyntaxParser.contextDeclarationList_return retval = new OCLSyntaxParser.contextDeclarationList_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		CommonToken EOF6 = default(CommonToken);
		OCLSyntaxParser.contextDeclaration_return contextDeclaration5 = default(OCLSyntaxParser.contextDeclaration_return);

		object EOF6_tree = default(object);
		RewriteRuleITokenStream stream_EOF=new RewriteRuleITokenStream(adaptor,"token EOF");
		RewriteRuleSubtreeStream stream_contextDeclaration=new RewriteRuleSubtreeStream(adaptor,"rule contextDeclaration");
		try { DebugEnterRule(GrammarFileName, "contextDeclarationList");
		DebugLocation(29, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:30:2: ( ( contextDeclaration )* EOF -> ^( CONDITION ( contextDeclaration )* ) )
			DebugEnterAlt(1);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:30:3: ( contextDeclaration )* EOF
			{
			DebugLocation(30, 3);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:30:3: ( contextDeclaration )*
			try { DebugEnterSubRule(2);
			while (true)
			{
				int alt2=2;
				try { DebugEnterDecision(2, false);
				int LA2_0 = input.LA(1);

				if ((LA2_0==103))
				{
					alt2 = 1;
				}


				} finally { DebugExitDecision(2); }
				switch ( alt2 )
				{
				case 1:
					DebugEnterAlt(1);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:30:3: contextDeclaration
					{
					DebugLocation(30, 3);
					PushFollow(Follow._contextDeclaration_in_contextDeclarationList206);
					contextDeclaration5=contextDeclaration();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_contextDeclaration.Add(contextDeclaration5.Tree);

					}
					break;

				default:
					goto loop2;
				}
			}

			loop2:
				;

			} finally { DebugExitSubRule(2); }

			DebugLocation(30, 23);
			EOF6=(CommonToken)Match(input,EOF,Follow._EOF_in_contextDeclarationList209); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_EOF.Add(EOF6);



			{
			// AST REWRITE
			// elements: contextDeclaration
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 30:27: -> ^( CONDITION ( contextDeclaration )* )
			{
				DebugLocation(30, 30);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:30:30: ^( CONDITION ( contextDeclaration )* )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(30, 32);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(CONDITION, "CONDITION"), root_1);

				DebugLocation(30, 42);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:30:42: ( contextDeclaration )*
				while ( stream_contextDeclaration.HasNext )
				{
					DebugLocation(30, 42);
					adaptor.AddChild(root_1, stream_contextDeclaration.NextTree());

				}
				stream_contextDeclaration.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("contextDeclarationList", 2);
			LeaveRule("contextDeclarationList", 2);
			LeaveRule_contextDeclarationList();
		}
		DebugLocation(31, 1);
		} finally { DebugExitRule(GrammarFileName, "contextDeclarationList"); }
		return retval;

	}
	// $ANTLR end "contextDeclarationList"

	public sealed partial class contextDeclaration_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public contextDeclaration_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_contextDeclaration();
	partial void LeaveRule_contextDeclaration();

	// $ANTLR start "contextDeclaration"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:34:1: public contextDeclaration : ( propertyContextDecl | classifierContextDecl | operationContextDecl );
	[GrammarRule("contextDeclaration")]
	public OCLSyntaxParser.contextDeclaration_return contextDeclaration()
	{
		EnterRule_contextDeclaration();
		EnterRule("contextDeclaration", 3);
		TraceIn("contextDeclaration", 3);
		OCLSyntaxParser.contextDeclaration_return retval = new OCLSyntaxParser.contextDeclaration_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		OCLSyntaxParser.propertyContextDecl_return propertyContextDecl7 = default(OCLSyntaxParser.propertyContextDecl_return);
		OCLSyntaxParser.classifierContextDecl_return classifierContextDecl8 = default(OCLSyntaxParser.classifierContextDecl_return);
		OCLSyntaxParser.operationContextDecl_return operationContextDecl9 = default(OCLSyntaxParser.operationContextDecl_return);


		try { DebugEnterRule(GrammarFileName, "contextDeclaration");
		DebugLocation(34, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:35:2: ( propertyContextDecl | classifierContextDecl | operationContextDecl )
			int alt3=3;
			try { DebugEnterDecision(3, false);
			try
			{
				alt3 = dfa3.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(3); }
			switch (alt3)
			{
			case 1:
				DebugEnterAlt(1);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:35:3: propertyContextDecl
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(35, 3);
				PushFollow(Follow._propertyContextDecl_in_contextDeclaration231);
				propertyContextDecl7=propertyContextDecl();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, propertyContextDecl7.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:36:3: classifierContextDecl
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(36, 3);
				PushFollow(Follow._classifierContextDecl_in_contextDeclaration235);
				classifierContextDecl8=classifierContextDecl();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, classifierContextDecl8.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:37:3: operationContextDecl
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(37, 3);
				PushFollow(Follow._operationContextDecl_in_contextDeclaration239);
				operationContextDecl9=operationContextDecl();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, operationContextDecl9.Tree);

				}
				break;

			}
			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("contextDeclaration", 3);
			LeaveRule("contextDeclaration", 3);
			LeaveRule_contextDeclaration();
		}
		DebugLocation(38, 1);
		} finally { DebugExitRule(GrammarFileName, "contextDeclaration"); }
		return retval;

	}
	// $ANTLR end "contextDeclaration"

	public sealed partial class contextDeclarationE_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public contextDeclarationE_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_contextDeclarationE();
	partial void LeaveRule_contextDeclarationE();

	// $ANTLR start "contextDeclarationE"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:41:1: public contextDeclarationE : ( propertyContextDecl | classifierContextDecl | operationContextDecl );
	[GrammarRule("contextDeclarationE")]
	public OCLSyntaxParser.contextDeclarationE_return contextDeclarationE()
	{
		EnterRule_contextDeclarationE();
		EnterRule("contextDeclarationE", 4);
		TraceIn("contextDeclarationE", 4);
		OCLSyntaxParser.contextDeclarationE_return retval = new OCLSyntaxParser.contextDeclarationE_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		OCLSyntaxParser.propertyContextDecl_return propertyContextDecl10 = default(OCLSyntaxParser.propertyContextDecl_return);
		OCLSyntaxParser.classifierContextDecl_return classifierContextDecl11 = default(OCLSyntaxParser.classifierContextDecl_return);
		OCLSyntaxParser.operationContextDecl_return operationContextDecl12 = default(OCLSyntaxParser.operationContextDecl_return);


		try { DebugEnterRule(GrammarFileName, "contextDeclarationE");
		DebugLocation(41, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:42:2: ( propertyContextDecl | classifierContextDecl | operationContextDecl )
			int alt4=3;
			try { DebugEnterDecision(4, false);
			try
			{
				alt4 = dfa4.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(4); }
			switch (alt4)
			{
			case 1:
				DebugEnterAlt(1);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:42:3: propertyContextDecl
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(42, 3);
				PushFollow(Follow._propertyContextDecl_in_contextDeclarationE252);
				propertyContextDecl10=propertyContextDecl();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, propertyContextDecl10.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:43:3: classifierContextDecl
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(43, 3);
				PushFollow(Follow._classifierContextDecl_in_contextDeclarationE256);
				classifierContextDecl11=classifierContextDecl();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, classifierContextDecl11.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:44:3: operationContextDecl
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(44, 3);
				PushFollow(Follow._operationContextDecl_in_contextDeclarationE260);
				operationContextDecl12=operationContextDecl();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, operationContextDecl12.Tree);

				}
				break;

			}
			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("contextDeclarationE", 4);
			LeaveRule("contextDeclarationE", 4);
			LeaveRule_contextDeclarationE();
		}
		DebugLocation(45, 1);
		} finally { DebugExitRule(GrammarFileName, "contextDeclarationE"); }
		return retval;

	}
	// $ANTLR end "contextDeclarationE"

	private sealed partial class propertyContextDecl_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public propertyContextDecl_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_propertyContextDecl();
	partial void LeaveRule_propertyContextDecl();

	// $ANTLR start "propertyContextDecl"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:47:1: propertyContextDecl : propertyContextHead ( initOrDerValue )* -> ^( PROPERTYCONDITION propertyContextHead ( initOrDerValue )* ) ;
	[GrammarRule("propertyContextDecl")]
	private OCLSyntaxParser.propertyContextDecl_return propertyContextDecl()
	{
		EnterRule_propertyContextDecl();
		EnterRule("propertyContextDecl", 5);
		TraceIn("propertyContextDecl", 5);
		OCLSyntaxParser.propertyContextDecl_return retval = new OCLSyntaxParser.propertyContextDecl_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		OCLSyntaxParser.propertyContextHead_return propertyContextHead13 = default(OCLSyntaxParser.propertyContextHead_return);
		OCLSyntaxParser.initOrDerValue_return initOrDerValue14 = default(OCLSyntaxParser.initOrDerValue_return);

		RewriteRuleSubtreeStream stream_propertyContextHead=new RewriteRuleSubtreeStream(adaptor,"rule propertyContextHead");
		RewriteRuleSubtreeStream stream_initOrDerValue=new RewriteRuleSubtreeStream(adaptor,"rule initOrDerValue");
		try { DebugEnterRule(GrammarFileName, "propertyContextDecl");
		DebugLocation(47, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:48:2: ( propertyContextHead ( initOrDerValue )* -> ^( PROPERTYCONDITION propertyContextHead ( initOrDerValue )* ) )
			DebugEnterAlt(1);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:48:3: propertyContextHead ( initOrDerValue )*
			{
			DebugLocation(48, 3);
			PushFollow(Follow._propertyContextHead_in_propertyContextDecl270);
			propertyContextHead13=propertyContextHead();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_propertyContextHead.Add(propertyContextHead13.Tree);
			DebugLocation(48, 23);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:48:23: ( initOrDerValue )*
			try { DebugEnterSubRule(5);
			while (true)
			{
				int alt5=2;
				try { DebugEnterDecision(5, false);
				int LA5_0 = input.LA(1);

				if ((LA5_0==105||LA5_0==112))
				{
					alt5 = 1;
				}


				} finally { DebugExitDecision(5); }
				switch ( alt5 )
				{
				case 1:
					DebugEnterAlt(1);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:48:23: initOrDerValue
					{
					DebugLocation(48, 23);
					PushFollow(Follow._initOrDerValue_in_propertyContextDecl272);
					initOrDerValue14=initOrDerValue();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_initOrDerValue.Add(initOrDerValue14.Tree);

					}
					break;

				default:
					goto loop5;
				}
			}

			loop5:
				;

			} finally { DebugExitSubRule(5); }



			{
			// AST REWRITE
			// elements: propertyContextHead, initOrDerValue
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 48:39: -> ^( PROPERTYCONDITION propertyContextHead ( initOrDerValue )* )
			{
				DebugLocation(48, 41);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:48:41: ^( PROPERTYCONDITION propertyContextHead ( initOrDerValue )* )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(48, 43);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(PROPERTYCONDITION, "PROPERTYCONDITION"), root_1);

				DebugLocation(48, 61);
				adaptor.AddChild(root_1, stream_propertyContextHead.NextTree());
				DebugLocation(48, 81);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:48:81: ( initOrDerValue )*
				while ( stream_initOrDerValue.HasNext )
				{
					DebugLocation(48, 81);
					adaptor.AddChild(root_1, stream_initOrDerValue.NextTree());

				}
				stream_initOrDerValue.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("propertyContextDecl", 5);
			LeaveRule("propertyContextDecl", 5);
			LeaveRule_propertyContextDecl();
		}
		DebugLocation(49, 1);
		} finally { DebugExitRule(GrammarFileName, "propertyContextDecl"); }
		return retval;

	}
	// $ANTLR end "propertyContextDecl"

	private sealed partial class propertyContextHead_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public propertyContextHead_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_propertyContextHead();
	partial void LeaveRule_propertyContextHead();

	// $ANTLR start "propertyContextHead"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:51:1: propertyContextHead : c= 'context' SimpleName ( '::' SimpleName )* '::' SimpleName ':' type -> ^( PROPERTYHEAD[$c] ( SimpleName )+ type ) ;
	[GrammarRule("propertyContextHead")]
	private OCLSyntaxParser.propertyContextHead_return propertyContextHead()
	{
		EnterRule_propertyContextHead();
		EnterRule("propertyContextHead", 6);
		TraceIn("propertyContextHead", 6);
		OCLSyntaxParser.propertyContextHead_return retval = new OCLSyntaxParser.propertyContextHead_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		CommonToken c = default(CommonToken);
		CommonToken SimpleName15 = default(CommonToken);
		CommonToken string_literal16 = default(CommonToken);
		CommonToken SimpleName17 = default(CommonToken);
		CommonToken string_literal18 = default(CommonToken);
		CommonToken SimpleName19 = default(CommonToken);
		CommonToken char_literal20 = default(CommonToken);
		OCLSyntaxParser.type_return type21 = default(OCLSyntaxParser.type_return);

		object c_tree = default(object);
		object SimpleName15_tree = default(object);
		object string_literal16_tree = default(object);
		object SimpleName17_tree = default(object);
		object string_literal18_tree = default(object);
		object SimpleName19_tree = default(object);
		object char_literal20_tree = default(object);
		RewriteRuleITokenStream stream_103=new RewriteRuleITokenStream(adaptor,"token 103");
		RewriteRuleITokenStream stream_SimpleName=new RewriteRuleITokenStream(adaptor,"token SimpleName");
		RewriteRuleITokenStream stream_72=new RewriteRuleITokenStream(adaptor,"token 72");
		RewriteRuleITokenStream stream_71=new RewriteRuleITokenStream(adaptor,"token 71");
		RewriteRuleSubtreeStream stream_type=new RewriteRuleSubtreeStream(adaptor,"rule type");
		try { DebugEnterRule(GrammarFileName, "propertyContextHead");
		DebugLocation(51, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:52:2: (c= 'context' SimpleName ( '::' SimpleName )* '::' SimpleName ':' type -> ^( PROPERTYHEAD[$c] ( SimpleName )+ type ) )
			DebugEnterAlt(1);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:52:3: c= 'context' SimpleName ( '::' SimpleName )* '::' SimpleName ':' type
			{
			DebugLocation(52, 4);
			c=(CommonToken)Match(input,103,Follow._103_in_propertyContextHead295); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_103.Add(c);

			DebugLocation(52, 15);
			SimpleName15=(CommonToken)Match(input,SimpleName,Follow._SimpleName_in_propertyContextHead297); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_SimpleName.Add(SimpleName15);

			DebugLocation(52, 26);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:52:26: ( '::' SimpleName )*
			try { DebugEnterSubRule(6);
			while (true)
			{
				int alt6=2;
				try { DebugEnterDecision(6, false);
				int LA6_0 = input.LA(1);

				if ((LA6_0==72))
				{
					int LA6_1 = input.LA(2);

					if ((LA6_1==SimpleName))
					{
						int LA6_2 = input.LA(3);

						if ((LA6_2==72))
						{
							alt6 = 1;
						}


					}


				}


				} finally { DebugExitDecision(6); }
				switch ( alt6 )
				{
				case 1:
					DebugEnterAlt(1);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:52:27: '::' SimpleName
					{
					DebugLocation(52, 27);
					string_literal16=(CommonToken)Match(input,72,Follow._72_in_propertyContextHead300); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_72.Add(string_literal16);

					DebugLocation(52, 32);
					SimpleName17=(CommonToken)Match(input,SimpleName,Follow._SimpleName_in_propertyContextHead302); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_SimpleName.Add(SimpleName17);


					}
					break;

				default:
					goto loop6;
				}
			}

			loop6:
				;

			} finally { DebugExitSubRule(6); }

			DebugLocation(52, 45);
			string_literal18=(CommonToken)Match(input,72,Follow._72_in_propertyContextHead306); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_72.Add(string_literal18);

			DebugLocation(52, 50);
			SimpleName19=(CommonToken)Match(input,SimpleName,Follow._SimpleName_in_propertyContextHead308); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_SimpleName.Add(SimpleName19);

			DebugLocation(52, 61);
			char_literal20=(CommonToken)Match(input,71,Follow._71_in_propertyContextHead310); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_71.Add(char_literal20);

			DebugLocation(52, 65);
			PushFollow(Follow._type_in_propertyContextHead312);
			type21=type();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_type.Add(type21.Tree);


			{
			// AST REWRITE
			// elements: SimpleName, type
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 53:3: -> ^( PROPERTYHEAD[$c] ( SimpleName )+ type )
			{
				DebugLocation(53, 6);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:53:6: ^( PROPERTYHEAD[$c] ( SimpleName )+ type )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(53, 8);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(PROPERTYHEAD, c), root_1);

				DebugLocation(53, 25);
				if (!(stream_SimpleName.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_SimpleName.HasNext )
				{
					DebugLocation(53, 25);
					adaptor.AddChild(root_1, stream_SimpleName.NextNode());

				}
				stream_SimpleName.Reset();
				DebugLocation(53, 37);
				adaptor.AddChild(root_1, stream_type.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("propertyContextHead", 6);
			LeaveRule("propertyContextHead", 6);
			LeaveRule_propertyContextHead();
		}
		DebugLocation(54, 1);
		} finally { DebugExitRule(GrammarFileName, "propertyContextHead"); }
		return retval;

	}
	// $ANTLR end "propertyContextHead"

	private sealed partial class operationContextDecl_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public operationContextDecl_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_operationContextDecl();
	partial void LeaveRule_operationContextDecl();

	// $ANTLR start "operationContextDecl"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:56:1: operationContextDecl : operationContextHead ( prePostOrBodyDecl )* -> ^( OPERATIONCONDITION operationContextHead ( prePostOrBodyDecl )* ) ;
	[GrammarRule("operationContextDecl")]
	private OCLSyntaxParser.operationContextDecl_return operationContextDecl()
	{
		EnterRule_operationContextDecl();
		EnterRule("operationContextDecl", 7);
		TraceIn("operationContextDecl", 7);
		OCLSyntaxParser.operationContextDecl_return retval = new OCLSyntaxParser.operationContextDecl_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		OCLSyntaxParser.operationContextHead_return operationContextHead22 = default(OCLSyntaxParser.operationContextHead_return);
		OCLSyntaxParser.prePostOrBodyDecl_return prePostOrBodyDecl23 = default(OCLSyntaxParser.prePostOrBodyDecl_return);

		RewriteRuleSubtreeStream stream_operationContextHead=new RewriteRuleSubtreeStream(adaptor,"rule operationContextHead");
		RewriteRuleSubtreeStream stream_prePostOrBodyDecl=new RewriteRuleSubtreeStream(adaptor,"rule prePostOrBodyDecl");
		try { DebugEnterRule(GrammarFileName, "operationContextDecl");
		DebugLocation(56, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:57:2: ( operationContextHead ( prePostOrBodyDecl )* -> ^( OPERATIONCONDITION operationContextHead ( prePostOrBodyDecl )* ) )
			DebugEnterAlt(1);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:57:3: operationContextHead ( prePostOrBodyDecl )*
			{
			DebugLocation(57, 3);
			PushFollow(Follow._operationContextHead_in_operationContextDecl336);
			operationContextHead22=operationContextHead();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_operationContextHead.Add(operationContextHead22.Tree);
			DebugLocation(57, 24);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:57:24: ( prePostOrBodyDecl )*
			try { DebugEnterSubRule(7);
			while (true)
			{
				int alt7=2;
				try { DebugEnterDecision(7, false);
				int LA7_0 = input.LA(1);

				if ((LA7_0==102||(LA7_0>=120 && LA7_0<=121)))
				{
					alt7 = 1;
				}


				} finally { DebugExitDecision(7); }
				switch ( alt7 )
				{
				case 1:
					DebugEnterAlt(1);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:57:24: prePostOrBodyDecl
					{
					DebugLocation(57, 24);
					PushFollow(Follow._prePostOrBodyDecl_in_operationContextDecl338);
					prePostOrBodyDecl23=prePostOrBodyDecl();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_prePostOrBodyDecl.Add(prePostOrBodyDecl23.Tree);

					}
					break;

				default:
					goto loop7;
				}
			}

			loop7:
				;

			} finally { DebugExitSubRule(7); }



			{
			// AST REWRITE
			// elements: operationContextHead, prePostOrBodyDecl
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 57:43: -> ^( OPERATIONCONDITION operationContextHead ( prePostOrBodyDecl )* )
			{
				DebugLocation(57, 45);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:57:45: ^( OPERATIONCONDITION operationContextHead ( prePostOrBodyDecl )* )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(57, 47);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(OPERATIONCONDITION, "OPERATIONCONDITION"), root_1);

				DebugLocation(57, 66);
				adaptor.AddChild(root_1, stream_operationContextHead.NextTree());
				DebugLocation(57, 87);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:57:87: ( prePostOrBodyDecl )*
				while ( stream_prePostOrBodyDecl.HasNext )
				{
					DebugLocation(57, 87);
					adaptor.AddChild(root_1, stream_prePostOrBodyDecl.NextTree());

				}
				stream_prePostOrBodyDecl.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("operationContextDecl", 7);
			LeaveRule("operationContextDecl", 7);
			LeaveRule_operationContextDecl();
		}
		DebugLocation(58, 1);
		} finally { DebugExitRule(GrammarFileName, "operationContextDecl"); }
		return retval;

	}
	// $ANTLR end "operationContextDecl"

	private sealed partial class operationContextHead_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public operationContextHead_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_operationContextHead();
	partial void LeaveRule_operationContextHead();

	// $ANTLR start "operationContextHead"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:60:1: operationContextHead : c= 'context' operation -> ^( OPERATIONHEAD[$c] operation ) ;
	[GrammarRule("operationContextHead")]
	private OCLSyntaxParser.operationContextHead_return operationContextHead()
	{
		EnterRule_operationContextHead();
		EnterRule("operationContextHead", 8);
		TraceIn("operationContextHead", 8);
		OCLSyntaxParser.operationContextHead_return retval = new OCLSyntaxParser.operationContextHead_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		CommonToken c = default(CommonToken);
		OCLSyntaxParser.operation_return operation24 = default(OCLSyntaxParser.operation_return);

		object c_tree = default(object);
		RewriteRuleITokenStream stream_103=new RewriteRuleITokenStream(adaptor,"token 103");
		RewriteRuleSubtreeStream stream_operation=new RewriteRuleSubtreeStream(adaptor,"rule operation");
		try { DebugEnterRule(GrammarFileName, "operationContextHead");
		DebugLocation(60, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:61:2: (c= 'context' operation -> ^( OPERATIONHEAD[$c] operation ) )
			DebugEnterAlt(1);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:61:3: c= 'context' operation
			{
			DebugLocation(61, 4);
			c=(CommonToken)Match(input,103,Follow._103_in_operationContextHead361); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_103.Add(c);

			DebugLocation(61, 15);
			PushFollow(Follow._operation_in_operationContextHead363);
			operation24=operation();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_operation.Add(operation24.Tree);


			{
			// AST REWRITE
			// elements: operation
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 61:25: -> ^( OPERATIONHEAD[$c] operation )
			{
				DebugLocation(61, 27);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:61:27: ^( OPERATIONHEAD[$c] operation )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(61, 29);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(OPERATIONHEAD, c), root_1);

				DebugLocation(61, 47);
				adaptor.AddChild(root_1, stream_operation.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("operationContextHead", 8);
			LeaveRule("operationContextHead", 8);
			LeaveRule_operationContextHead();
		}
		DebugLocation(62, 1);
		} finally { DebugExitRule(GrammarFileName, "operationContextHead"); }
		return retval;

	}
	// $ANTLR end "operationContextHead"

	private sealed partial class classifierContextDecl_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public classifierContextDecl_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_classifierContextDecl();
	partial void LeaveRule_classifierContextDecl();

	// $ANTLR start "classifierContextDecl"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:64:1: classifierContextDecl : classifierContextHead ( invOrDef )* -> ^( CLASSIFIERCONDITION classifierContextHead ( invOrDef )* ) ;
	[GrammarRule("classifierContextDecl")]
	private OCLSyntaxParser.classifierContextDecl_return classifierContextDecl()
	{
		EnterRule_classifierContextDecl();
		EnterRule("classifierContextDecl", 9);
		TraceIn("classifierContextDecl", 9);
		OCLSyntaxParser.classifierContextDecl_return retval = new OCLSyntaxParser.classifierContextDecl_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		OCLSyntaxParser.classifierContextHead_return classifierContextHead25 = default(OCLSyntaxParser.classifierContextHead_return);
		OCLSyntaxParser.invOrDef_return invOrDef26 = default(OCLSyntaxParser.invOrDef_return);

		RewriteRuleSubtreeStream stream_classifierContextHead=new RewriteRuleSubtreeStream(adaptor,"rule classifierContextHead");
		RewriteRuleSubtreeStream stream_invOrDef=new RewriteRuleSubtreeStream(adaptor,"rule invOrDef");
		try { DebugEnterRule(GrammarFileName, "classifierContextDecl");
		DebugLocation(64, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:65:2: ( classifierContextHead ( invOrDef )* -> ^( CLASSIFIERCONDITION classifierContextHead ( invOrDef )* ) )
			DebugEnterAlt(1);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:65:3: classifierContextHead ( invOrDef )*
			{
			DebugLocation(65, 3);
			PushFollow(Follow._classifierContextHead_in_classifierContextDecl381);
			classifierContextHead25=classifierContextHead();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_classifierContextHead.Add(classifierContextHead25.Tree);
			DebugLocation(65, 25);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:65:25: ( invOrDef )*
			try { DebugEnterSubRule(8);
			while (true)
			{
				int alt8=2;
				try { DebugEnterDecision(8, false);
				int LA8_0 = input.LA(1);

				if ((LA8_0==104||LA8_0==113||LA8_0==123))
				{
					alt8 = 1;
				}


				} finally { DebugExitDecision(8); }
				switch ( alt8 )
				{
				case 1:
					DebugEnterAlt(1);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:65:26: invOrDef
					{
					DebugLocation(65, 26);
					PushFollow(Follow._invOrDef_in_classifierContextDecl384);
					invOrDef26=invOrDef();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_invOrDef.Add(invOrDef26.Tree);

					}
					break;

				default:
					goto loop8;
				}
			}

			loop8:
				;

			} finally { DebugExitSubRule(8); }



			{
			// AST REWRITE
			// elements: classifierContextHead, invOrDef
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 65:37: -> ^( CLASSIFIERCONDITION classifierContextHead ( invOrDef )* )
			{
				DebugLocation(65, 40);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:65:40: ^( CLASSIFIERCONDITION classifierContextHead ( invOrDef )* )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(65, 42);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(CLASSIFIERCONDITION, "CLASSIFIERCONDITION"), root_1);

				DebugLocation(65, 62);
				adaptor.AddChild(root_1, stream_classifierContextHead.NextTree());
				DebugLocation(65, 84);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:65:84: ( invOrDef )*
				while ( stream_invOrDef.HasNext )
				{
					DebugLocation(65, 84);
					adaptor.AddChild(root_1, stream_invOrDef.NextTree());

				}
				stream_invOrDef.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("classifierContextDecl", 9);
			LeaveRule("classifierContextDecl", 9);
			LeaveRule_classifierContextDecl();
		}
		DebugLocation(66, 1);
		} finally { DebugExitRule(GrammarFileName, "classifierContextDecl"); }
		return retval;

	}
	// $ANTLR end "classifierContextDecl"

	private sealed partial class classifierContextHead_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public classifierContextHead_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_classifierContextHead();
	partial void LeaveRule_classifierContextHead();

	// $ANTLR start "classifierContextHead"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:68:1: classifierContextHead : (c= 'context' pathName -> ^( CLASSIFIERHEAD[$c] pathName ) |c= 'context' SimpleName ':' pathName -> ^( CLASSIFIERHEAD[$c] pathName SimpleName ) );
	[GrammarRule("classifierContextHead")]
	private OCLSyntaxParser.classifierContextHead_return classifierContextHead()
	{
		EnterRule_classifierContextHead();
		EnterRule("classifierContextHead", 10);
		TraceIn("classifierContextHead", 10);
		OCLSyntaxParser.classifierContextHead_return retval = new OCLSyntaxParser.classifierContextHead_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		CommonToken c = default(CommonToken);
		CommonToken SimpleName28 = default(CommonToken);
		CommonToken char_literal29 = default(CommonToken);
		OCLSyntaxParser.pathName_return pathName27 = default(OCLSyntaxParser.pathName_return);
		OCLSyntaxParser.pathName_return pathName30 = default(OCLSyntaxParser.pathName_return);

		object c_tree = default(object);
		object SimpleName28_tree = default(object);
		object char_literal29_tree = default(object);
		RewriteRuleITokenStream stream_103=new RewriteRuleITokenStream(adaptor,"token 103");
		RewriteRuleITokenStream stream_SimpleName=new RewriteRuleITokenStream(adaptor,"token SimpleName");
		RewriteRuleITokenStream stream_71=new RewriteRuleITokenStream(adaptor,"token 71");
		RewriteRuleSubtreeStream stream_pathName=new RewriteRuleSubtreeStream(adaptor,"rule pathName");
		try { DebugEnterRule(GrammarFileName, "classifierContextHead");
		DebugLocation(68, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:69:2: (c= 'context' pathName -> ^( CLASSIFIERHEAD[$c] pathName ) |c= 'context' SimpleName ':' pathName -> ^( CLASSIFIERHEAD[$c] pathName SimpleName ) )
			int alt9=2;
			try { DebugEnterDecision(9, false);
			int LA9_0 = input.LA(1);

			if ((LA9_0==103))
			{
				int LA9_1 = input.LA(2);

				if ((LA9_1==SimpleName))
				{
					int LA9_2 = input.LA(3);

					if ((LA9_2==71))
					{
						alt9 = 2;
					}
					else if ((LA9_2==EOF||LA9_2==72||(LA9_2>=103 && LA9_2<=104)||LA9_2==113||LA9_2==123))
					{
						alt9 = 1;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 9, 2, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 9, 1, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 9, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(9); }
			switch (alt9)
			{
			case 1:
				DebugEnterAlt(1);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:69:3: c= 'context' pathName
				{
				DebugLocation(69, 4);
				c=(CommonToken)Match(input,103,Follow._103_in_classifierContextHead409); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_103.Add(c);

				DebugLocation(69, 15);
				PushFollow(Follow._pathName_in_classifierContextHead411);
				pathName27=pathName();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_pathName.Add(pathName27.Tree);


				{
				// AST REWRITE
				// elements: pathName
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 69:25: -> ^( CLASSIFIERHEAD[$c] pathName )
				{
					DebugLocation(69, 27);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:69:27: ^( CLASSIFIERHEAD[$c] pathName )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(69, 29);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(CLASSIFIERHEAD, c), root_1);

					DebugLocation(69, 48);
					adaptor.AddChild(root_1, stream_pathName.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:70:3: c= 'context' SimpleName ':' pathName
				{
				DebugLocation(70, 4);
				c=(CommonToken)Match(input,103,Follow._103_in_classifierContextHead427); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_103.Add(c);

				DebugLocation(70, 15);
				SimpleName28=(CommonToken)Match(input,SimpleName,Follow._SimpleName_in_classifierContextHead429); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_SimpleName.Add(SimpleName28);

				DebugLocation(70, 25);
				char_literal29=(CommonToken)Match(input,71,Follow._71_in_classifierContextHead430); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_71.Add(char_literal29);

				DebugLocation(70, 28);
				PushFollow(Follow._pathName_in_classifierContextHead431);
				pathName30=pathName();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_pathName.Add(pathName30.Tree);


				{
				// AST REWRITE
				// elements: pathName, SimpleName
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 70:37: -> ^( CLASSIFIERHEAD[$c] pathName SimpleName )
				{
					DebugLocation(70, 39);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:70:39: ^( CLASSIFIERHEAD[$c] pathName SimpleName )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(70, 41);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(CLASSIFIERHEAD, c), root_1);

					DebugLocation(70, 60);
					adaptor.AddChild(root_1, stream_pathName.NextTree());
					DebugLocation(70, 69);
					adaptor.AddChild(root_1, stream_SimpleName.NextNode());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("classifierContextHead", 10);
			LeaveRule("classifierContextHead", 10);
			LeaveRule_classifierContextHead();
		}
		DebugLocation(71, 1);
		} finally { DebugExitRule(GrammarFileName, "classifierContextHead"); }
		return retval;

	}
	// $ANTLR end "classifierContextHead"

	private sealed partial class initOrDerValue_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public initOrDerValue_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_initOrDerValue();
	partial void LeaveRule_initOrDerValue();

	// $ANTLR start "initOrDerValue"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:73:1: initOrDerValue : (i= 'init' ':' oclExpression -> ^( INIT[$i] oclExpression ) |d= 'derive' ':' oclExpression -> ^( DERIVATE[$d] oclExpression ) );
	[GrammarRule("initOrDerValue")]
	private OCLSyntaxParser.initOrDerValue_return initOrDerValue()
	{
		EnterRule_initOrDerValue();
		EnterRule("initOrDerValue", 11);
		TraceIn("initOrDerValue", 11);
		OCLSyntaxParser.initOrDerValue_return retval = new OCLSyntaxParser.initOrDerValue_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		CommonToken i = default(CommonToken);
		CommonToken d = default(CommonToken);
		CommonToken char_literal31 = default(CommonToken);
		CommonToken char_literal33 = default(CommonToken);
		OCLSyntaxParser.oclExpression_return oclExpression32 = default(OCLSyntaxParser.oclExpression_return);
		OCLSyntaxParser.oclExpression_return oclExpression34 = default(OCLSyntaxParser.oclExpression_return);

		object i_tree = default(object);
		object d_tree = default(object);
		object char_literal31_tree = default(object);
		object char_literal33_tree = default(object);
		RewriteRuleITokenStream stream_112=new RewriteRuleITokenStream(adaptor,"token 112");
		RewriteRuleITokenStream stream_71=new RewriteRuleITokenStream(adaptor,"token 71");
		RewriteRuleITokenStream stream_105=new RewriteRuleITokenStream(adaptor,"token 105");
		RewriteRuleSubtreeStream stream_oclExpression=new RewriteRuleSubtreeStream(adaptor,"rule oclExpression");
		try { DebugEnterRule(GrammarFileName, "initOrDerValue");
		DebugLocation(73, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:74:2: (i= 'init' ':' oclExpression -> ^( INIT[$i] oclExpression ) |d= 'derive' ':' oclExpression -> ^( DERIVATE[$d] oclExpression ) )
			int alt10=2;
			try { DebugEnterDecision(10, false);
			int LA10_0 = input.LA(1);

			if ((LA10_0==112))
			{
				alt10 = 1;
			}
			else if ((LA10_0==105))
			{
				alt10 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 10, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(10); }
			switch (alt10)
			{
			case 1:
				DebugEnterAlt(1);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:74:3: i= 'init' ':' oclExpression
				{
				DebugLocation(74, 4);
				i=(CommonToken)Match(input,112,Follow._112_in_initOrDerValue454); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_112.Add(i);

				DebugLocation(74, 12);
				char_literal31=(CommonToken)Match(input,71,Follow._71_in_initOrDerValue456); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_71.Add(char_literal31);

				DebugLocation(74, 16);
				PushFollow(Follow._oclExpression_in_initOrDerValue458);
				oclExpression32=oclExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_oclExpression.Add(oclExpression32.Tree);


				{
				// AST REWRITE
				// elements: oclExpression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 74:30: -> ^( INIT[$i] oclExpression )
				{
					DebugLocation(74, 33);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:74:33: ^( INIT[$i] oclExpression )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(74, 35);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(INIT, i), root_1);

					DebugLocation(74, 44);
					adaptor.AddChild(root_1, stream_oclExpression.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:75:3: d= 'derive' ':' oclExpression
				{
				DebugLocation(75, 4);
				d=(CommonToken)Match(input,105,Follow._105_in_initOrDerValue473); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_105.Add(d);

				DebugLocation(75, 14);
				char_literal33=(CommonToken)Match(input,71,Follow._71_in_initOrDerValue475); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_71.Add(char_literal33);

				DebugLocation(75, 18);
				PushFollow(Follow._oclExpression_in_initOrDerValue477);
				oclExpression34=oclExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_oclExpression.Add(oclExpression34.Tree);


				{
				// AST REWRITE
				// elements: oclExpression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 75:32: -> ^( DERIVATE[$d] oclExpression )
				{
					DebugLocation(75, 34);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:75:34: ^( DERIVATE[$d] oclExpression )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(75, 36);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(DERIVATE, d), root_1);

					DebugLocation(75, 49);
					adaptor.AddChild(root_1, stream_oclExpression.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("initOrDerValue", 11);
			LeaveRule("initOrDerValue", 11);
			LeaveRule_initOrDerValue();
		}
		DebugLocation(76, 1);
		} finally { DebugExitRule(GrammarFileName, "initOrDerValue"); }
		return retval;

	}
	// $ANTLR end "initOrDerValue"

	private sealed partial class invOrDef_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public invOrDef_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_invOrDef();
	partial void LeaveRule_invOrDef();

	// $ANTLR start "invOrDef"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:78:1: invOrDef : (i= 'inv' ( SimpleName )? ':' oclExpression (m= 'message' ':' msgExp= oclExpression )? -> ^( INV[$i] ( SimpleName )? oclExpression ( MESSAGE[$m] $msgExp)? ) | ( 'static' )? d= 'def' ( SimpleName )? ':' defExpression -> ^( DEF[$d] ( 'static' )? ( SimpleName )? defExpression ) );
	[GrammarRule("invOrDef")]
	private OCLSyntaxParser.invOrDef_return invOrDef()
	{
		EnterRule_invOrDef();
		EnterRule("invOrDef", 12);
		TraceIn("invOrDef", 12);
		OCLSyntaxParser.invOrDef_return retval = new OCLSyntaxParser.invOrDef_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		CommonToken i = default(CommonToken);
		CommonToken m = default(CommonToken);
		CommonToken d = default(CommonToken);
		CommonToken SimpleName35 = default(CommonToken);
		CommonToken char_literal36 = default(CommonToken);
		CommonToken char_literal38 = default(CommonToken);
		CommonToken string_literal39 = default(CommonToken);
		CommonToken SimpleName40 = default(CommonToken);
		CommonToken char_literal41 = default(CommonToken);
		OCLSyntaxParser.oclExpression_return msgExp = default(OCLSyntaxParser.oclExpression_return);
		OCLSyntaxParser.oclExpression_return oclExpression37 = default(OCLSyntaxParser.oclExpression_return);
		OCLSyntaxParser.defExpression_return defExpression42 = default(OCLSyntaxParser.defExpression_return);

		object i_tree = default(object);
		object m_tree = default(object);
		object d_tree = default(object);
		object SimpleName35_tree = default(object);
		object char_literal36_tree = default(object);
		object char_literal38_tree = default(object);
		object string_literal39_tree = default(object);
		object SimpleName40_tree = default(object);
		object char_literal41_tree = default(object);
		RewriteRuleITokenStream stream_113=new RewriteRuleITokenStream(adaptor,"token 113");
		RewriteRuleITokenStream stream_SimpleName=new RewriteRuleITokenStream(adaptor,"token SimpleName");
		RewriteRuleITokenStream stream_71=new RewriteRuleITokenStream(adaptor,"token 71");
		RewriteRuleITokenStream stream_116=new RewriteRuleITokenStream(adaptor,"token 116");
		RewriteRuleITokenStream stream_123=new RewriteRuleITokenStream(adaptor,"token 123");
		RewriteRuleITokenStream stream_104=new RewriteRuleITokenStream(adaptor,"token 104");
		RewriteRuleSubtreeStream stream_oclExpression=new RewriteRuleSubtreeStream(adaptor,"rule oclExpression");
		RewriteRuleSubtreeStream stream_defExpression=new RewriteRuleSubtreeStream(adaptor,"rule defExpression");
		try { DebugEnterRule(GrammarFileName, "invOrDef");
		DebugLocation(78, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:79:2: (i= 'inv' ( SimpleName )? ':' oclExpression (m= 'message' ':' msgExp= oclExpression )? -> ^( INV[$i] ( SimpleName )? oclExpression ( MESSAGE[$m] $msgExp)? ) | ( 'static' )? d= 'def' ( SimpleName )? ':' defExpression -> ^( DEF[$d] ( 'static' )? ( SimpleName )? defExpression ) )
			int alt15=2;
			try { DebugEnterDecision(15, false);
			int LA15_0 = input.LA(1);

			if ((LA15_0==113))
			{
				alt15 = 1;
			}
			else if ((LA15_0==104||LA15_0==123))
			{
				alt15 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 15, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(15); }
			switch (alt15)
			{
			case 1:
				DebugEnterAlt(1);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:79:3: i= 'inv' ( SimpleName )? ':' oclExpression (m= 'message' ':' msgExp= oclExpression )?
				{
				DebugLocation(79, 4);
				i=(CommonToken)Match(input,113,Follow._113_in_invOrDef497); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_113.Add(i);

				DebugLocation(79, 11);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:79:11: ( SimpleName )?
				int alt11=2;
				try { DebugEnterSubRule(11);
				try { DebugEnterDecision(11, false);
				int LA11_0 = input.LA(1);

				if ((LA11_0==SimpleName))
				{
					alt11 = 1;
				}
				} finally { DebugExitDecision(11); }
				switch (alt11)
				{
				case 1:
					DebugEnterAlt(1);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:79:12: SimpleName
					{
					DebugLocation(79, 12);
					SimpleName35=(CommonToken)Match(input,SimpleName,Follow._SimpleName_in_invOrDef500); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_SimpleName.Add(SimpleName35);


					}
					break;

				}
				} finally { DebugExitSubRule(11); }

				DebugLocation(79, 26);
				char_literal36=(CommonToken)Match(input,71,Follow._71_in_invOrDef505); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_71.Add(char_literal36);

				DebugLocation(79, 30);
				PushFollow(Follow._oclExpression_in_invOrDef507);
				oclExpression37=oclExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_oclExpression.Add(oclExpression37.Tree);
				DebugLocation(80, 3);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:80:3: (m= 'message' ':' msgExp= oclExpression )?
				int alt12=2;
				try { DebugEnterSubRule(12);
				try { DebugEnterDecision(12, false);
				int LA12_0 = input.LA(1);

				if ((LA12_0==116))
				{
					alt12 = 1;
				}
				} finally { DebugExitDecision(12); }
				switch (alt12)
				{
				case 1:
					DebugEnterAlt(1);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:80:4: m= 'message' ':' msgExp= oclExpression
					{
					DebugLocation(80, 5);
					m=(CommonToken)Match(input,116,Follow._116_in_invOrDef515); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_116.Add(m);

					DebugLocation(80, 16);
					char_literal38=(CommonToken)Match(input,71,Follow._71_in_invOrDef517); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_71.Add(char_literal38);

					DebugLocation(80, 27);
					PushFollow(Follow._oclExpression_in_invOrDef523);
					msgExp=oclExpression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_oclExpression.Add(msgExp.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(12); }



				{
				// AST REWRITE
				// elements: SimpleName, oclExpression, msgExp
				// token labels: 
				// rule labels: msgExp, retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_msgExp=new RewriteRuleSubtreeStream(adaptor,"rule msgExp",msgExp!=null?msgExp.Tree:null);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 81:3: -> ^( INV[$i] ( SimpleName )? oclExpression ( MESSAGE[$m] $msgExp)? )
				{
					DebugLocation(81, 6);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:81:6: ^( INV[$i] ( SimpleName )? oclExpression ( MESSAGE[$m] $msgExp)? )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(81, 8);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(INV, i), root_1);

					DebugLocation(81, 16);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:81:16: ( SimpleName )?
					if (stream_SimpleName.HasNext)
					{
						DebugLocation(81, 16);
						adaptor.AddChild(root_1, stream_SimpleName.NextNode());

					}
					stream_SimpleName.Reset();
					DebugLocation(81, 28);
					adaptor.AddChild(root_1, stream_oclExpression.NextTree());
					DebugLocation(81, 42);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:81:42: ( MESSAGE[$m] $msgExp)?
					if (stream_msgExp.HasNext)
					{
						DebugLocation(81, 43);
						adaptor.AddChild(root_1, (object)adaptor.Create(MESSAGE, m));
						DebugLocation(81, 56);
						adaptor.AddChild(root_1, stream_msgExp.NextTree());

					}
					stream_msgExp.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:82:4: ( 'static' )? d= 'def' ( SimpleName )? ':' defExpression
				{
				DebugLocation(82, 4);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:82:4: ( 'static' )?
				int alt13=2;
				try { DebugEnterSubRule(13);
				try { DebugEnterDecision(13, false);
				int LA13_0 = input.LA(1);

				if ((LA13_0==123))
				{
					alt13 = 1;
				}
				} finally { DebugExitDecision(13); }
				switch (alt13)
				{
				case 1:
					DebugEnterAlt(1);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:82:4: 'static'
					{
					DebugLocation(82, 4);
					string_literal39=(CommonToken)Match(input,123,Follow._123_in_invOrDef553); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_123.Add(string_literal39);


					}
					break;

				}
				} finally { DebugExitSubRule(13); }

				DebugLocation(82, 15);
				d=(CommonToken)Match(input,104,Follow._104_in_invOrDef558); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_104.Add(d);

				DebugLocation(82, 22);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:82:22: ( SimpleName )?
				int alt14=2;
				try { DebugEnterSubRule(14);
				try { DebugEnterDecision(14, false);
				int LA14_0 = input.LA(1);

				if ((LA14_0==SimpleName))
				{
					alt14 = 1;
				}
				} finally { DebugExitDecision(14); }
				switch (alt14)
				{
				case 1:
					DebugEnterAlt(1);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:82:22: SimpleName
					{
					DebugLocation(82, 22);
					SimpleName40=(CommonToken)Match(input,SimpleName,Follow._SimpleName_in_invOrDef560); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_SimpleName.Add(SimpleName40);


					}
					break;

				}
				} finally { DebugExitSubRule(14); }

				DebugLocation(82, 34);
				char_literal41=(CommonToken)Match(input,71,Follow._71_in_invOrDef563); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_71.Add(char_literal41);

				DebugLocation(82, 38);
				PushFollow(Follow._defExpression_in_invOrDef565);
				defExpression42=defExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_defExpression.Add(defExpression42.Tree);


				{
				// AST REWRITE
				// elements: 123, SimpleName, defExpression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 83:3: -> ^( DEF[$d] ( 'static' )? ( SimpleName )? defExpression )
				{
					DebugLocation(83, 6);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:83:6: ^( DEF[$d] ( 'static' )? ( SimpleName )? defExpression )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(83, 8);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(DEF, d), root_1);

					DebugLocation(83, 16);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:83:16: ( 'static' )?
					if (stream_123.HasNext)
					{
						DebugLocation(83, 16);
						adaptor.AddChild(root_1, stream_123.NextNode());

					}
					stream_123.Reset();
					DebugLocation(83, 26);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:83:26: ( SimpleName )?
					if (stream_SimpleName.HasNext)
					{
						DebugLocation(83, 26);
						adaptor.AddChild(root_1, stream_SimpleName.NextNode());

					}
					stream_SimpleName.Reset();
					DebugLocation(83, 38);
					adaptor.AddChild(root_1, stream_defExpression.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("invOrDef", 12);
			LeaveRule("invOrDef", 12);
			LeaveRule_invOrDef();
		}
		DebugLocation(85, 1);
		} finally { DebugExitRule(GrammarFileName, "invOrDef"); }
		return retval;

	}
	// $ANTLR end "invOrDef"

	private sealed partial class prePostOrBodyDecl_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public prePostOrBodyDecl_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_prePostOrBodyDecl();
	partial void LeaveRule_prePostOrBodyDecl();

	// $ANTLR start "prePostOrBodyDecl"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:87:1: prePostOrBodyDecl : (h= 'pre' ( SimpleName )? ':' oclExpression -> ^( PRE[h] ( SimpleName )? oclExpression ) |h= 'post' ( SimpleName )? ':' oclExpression -> ^( POST[h] ( SimpleName )? oclExpression ) |h= 'body' ( SimpleName )? ':' oclExpression -> ^( BODY[h] ( SimpleName )? oclExpression ) );
	[GrammarRule("prePostOrBodyDecl")]
	private OCLSyntaxParser.prePostOrBodyDecl_return prePostOrBodyDecl()
	{
		EnterRule_prePostOrBodyDecl();
		EnterRule("prePostOrBodyDecl", 13);
		TraceIn("prePostOrBodyDecl", 13);
		OCLSyntaxParser.prePostOrBodyDecl_return retval = new OCLSyntaxParser.prePostOrBodyDecl_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		CommonToken h = default(CommonToken);
		CommonToken SimpleName43 = default(CommonToken);
		CommonToken char_literal44 = default(CommonToken);
		CommonToken SimpleName46 = default(CommonToken);
		CommonToken char_literal47 = default(CommonToken);
		CommonToken SimpleName49 = default(CommonToken);
		CommonToken char_literal50 = default(CommonToken);
		OCLSyntaxParser.oclExpression_return oclExpression45 = default(OCLSyntaxParser.oclExpression_return);
		OCLSyntaxParser.oclExpression_return oclExpression48 = default(OCLSyntaxParser.oclExpression_return);
		OCLSyntaxParser.oclExpression_return oclExpression51 = default(OCLSyntaxParser.oclExpression_return);

		object h_tree = default(object);
		object SimpleName43_tree = default(object);
		object char_literal44_tree = default(object);
		object SimpleName46_tree = default(object);
		object char_literal47_tree = default(object);
		object SimpleName49_tree = default(object);
		object char_literal50_tree = default(object);
		RewriteRuleITokenStream stream_121=new RewriteRuleITokenStream(adaptor,"token 121");
		RewriteRuleITokenStream stream_SimpleName=new RewriteRuleITokenStream(adaptor,"token SimpleName");
		RewriteRuleITokenStream stream_71=new RewriteRuleITokenStream(adaptor,"token 71");
		RewriteRuleITokenStream stream_120=new RewriteRuleITokenStream(adaptor,"token 120");
		RewriteRuleITokenStream stream_102=new RewriteRuleITokenStream(adaptor,"token 102");
		RewriteRuleSubtreeStream stream_oclExpression=new RewriteRuleSubtreeStream(adaptor,"rule oclExpression");
		try { DebugEnterRule(GrammarFileName, "prePostOrBodyDecl");
		DebugLocation(87, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:88:2: (h= 'pre' ( SimpleName )? ':' oclExpression -> ^( PRE[h] ( SimpleName )? oclExpression ) |h= 'post' ( SimpleName )? ':' oclExpression -> ^( POST[h] ( SimpleName )? oclExpression ) |h= 'body' ( SimpleName )? ':' oclExpression -> ^( BODY[h] ( SimpleName )? oclExpression ) )
			int alt19=3;
			try { DebugEnterDecision(19, false);
			switch (input.LA(1))
			{
			case 121:
				{
				alt19 = 1;
				}
				break;
			case 120:
				{
				alt19 = 2;
				}
				break;
			case 102:
				{
				alt19 = 3;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 19, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(19); }
			switch (alt19)
			{
			case 1:
				DebugEnterAlt(1);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:88:3: h= 'pre' ( SimpleName )? ':' oclExpression
				{
				DebugLocation(88, 4);
				h=(CommonToken)Match(input,121,Follow._121_in_prePostOrBodyDecl596); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_121.Add(h);

				DebugLocation(88, 11);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:88:11: ( SimpleName )?
				int alt16=2;
				try { DebugEnterSubRule(16);
				try { DebugEnterDecision(16, false);
				int LA16_0 = input.LA(1);

				if ((LA16_0==SimpleName))
				{
					alt16 = 1;
				}
				} finally { DebugExitDecision(16); }
				switch (alt16)
				{
				case 1:
					DebugEnterAlt(1);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:88:12: SimpleName
					{
					DebugLocation(88, 12);
					SimpleName43=(CommonToken)Match(input,SimpleName,Follow._SimpleName_in_prePostOrBodyDecl599); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_SimpleName.Add(SimpleName43);


					}
					break;

				}
				} finally { DebugExitSubRule(16); }

				DebugLocation(88, 25);
				char_literal44=(CommonToken)Match(input,71,Follow._71_in_prePostOrBodyDecl603); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_71.Add(char_literal44);

				DebugLocation(88, 29);
				PushFollow(Follow._oclExpression_in_prePostOrBodyDecl605);
				oclExpression45=oclExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_oclExpression.Add(oclExpression45.Tree);


				{
				// AST REWRITE
				// elements: SimpleName, oclExpression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 88:43: -> ^( PRE[h] ( SimpleName )? oclExpression )
				{
					DebugLocation(88, 45);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:88:45: ^( PRE[h] ( SimpleName )? oclExpression )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(88, 47);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(PRE, h), root_1);

					DebugLocation(88, 54);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:88:54: ( SimpleName )?
					if (stream_SimpleName.HasNext)
					{
						DebugLocation(88, 54);
						adaptor.AddChild(root_1, stream_SimpleName.NextNode());

					}
					stream_SimpleName.Reset();
					DebugLocation(88, 66);
					adaptor.AddChild(root_1, stream_oclExpression.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:89:3: h= 'post' ( SimpleName )? ':' oclExpression
				{
				DebugLocation(89, 4);
				h=(CommonToken)Match(input,120,Follow._120_in_prePostOrBodyDecl622); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_120.Add(h);

				DebugLocation(89, 12);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:89:12: ( SimpleName )?
				int alt17=2;
				try { DebugEnterSubRule(17);
				try { DebugEnterDecision(17, false);
				int LA17_0 = input.LA(1);

				if ((LA17_0==SimpleName))
				{
					alt17 = 1;
				}
				} finally { DebugExitDecision(17); }
				switch (alt17)
				{
				case 1:
					DebugEnterAlt(1);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:89:13: SimpleName
					{
					DebugLocation(89, 13);
					SimpleName46=(CommonToken)Match(input,SimpleName,Follow._SimpleName_in_prePostOrBodyDecl625); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_SimpleName.Add(SimpleName46);


					}
					break;

				}
				} finally { DebugExitSubRule(17); }

				DebugLocation(89, 26);
				char_literal47=(CommonToken)Match(input,71,Follow._71_in_prePostOrBodyDecl629); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_71.Add(char_literal47);

				DebugLocation(89, 30);
				PushFollow(Follow._oclExpression_in_prePostOrBodyDecl631);
				oclExpression48=oclExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_oclExpression.Add(oclExpression48.Tree);


				{
				// AST REWRITE
				// elements: SimpleName, oclExpression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 89:44: -> ^( POST[h] ( SimpleName )? oclExpression )
				{
					DebugLocation(89, 46);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:89:46: ^( POST[h] ( SimpleName )? oclExpression )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(89, 48);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(POST, h), root_1);

					DebugLocation(89, 56);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:89:56: ( SimpleName )?
					if (stream_SimpleName.HasNext)
					{
						DebugLocation(89, 56);
						adaptor.AddChild(root_1, stream_SimpleName.NextNode());

					}
					stream_SimpleName.Reset();
					DebugLocation(89, 68);
					adaptor.AddChild(root_1, stream_oclExpression.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:90:3: h= 'body' ( SimpleName )? ':' oclExpression
				{
				DebugLocation(90, 4);
				h=(CommonToken)Match(input,102,Follow._102_in_prePostOrBodyDecl648); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_102.Add(h);

				DebugLocation(90, 12);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:90:12: ( SimpleName )?
				int alt18=2;
				try { DebugEnterSubRule(18);
				try { DebugEnterDecision(18, false);
				int LA18_0 = input.LA(1);

				if ((LA18_0==SimpleName))
				{
					alt18 = 1;
				}
				} finally { DebugExitDecision(18); }
				switch (alt18)
				{
				case 1:
					DebugEnterAlt(1);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:90:13: SimpleName
					{
					DebugLocation(90, 13);
					SimpleName49=(CommonToken)Match(input,SimpleName,Follow._SimpleName_in_prePostOrBodyDecl651); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_SimpleName.Add(SimpleName49);


					}
					break;

				}
				} finally { DebugExitSubRule(18); }

				DebugLocation(90, 26);
				char_literal50=(CommonToken)Match(input,71,Follow._71_in_prePostOrBodyDecl655); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_71.Add(char_literal50);

				DebugLocation(90, 30);
				PushFollow(Follow._oclExpression_in_prePostOrBodyDecl657);
				oclExpression51=oclExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_oclExpression.Add(oclExpression51.Tree);


				{
				// AST REWRITE
				// elements: SimpleName, oclExpression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 90:44: -> ^( BODY[h] ( SimpleName )? oclExpression )
				{
					DebugLocation(90, 46);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:90:46: ^( BODY[h] ( SimpleName )? oclExpression )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(90, 48);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(BODY, h), root_1);

					DebugLocation(90, 56);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:90:56: ( SimpleName )?
					if (stream_SimpleName.HasNext)
					{
						DebugLocation(90, 56);
						adaptor.AddChild(root_1, stream_SimpleName.NextNode());

					}
					stream_SimpleName.Reset();
					DebugLocation(90, 68);
					adaptor.AddChild(root_1, stream_oclExpression.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("prePostOrBodyDecl", 13);
			LeaveRule("prePostOrBodyDecl", 13);
			LeaveRule_prePostOrBodyDecl();
		}
		DebugLocation(91, 1);
		} finally { DebugExitRule(GrammarFileName, "prePostOrBodyDecl"); }
		return retval;

	}
	// $ANTLR end "prePostOrBodyDecl"

	private sealed partial class operation_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public operation_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_operation();
	partial void LeaveRule_operation();

	// $ANTLR start "operation"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:94:1: operation : pathName '(' ( parameters )? ')' ( ':' type )? -> ^( OPERATION pathName ( parameters )? ( type )? ) ;
	[GrammarRule("operation")]
	private OCLSyntaxParser.operation_return operation()
	{
		EnterRule_operation();
		EnterRule("operation", 14);
		TraceIn("operation", 14);
		OCLSyntaxParser.operation_return retval = new OCLSyntaxParser.operation_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		CommonToken char_literal53 = default(CommonToken);
		CommonToken char_literal55 = default(CommonToken);
		CommonToken char_literal56 = default(CommonToken);
		OCLSyntaxParser.pathName_return pathName52 = default(OCLSyntaxParser.pathName_return);
		OCLSyntaxParser.parameters_return parameters54 = default(OCLSyntaxParser.parameters_return);
		OCLSyntaxParser.type_return type57 = default(OCLSyntaxParser.type_return);

		object char_literal53_tree = default(object);
		object char_literal55_tree = default(object);
		object char_literal56_tree = default(object);
		RewriteRuleITokenStream stream_63=new RewriteRuleITokenStream(adaptor,"token 63");
		RewriteRuleITokenStream stream_64=new RewriteRuleITokenStream(adaptor,"token 64");
		RewriteRuleITokenStream stream_71=new RewriteRuleITokenStream(adaptor,"token 71");
		RewriteRuleSubtreeStream stream_pathName=new RewriteRuleSubtreeStream(adaptor,"rule pathName");
		RewriteRuleSubtreeStream stream_parameters=new RewriteRuleSubtreeStream(adaptor,"rule parameters");
		RewriteRuleSubtreeStream stream_type=new RewriteRuleSubtreeStream(adaptor,"rule type");
		try { DebugEnterRule(GrammarFileName, "operation");
		DebugLocation(94, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:95:2: ( pathName '(' ( parameters )? ')' ( ':' type )? -> ^( OPERATION pathName ( parameters )? ( type )? ) )
			DebugEnterAlt(1);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:95:3: pathName '(' ( parameters )? ')' ( ':' type )?
			{
			DebugLocation(95, 3);
			PushFollow(Follow._pathName_in_operation679);
			pathName52=pathName();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_pathName.Add(pathName52.Tree);
			DebugLocation(95, 32);
			char_literal53=(CommonToken)Match(input,63,Follow._63_in_operation683); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_63.Add(char_literal53);

			DebugLocation(95, 36);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:95:36: ( parameters )?
			int alt20=2;
			try { DebugEnterSubRule(20);
			try { DebugEnterDecision(20, false);
			int LA20_0 = input.LA(1);

			if ((LA20_0==SimpleName))
			{
				alt20 = 1;
			}
			} finally { DebugExitDecision(20); }
			switch (alt20)
			{
			case 1:
				DebugEnterAlt(1);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:95:36: parameters
				{
				DebugLocation(95, 36);
				PushFollow(Follow._parameters_in_operation685);
				parameters54=parameters();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_parameters.Add(parameters54.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(20); }

			DebugLocation(95, 48);
			char_literal55=(CommonToken)Match(input,64,Follow._64_in_operation688); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_64.Add(char_literal55);

			DebugLocation(95, 52);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:95:52: ( ':' type )?
			int alt21=2;
			try { DebugEnterSubRule(21);
			try { DebugEnterDecision(21, false);
			int LA21_0 = input.LA(1);

			if ((LA21_0==71))
			{
				alt21 = 1;
			}
			} finally { DebugExitDecision(21); }
			switch (alt21)
			{
			case 1:
				DebugEnterAlt(1);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:95:53: ':' type
				{
				DebugLocation(95, 53);
				char_literal56=(CommonToken)Match(input,71,Follow._71_in_operation691); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_71.Add(char_literal56);

				DebugLocation(95, 57);
				PushFollow(Follow._type_in_operation693);
				type57=type();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_type.Add(type57.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(21); }



			{
			// AST REWRITE
			// elements: pathName, parameters, type
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 96:3: -> ^( OPERATION pathName ( parameters )? ( type )? )
			{
				DebugLocation(96, 6);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:96:6: ^( OPERATION pathName ( parameters )? ( type )? )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(96, 8);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(OPERATION, "OPERATION"), root_1);

				DebugLocation(96, 18);
				adaptor.AddChild(root_1, stream_pathName.NextTree());
				DebugLocation(96, 27);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:96:27: ( parameters )?
				if (stream_parameters.HasNext)
				{
					DebugLocation(96, 27);
					adaptor.AddChild(root_1, stream_parameters.NextTree());

				}
				stream_parameters.Reset();
				DebugLocation(96, 39);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:96:39: ( type )?
				if (stream_type.HasNext)
				{
					DebugLocation(96, 39);
					adaptor.AddChild(root_1, stream_type.NextTree());

				}
				stream_type.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("operation", 14);
			LeaveRule("operation", 14);
			LeaveRule_operation();
		}
		DebugLocation(97, 1);
		} finally { DebugExitRule(GrammarFileName, "operation"); }
		return retval;

	}
	// $ANTLR end "operation"

	private sealed partial class parameters_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public parameters_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_parameters();
	partial void LeaveRule_parameters();

	// $ANTLR start "parameters"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:99:1: parameters : variableDeclarationList[VariableDeclarationRequirement.OperationContext] ;
	[GrammarRule("parameters")]
	private OCLSyntaxParser.parameters_return parameters()
	{
		EnterRule_parameters();
		EnterRule("parameters", 15);
		TraceIn("parameters", 15);
		OCLSyntaxParser.parameters_return retval = new OCLSyntaxParser.parameters_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		OCLSyntaxParser.variableDeclarationList_return variableDeclarationList58 = default(OCLSyntaxParser.variableDeclarationList_return);


		try { DebugEnterRule(GrammarFileName, "parameters");
		DebugLocation(99, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:100:2: ( variableDeclarationList[VariableDeclarationRequirement.OperationContext] )
			DebugEnterAlt(1);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:100:3: variableDeclarationList[VariableDeclarationRequirement.OperationContext]
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(100, 3);
			PushFollow(Follow._variableDeclarationList_in_parameters721);
			variableDeclarationList58=variableDeclarationList(VariableDeclarationRequirement.OperationContext);
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, variableDeclarationList58.Tree);

			}

			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("parameters", 15);
			LeaveRule("parameters", 15);
			LeaveRule_parameters();
		}
		DebugLocation(101, 1);
		} finally { DebugExitRule(GrammarFileName, "parameters"); }
		return retval;

	}
	// $ANTLR end "parameters"

	private sealed partial class defExpression_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public defExpression_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_defExpression();
	partial void LeaveRule_defExpression();

	// $ANTLR start "defExpression"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:103:1: defExpression : ( variableDeclaration[VariableDeclarationRequirement.Def] | operation '=' oclExpression -> ^( DECL operation oclExpression ) );
	[GrammarRule("defExpression")]
	private OCLSyntaxParser.defExpression_return defExpression()
	{
		EnterRule_defExpression();
		EnterRule("defExpression", 16);
		TraceIn("defExpression", 16);
		OCLSyntaxParser.defExpression_return retval = new OCLSyntaxParser.defExpression_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		CommonToken char_literal61 = default(CommonToken);
		OCLSyntaxParser.variableDeclaration_return variableDeclaration59 = default(OCLSyntaxParser.variableDeclaration_return);
		OCLSyntaxParser.operation_return operation60 = default(OCLSyntaxParser.operation_return);
		OCLSyntaxParser.oclExpression_return oclExpression62 = default(OCLSyntaxParser.oclExpression_return);

		object char_literal61_tree = default(object);
		RewriteRuleITokenStream stream_77=new RewriteRuleITokenStream(adaptor,"token 77");
		RewriteRuleSubtreeStream stream_operation=new RewriteRuleSubtreeStream(adaptor,"rule operation");
		RewriteRuleSubtreeStream stream_oclExpression=new RewriteRuleSubtreeStream(adaptor,"rule oclExpression");
		try { DebugEnterRule(GrammarFileName, "defExpression");
		DebugLocation(103, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:104:2: ( variableDeclaration[VariableDeclarationRequirement.Def] | operation '=' oclExpression -> ^( DECL operation oclExpression ) )
			int alt22=2;
			try { DebugEnterDecision(22, false);
			int LA22_0 = input.LA(1);

			if ((LA22_0==SimpleName))
			{
				int LA22_1 = input.LA(2);

				if ((LA22_1==71||LA22_1==77))
				{
					alt22 = 1;
				}
				else if ((LA22_1==63||LA22_1==72))
				{
					alt22 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 22, 1, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 22, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(22); }
			switch (alt22)
			{
			case 1:
				DebugEnterAlt(1);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:104:4: variableDeclaration[VariableDeclarationRequirement.Def]
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(104, 4);
				PushFollow(Follow._variableDeclaration_in_defExpression734);
				variableDeclaration59=variableDeclaration(VariableDeclarationRequirement.Def);
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, variableDeclaration59.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:105:4: operation '=' oclExpression
				{
				DebugLocation(105, 4);
				PushFollow(Follow._operation_in_defExpression740);
				operation60=operation();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_operation.Add(operation60.Tree);
				DebugLocation(105, 14);
				char_literal61=(CommonToken)Match(input,77,Follow._77_in_defExpression742); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_77.Add(char_literal61);

				DebugLocation(105, 18);
				PushFollow(Follow._oclExpression_in_defExpression744);
				oclExpression62=oclExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_oclExpression.Add(oclExpression62.Tree);


				{
				// AST REWRITE
				// elements: operation, oclExpression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 106:3: -> ^( DECL operation oclExpression )
				{
					DebugLocation(106, 5);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:106:5: ^( DECL operation oclExpression )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(106, 7);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(DECL, "DECL"), root_1);

					DebugLocation(106, 12);
					adaptor.AddChild(root_1, stream_operation.NextTree());
					DebugLocation(106, 22);
					adaptor.AddChild(root_1, stream_oclExpression.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("defExpression", 16);
			LeaveRule("defExpression", 16);
			LeaveRule_defExpression();
		}
		DebugLocation(107, 1);
		} finally { DebugExitRule(GrammarFileName, "defExpression"); }
		return retval;

	}
	// $ANTLR end "defExpression"

	public sealed partial class oclExpression_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public oclExpression_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_oclExpression();
	partial void LeaveRule_oclExpression();

	// $ANTLR start "oclExpression"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:110:1: public oclExpression : logicalImpliesExpression ;
	[GrammarRule("oclExpression")]
	public OCLSyntaxParser.oclExpression_return oclExpression()
	{
		EnterRule_oclExpression();
		EnterRule("oclExpression", 17);
		TraceIn("oclExpression", 17);
		OCLSyntaxParser.oclExpression_return retval = new OCLSyntaxParser.oclExpression_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		OCLSyntaxParser.logicalImpliesExpression_return logicalImpliesExpression63 = default(OCLSyntaxParser.logicalImpliesExpression_return);


		try { DebugEnterRule(GrammarFileName, "oclExpression");
		DebugLocation(110, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:111:2: ( logicalImpliesExpression )
			DebugEnterAlt(1);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:111:3: logicalImpliesExpression
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(111, 3);
			PushFollow(Follow._logicalImpliesExpression_in_oclExpression768);
			logicalImpliesExpression63=logicalImpliesExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, logicalImpliesExpression63.Tree);

			}

			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("oclExpression", 17);
			LeaveRule("oclExpression", 17);
			LeaveRule_oclExpression();
		}
		DebugLocation(113, 1);
		} finally { DebugExitRule(GrammarFileName, "oclExpression"); }
		return retval;

	}
	// $ANTLR end "oclExpression"

	private sealed partial class logicalImpliesExpression_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public logicalImpliesExpression_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_logicalImpliesExpression();
	partial void LeaveRule_logicalImpliesExpression();

	// $ANTLR start "logicalImpliesExpression"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:115:1: logicalImpliesExpression : ( logicalXorExpression -> logicalXorExpression ) (opToken= 'implies' expr= logicalXorExpression -> ^( INFIX[$opToken] $logicalImpliesExpression $expr) )* ;
	[GrammarRule("logicalImpliesExpression")]
	private OCLSyntaxParser.logicalImpliesExpression_return logicalImpliesExpression()
	{
		EnterRule_logicalImpliesExpression();
		EnterRule("logicalImpliesExpression", 18);
		TraceIn("logicalImpliesExpression", 18);
		OCLSyntaxParser.logicalImpliesExpression_return retval = new OCLSyntaxParser.logicalImpliesExpression_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		CommonToken opToken = default(CommonToken);
		OCLSyntaxParser.logicalXorExpression_return expr = default(OCLSyntaxParser.logicalXorExpression_return);
		OCLSyntaxParser.logicalXorExpression_return logicalXorExpression64 = default(OCLSyntaxParser.logicalXorExpression_return);

		object opToken_tree = default(object);
		RewriteRuleITokenStream stream_110=new RewriteRuleITokenStream(adaptor,"token 110");
		RewriteRuleSubtreeStream stream_logicalXorExpression=new RewriteRuleSubtreeStream(adaptor,"rule logicalXorExpression");
		try { DebugEnterRule(GrammarFileName, "logicalImpliesExpression");
		DebugLocation(115, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:116:2: ( ( logicalXorExpression -> logicalXorExpression ) (opToken= 'implies' expr= logicalXorExpression -> ^( INFIX[$opToken] $logicalImpliesExpression $expr) )* )
			DebugEnterAlt(1);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:116:4: ( logicalXorExpression -> logicalXorExpression ) (opToken= 'implies' expr= logicalXorExpression -> ^( INFIX[$opToken] $logicalImpliesExpression $expr) )*
			{
			DebugLocation(116, 4);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:116:4: ( logicalXorExpression -> logicalXorExpression )
			DebugEnterAlt(1);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:116:5: logicalXorExpression
			{
			DebugLocation(116, 5);
			PushFollow(Follow._logicalXorExpression_in_logicalImpliesExpression784);
			logicalXorExpression64=logicalXorExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_logicalXorExpression.Add(logicalXorExpression64.Tree);


			{
			// AST REWRITE
			// elements: logicalXorExpression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 116:25: -> logicalXorExpression
			{
				DebugLocation(116, 27);
				adaptor.AddChild(root_0, stream_logicalXorExpression.NextTree());

			}

			retval.Tree = root_0;
			}
			}

			}

			DebugLocation(116, 50);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:116:50: (opToken= 'implies' expr= logicalXorExpression -> ^( INFIX[$opToken] $logicalImpliesExpression $expr) )*
			try { DebugEnterSubRule(23);
			while (true)
			{
				int alt23=2;
				try { DebugEnterDecision(23, false);
				int LA23_0 = input.LA(1);

				if ((LA23_0==110))
				{
					alt23 = 1;
				}


				} finally { DebugExitDecision(23); }
				switch ( alt23 )
				{
				case 1:
					DebugEnterAlt(1);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:116:51: opToken= 'implies' expr= logicalXorExpression
					{
					DebugLocation(116, 58);
					opToken=(CommonToken)Match(input,110,Follow._110_in_logicalImpliesExpression793); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_110.Add(opToken);

					DebugLocation(116, 73);
					PushFollow(Follow._logicalXorExpression_in_logicalImpliesExpression797);
					expr=logicalXorExpression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_logicalXorExpression.Add(expr.Tree);


					{
					// AST REWRITE
					// elements: logicalImpliesExpression, expr
					// token labels: 
					// rule labels: expr, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if (state.backtracking == 0) {
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_expr=new RewriteRuleSubtreeStream(adaptor,"rule expr",expr!=null?expr.Tree:null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (object)adaptor.Nil();
					// 116:94: -> ^( INFIX[$opToken] $logicalImpliesExpression $expr)
					{
						DebugLocation(116, 96);
						// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:116:96: ^( INFIX[$opToken] $logicalImpliesExpression $expr)
						{
						object root_1 = (object)adaptor.Nil();
						DebugLocation(116, 98);
						root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(INFIX, opToken), root_1);

						DebugLocation(116, 115);
						adaptor.AddChild(root_1, stream_retval.NextTree());
						DebugLocation(116, 141);
						adaptor.AddChild(root_1, stream_expr.NextTree());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}
					}

					}
					break;

				default:
					goto loop23;
				}
			}

			loop23:
				;

			} finally { DebugExitSubRule(23); }


			}

			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("logicalImpliesExpression", 18);
			LeaveRule("logicalImpliesExpression", 18);
			LeaveRule_logicalImpliesExpression();
		}
		DebugLocation(117, 1);
		} finally { DebugExitRule(GrammarFileName, "logicalImpliesExpression"); }
		return retval;

	}
	// $ANTLR end "logicalImpliesExpression"

	private sealed partial class logicalXorExpression_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public logicalXorExpression_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_logicalXorExpression();
	partial void LeaveRule_logicalXorExpression();

	// $ANTLR start "logicalXorExpression"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:118:1: logicalXorExpression : ( logicalOrExpression -> logicalOrExpression ) (opToken= 'xor' expr= logicalOrExpression -> ^( INFIX[$opToken] $logicalXorExpression $expr) )* ;
	[GrammarRule("logicalXorExpression")]
	private OCLSyntaxParser.logicalXorExpression_return logicalXorExpression()
	{
		EnterRule_logicalXorExpression();
		EnterRule("logicalXorExpression", 19);
		TraceIn("logicalXorExpression", 19);
		OCLSyntaxParser.logicalXorExpression_return retval = new OCLSyntaxParser.logicalXorExpression_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		CommonToken opToken = default(CommonToken);
		OCLSyntaxParser.logicalOrExpression_return expr = default(OCLSyntaxParser.logicalOrExpression_return);
		OCLSyntaxParser.logicalOrExpression_return logicalOrExpression65 = default(OCLSyntaxParser.logicalOrExpression_return);

		object opToken_tree = default(object);
		RewriteRuleITokenStream stream_126=new RewriteRuleITokenStream(adaptor,"token 126");
		RewriteRuleSubtreeStream stream_logicalOrExpression=new RewriteRuleSubtreeStream(adaptor,"rule logicalOrExpression");
		try { DebugEnterRule(GrammarFileName, "logicalXorExpression");
		DebugLocation(118, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:119:2: ( ( logicalOrExpression -> logicalOrExpression ) (opToken= 'xor' expr= logicalOrExpression -> ^( INFIX[$opToken] $logicalXorExpression $expr) )* )
			DebugEnterAlt(1);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:119:4: ( logicalOrExpression -> logicalOrExpression ) (opToken= 'xor' expr= logicalOrExpression -> ^( INFIX[$opToken] $logicalXorExpression $expr) )*
			{
			DebugLocation(119, 4);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:119:4: ( logicalOrExpression -> logicalOrExpression )
			DebugEnterAlt(1);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:119:5: logicalOrExpression
			{
			DebugLocation(119, 5);
			PushFollow(Follow._logicalOrExpression_in_logicalXorExpression822);
			logicalOrExpression65=logicalOrExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_logicalOrExpression.Add(logicalOrExpression65.Tree);


			{
			// AST REWRITE
			// elements: logicalOrExpression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 119:24: -> logicalOrExpression
			{
				DebugLocation(119, 26);
				adaptor.AddChild(root_0, stream_logicalOrExpression.NextTree());

			}

			retval.Tree = root_0;
			}
			}

			}

			DebugLocation(119, 47);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:119:47: (opToken= 'xor' expr= logicalOrExpression -> ^( INFIX[$opToken] $logicalXorExpression $expr) )*
			try { DebugEnterSubRule(24);
			while (true)
			{
				int alt24=2;
				try { DebugEnterDecision(24, false);
				int LA24_0 = input.LA(1);

				if ((LA24_0==126))
				{
					alt24 = 1;
				}


				} finally { DebugExitDecision(24); }
				switch ( alt24 )
				{
				case 1:
					DebugEnterAlt(1);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:119:48: opToken= 'xor' expr= logicalOrExpression
					{
					DebugLocation(119, 55);
					opToken=(CommonToken)Match(input,126,Follow._126_in_logicalXorExpression830); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_126.Add(opToken);

					DebugLocation(119, 66);
					PushFollow(Follow._logicalOrExpression_in_logicalXorExpression834);
					expr=logicalOrExpression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_logicalOrExpression.Add(expr.Tree);


					{
					// AST REWRITE
					// elements: logicalXorExpression, expr
					// token labels: 
					// rule labels: expr, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if (state.backtracking == 0) {
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_expr=new RewriteRuleSubtreeStream(adaptor,"rule expr",expr!=null?expr.Tree:null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (object)adaptor.Nil();
					// 119:86: -> ^( INFIX[$opToken] $logicalXorExpression $expr)
					{
						DebugLocation(119, 88);
						// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:119:88: ^( INFIX[$opToken] $logicalXorExpression $expr)
						{
						object root_1 = (object)adaptor.Nil();
						DebugLocation(119, 90);
						root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(INFIX, opToken), root_1);

						DebugLocation(119, 107);
						adaptor.AddChild(root_1, stream_retval.NextTree());
						DebugLocation(119, 129);
						adaptor.AddChild(root_1, stream_expr.NextTree());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}
					}

					}
					break;

				default:
					goto loop24;
				}
			}

			loop24:
				;

			} finally { DebugExitSubRule(24); }


			}

			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("logicalXorExpression", 19);
			LeaveRule("logicalXorExpression", 19);
			LeaveRule_logicalXorExpression();
		}
		DebugLocation(120, 1);
		} finally { DebugExitRule(GrammarFileName, "logicalXorExpression"); }
		return retval;

	}
	// $ANTLR end "logicalXorExpression"

	private sealed partial class logicalOrExpression_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public logicalOrExpression_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_logicalOrExpression();
	partial void LeaveRule_logicalOrExpression();

	// $ANTLR start "logicalOrExpression"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:121:1: logicalOrExpression : ( logicalAndExpression -> logicalAndExpression ) (opToken= 'or' expr= logicalAndExpression -> ^( INFIX[$opToken] $logicalOrExpression $expr) )* ;
	[GrammarRule("logicalOrExpression")]
	private OCLSyntaxParser.logicalOrExpression_return logicalOrExpression()
	{
		EnterRule_logicalOrExpression();
		EnterRule("logicalOrExpression", 20);
		TraceIn("logicalOrExpression", 20);
		OCLSyntaxParser.logicalOrExpression_return retval = new OCLSyntaxParser.logicalOrExpression_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		CommonToken opToken = default(CommonToken);
		OCLSyntaxParser.logicalAndExpression_return expr = default(OCLSyntaxParser.logicalAndExpression_return);
		OCLSyntaxParser.logicalAndExpression_return logicalAndExpression66 = default(OCLSyntaxParser.logicalAndExpression_return);

		object opToken_tree = default(object);
		RewriteRuleITokenStream stream_119=new RewriteRuleITokenStream(adaptor,"token 119");
		RewriteRuleSubtreeStream stream_logicalAndExpression=new RewriteRuleSubtreeStream(adaptor,"rule logicalAndExpression");
		try { DebugEnterRule(GrammarFileName, "logicalOrExpression");
		DebugLocation(121, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:122:2: ( ( logicalAndExpression -> logicalAndExpression ) (opToken= 'or' expr= logicalAndExpression -> ^( INFIX[$opToken] $logicalOrExpression $expr) )* )
			DebugEnterAlt(1);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:122:4: ( logicalAndExpression -> logicalAndExpression ) (opToken= 'or' expr= logicalAndExpression -> ^( INFIX[$opToken] $logicalOrExpression $expr) )*
			{
			DebugLocation(122, 4);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:122:4: ( logicalAndExpression -> logicalAndExpression )
			DebugEnterAlt(1);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:122:5: logicalAndExpression
			{
			DebugLocation(122, 5);
			PushFollow(Follow._logicalAndExpression_in_logicalOrExpression858);
			logicalAndExpression66=logicalAndExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_logicalAndExpression.Add(logicalAndExpression66.Tree);


			{
			// AST REWRITE
			// elements: logicalAndExpression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 122:25: -> logicalAndExpression
			{
				DebugLocation(122, 27);
				adaptor.AddChild(root_0, stream_logicalAndExpression.NextTree());

			}

			retval.Tree = root_0;
			}
			}

			}

			DebugLocation(122, 49);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:122:49: (opToken= 'or' expr= logicalAndExpression -> ^( INFIX[$opToken] $logicalOrExpression $expr) )*
			try { DebugEnterSubRule(25);
			while (true)
			{
				int alt25=2;
				try { DebugEnterDecision(25, false);
				int LA25_0 = input.LA(1);

				if ((LA25_0==119))
				{
					alt25 = 1;
				}


				} finally { DebugExitDecision(25); }
				switch ( alt25 )
				{
				case 1:
					DebugEnterAlt(1);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:122:50: opToken= 'or' expr= logicalAndExpression
					{
					DebugLocation(122, 57);
					opToken=(CommonToken)Match(input,119,Follow._119_in_logicalOrExpression866); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_119.Add(opToken);

					DebugLocation(122, 67);
					PushFollow(Follow._logicalAndExpression_in_logicalOrExpression870);
					expr=logicalAndExpression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_logicalAndExpression.Add(expr.Tree);


					{
					// AST REWRITE
					// elements: logicalOrExpression, expr
					// token labels: 
					// rule labels: expr, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if (state.backtracking == 0) {
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_expr=new RewriteRuleSubtreeStream(adaptor,"rule expr",expr!=null?expr.Tree:null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (object)adaptor.Nil();
					// 122:88: -> ^( INFIX[$opToken] $logicalOrExpression $expr)
					{
						DebugLocation(122, 90);
						// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:122:90: ^( INFIX[$opToken] $logicalOrExpression $expr)
						{
						object root_1 = (object)adaptor.Nil();
						DebugLocation(122, 92);
						root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(INFIX, opToken), root_1);

						DebugLocation(122, 109);
						adaptor.AddChild(root_1, stream_retval.NextTree());
						DebugLocation(122, 130);
						adaptor.AddChild(root_1, stream_expr.NextTree());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}
					}

					}
					break;

				default:
					goto loop25;
				}
			}

			loop25:
				;

			} finally { DebugExitSubRule(25); }


			}

			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("logicalOrExpression", 20);
			LeaveRule("logicalOrExpression", 20);
			LeaveRule_logicalOrExpression();
		}
		DebugLocation(123, 1);
		} finally { DebugExitRule(GrammarFileName, "logicalOrExpression"); }
		return retval;

	}
	// $ANTLR end "logicalOrExpression"

	private sealed partial class logicalAndExpression_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public logicalAndExpression_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_logicalAndExpression();
	partial void LeaveRule_logicalAndExpression();

	// $ANTLR start "logicalAndExpression"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:124:1: logicalAndExpression : ( relationalEqExpression -> relationalEqExpression ) (opToken= 'and' expr= relationalEqExpression -> ^( INFIX[$opToken] $logicalAndExpression $expr) )* ;
	[GrammarRule("logicalAndExpression")]
	private OCLSyntaxParser.logicalAndExpression_return logicalAndExpression()
	{
		EnterRule_logicalAndExpression();
		EnterRule("logicalAndExpression", 21);
		TraceIn("logicalAndExpression", 21);
		OCLSyntaxParser.logicalAndExpression_return retval = new OCLSyntaxParser.logicalAndExpression_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		CommonToken opToken = default(CommonToken);
		OCLSyntaxParser.relationalEqExpression_return expr = default(OCLSyntaxParser.relationalEqExpression_return);
		OCLSyntaxParser.relationalEqExpression_return relationalEqExpression67 = default(OCLSyntaxParser.relationalEqExpression_return);

		object opToken_tree = default(object);
		RewriteRuleITokenStream stream_101=new RewriteRuleITokenStream(adaptor,"token 101");
		RewriteRuleSubtreeStream stream_relationalEqExpression=new RewriteRuleSubtreeStream(adaptor,"rule relationalEqExpression");
		try { DebugEnterRule(GrammarFileName, "logicalAndExpression");
		DebugLocation(124, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:125:2: ( ( relationalEqExpression -> relationalEqExpression ) (opToken= 'and' expr= relationalEqExpression -> ^( INFIX[$opToken] $logicalAndExpression $expr) )* )
			DebugEnterAlt(1);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:125:4: ( relationalEqExpression -> relationalEqExpression ) (opToken= 'and' expr= relationalEqExpression -> ^( INFIX[$opToken] $logicalAndExpression $expr) )*
			{
			DebugLocation(125, 4);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:125:4: ( relationalEqExpression -> relationalEqExpression )
			DebugEnterAlt(1);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:125:5: relationalEqExpression
			{
			DebugLocation(125, 5);
			PushFollow(Follow._relationalEqExpression_in_logicalAndExpression894);
			relationalEqExpression67=relationalEqExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_relationalEqExpression.Add(relationalEqExpression67.Tree);


			{
			// AST REWRITE
			// elements: relationalEqExpression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 125:27: -> relationalEqExpression
			{
				DebugLocation(125, 29);
				adaptor.AddChild(root_0, stream_relationalEqExpression.NextTree());

			}

			retval.Tree = root_0;
			}
			}

			}

			DebugLocation(125, 54);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:125:54: (opToken= 'and' expr= relationalEqExpression -> ^( INFIX[$opToken] $logicalAndExpression $expr) )*
			try { DebugEnterSubRule(26);
			while (true)
			{
				int alt26=2;
				try { DebugEnterDecision(26, false);
				int LA26_0 = input.LA(1);

				if ((LA26_0==101))
				{
					alt26 = 1;
				}


				} finally { DebugExitDecision(26); }
				switch ( alt26 )
				{
				case 1:
					DebugEnterAlt(1);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:125:55: opToken= 'and' expr= relationalEqExpression
					{
					DebugLocation(125, 62);
					opToken=(CommonToken)Match(input,101,Follow._101_in_logicalAndExpression903); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_101.Add(opToken);

					DebugLocation(125, 73);
					PushFollow(Follow._relationalEqExpression_in_logicalAndExpression907);
					expr=relationalEqExpression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_relationalEqExpression.Add(expr.Tree);


					{
					// AST REWRITE
					// elements: logicalAndExpression, expr
					// token labels: 
					// rule labels: expr, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if (state.backtracking == 0) {
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_expr=new RewriteRuleSubtreeStream(adaptor,"rule expr",expr!=null?expr.Tree:null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (object)adaptor.Nil();
					// 125:96: -> ^( INFIX[$opToken] $logicalAndExpression $expr)
					{
						DebugLocation(125, 98);
						// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:125:98: ^( INFIX[$opToken] $logicalAndExpression $expr)
						{
						object root_1 = (object)adaptor.Nil();
						DebugLocation(125, 100);
						root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(INFIX, opToken), root_1);

						DebugLocation(125, 117);
						adaptor.AddChild(root_1, stream_retval.NextTree());
						DebugLocation(125, 139);
						adaptor.AddChild(root_1, stream_expr.NextTree());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}
					}

					}
					break;

				default:
					goto loop26;
				}
			}

			loop26:
				;

			} finally { DebugExitSubRule(26); }


			}

			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("logicalAndExpression", 21);
			LeaveRule("logicalAndExpression", 21);
			LeaveRule_logicalAndExpression();
		}
		DebugLocation(126, 1);
		} finally { DebugExitRule(GrammarFileName, "logicalAndExpression"); }
		return retval;

	}
	// $ANTLR end "logicalAndExpression"

	private sealed partial class relationalEqExpression_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public relationalEqExpression_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_relationalEqExpression();
	partial void LeaveRule_relationalEqExpression();

	// $ANTLR start "relationalEqExpression"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:128:1: relationalEqExpression : ( relationalNotEqExprassion -> relationalNotEqExprassion ) ( (opToken= '=' |opToken= '<>' ) expr= relationalNotEqExprassion -> ^( INFIX[$opToken] $relationalEqExpression $expr) )* ;
	[GrammarRule("relationalEqExpression")]
	private OCLSyntaxParser.relationalEqExpression_return relationalEqExpression()
	{
		EnterRule_relationalEqExpression();
		EnterRule("relationalEqExpression", 22);
		TraceIn("relationalEqExpression", 22);
		OCLSyntaxParser.relationalEqExpression_return retval = new OCLSyntaxParser.relationalEqExpression_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		CommonToken opToken = default(CommonToken);
		OCLSyntaxParser.relationalNotEqExprassion_return expr = default(OCLSyntaxParser.relationalNotEqExprassion_return);
		OCLSyntaxParser.relationalNotEqExprassion_return relationalNotEqExprassion68 = default(OCLSyntaxParser.relationalNotEqExprassion_return);

		object opToken_tree = default(object);
		RewriteRuleITokenStream stream_77=new RewriteRuleITokenStream(adaptor,"token 77");
		RewriteRuleITokenStream stream_76=new RewriteRuleITokenStream(adaptor,"token 76");
		RewriteRuleSubtreeStream stream_relationalNotEqExprassion=new RewriteRuleSubtreeStream(adaptor,"rule relationalNotEqExprassion");
		try { DebugEnterRule(GrammarFileName, "relationalEqExpression");
		DebugLocation(128, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:129:2: ( ( relationalNotEqExprassion -> relationalNotEqExprassion ) ( (opToken= '=' |opToken= '<>' ) expr= relationalNotEqExprassion -> ^( INFIX[$opToken] $relationalEqExpression $expr) )* )
			DebugEnterAlt(1);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:129:4: ( relationalNotEqExprassion -> relationalNotEqExprassion ) ( (opToken= '=' |opToken= '<>' ) expr= relationalNotEqExprassion -> ^( INFIX[$opToken] $relationalEqExpression $expr) )*
			{
			DebugLocation(129, 4);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:129:4: ( relationalNotEqExprassion -> relationalNotEqExprassion )
			DebugEnterAlt(1);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:129:5: relationalNotEqExprassion
			{
			DebugLocation(129, 5);
			PushFollow(Follow._relationalNotEqExprassion_in_relationalEqExpression932);
			relationalNotEqExprassion68=relationalNotEqExprassion();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_relationalNotEqExprassion.Add(relationalNotEqExprassion68.Tree);


			{
			// AST REWRITE
			// elements: relationalNotEqExprassion
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 129:30: -> relationalNotEqExprassion
			{
				DebugLocation(129, 32);
				adaptor.AddChild(root_0, stream_relationalNotEqExprassion.NextTree());

			}

			retval.Tree = root_0;
			}
			}

			}

			DebugLocation(129, 59);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:129:59: ( (opToken= '=' |opToken= '<>' ) expr= relationalNotEqExprassion -> ^( INFIX[$opToken] $relationalEqExpression $expr) )*
			try { DebugEnterSubRule(28);
			while (true)
			{
				int alt28=2;
				try { DebugEnterDecision(28, false);
				int LA28_0 = input.LA(1);

				if ((LA28_0==77))
				{
					alt28 = 1;
				}
				else if ((LA28_0==76))
				{
					alt28 = 1;
				}


				} finally { DebugExitDecision(28); }
				switch ( alt28 )
				{
				case 1:
					DebugEnterAlt(1);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:129:60: (opToken= '=' |opToken= '<>' ) expr= relationalNotEqExprassion
					{
					DebugLocation(129, 60);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:129:60: (opToken= '=' |opToken= '<>' )
					int alt27=2;
					try { DebugEnterSubRule(27);
					try { DebugEnterDecision(27, false);
					int LA27_0 = input.LA(1);

					if ((LA27_0==77))
					{
						alt27 = 1;
					}
					else if ((LA27_0==76))
					{
						alt27 = 2;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 27, 0, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					} finally { DebugExitDecision(27); }
					switch (alt27)
					{
					case 1:
						DebugEnterAlt(1);
						// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:129:61: opToken= '='
						{
						DebugLocation(129, 68);
						opToken=(CommonToken)Match(input,77,Follow._77_in_relationalEqExpression941); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_77.Add(opToken);


						}
						break;
					case 2:
						DebugEnterAlt(2);
						// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:129:73: opToken= '<>'
						{
						DebugLocation(129, 80);
						opToken=(CommonToken)Match(input,76,Follow._76_in_relationalEqExpression945); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_76.Add(opToken);


						}
						break;

					}
					} finally { DebugExitSubRule(27); }

					DebugLocation(129, 91);
					PushFollow(Follow._relationalNotEqExprassion_in_relationalEqExpression950);
					expr=relationalNotEqExprassion();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_relationalNotEqExprassion.Add(expr.Tree);


					{
					// AST REWRITE
					// elements: relationalEqExpression, expr
					// token labels: 
					// rule labels: expr, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if (state.backtracking == 0) {
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_expr=new RewriteRuleSubtreeStream(adaptor,"rule expr",expr!=null?expr.Tree:null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (object)adaptor.Nil();
					// 129:117: -> ^( INFIX[$opToken] $relationalEqExpression $expr)
					{
						DebugLocation(129, 119);
						// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:129:119: ^( INFIX[$opToken] $relationalEqExpression $expr)
						{
						object root_1 = (object)adaptor.Nil();
						DebugLocation(129, 121);
						root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(INFIX, opToken), root_1);

						DebugLocation(129, 138);
						adaptor.AddChild(root_1, stream_retval.NextTree());
						DebugLocation(129, 162);
						adaptor.AddChild(root_1, stream_expr.NextTree());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}
					}

					}
					break;

				default:
					goto loop28;
				}
			}

			loop28:
				;

			} finally { DebugExitSubRule(28); }


			}

			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("relationalEqExpression", 22);
			LeaveRule("relationalEqExpression", 22);
			LeaveRule_relationalEqExpression();
		}
		DebugLocation(130, 1);
		} finally { DebugExitRule(GrammarFileName, "relationalEqExpression"); }
		return retval;

	}
	// $ANTLR end "relationalEqExpression"

	private sealed partial class relationalNotEqExprassion_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public relationalNotEqExprassion_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_relationalNotEqExprassion();
	partial void LeaveRule_relationalNotEqExprassion();

	// $ANTLR start "relationalNotEqExprassion"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:131:1: relationalNotEqExprassion : ( additiveExpression -> additiveExpression ) ( (opToken= '<' |opToken= '>' |opToken= '<=' |opToken= '>=' ) expr= additiveExpression -> ^( INFIX[$opToken] $relationalNotEqExprassion $expr) )* ;
	[GrammarRule("relationalNotEqExprassion")]
	private OCLSyntaxParser.relationalNotEqExprassion_return relationalNotEqExprassion()
	{
		EnterRule_relationalNotEqExprassion();
		EnterRule("relationalNotEqExprassion", 23);
		TraceIn("relationalNotEqExprassion", 23);
		OCLSyntaxParser.relationalNotEqExprassion_return retval = new OCLSyntaxParser.relationalNotEqExprassion_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		CommonToken opToken = default(CommonToken);
		OCLSyntaxParser.additiveExpression_return expr = default(OCLSyntaxParser.additiveExpression_return);
		OCLSyntaxParser.additiveExpression_return additiveExpression69 = default(OCLSyntaxParser.additiveExpression_return);

		object opToken_tree = default(object);
		RewriteRuleITokenStream stream_74=new RewriteRuleITokenStream(adaptor,"token 74");
		RewriteRuleITokenStream stream_78=new RewriteRuleITokenStream(adaptor,"token 78");
		RewriteRuleITokenStream stream_75=new RewriteRuleITokenStream(adaptor,"token 75");
		RewriteRuleITokenStream stream_79=new RewriteRuleITokenStream(adaptor,"token 79");
		RewriteRuleSubtreeStream stream_additiveExpression=new RewriteRuleSubtreeStream(adaptor,"rule additiveExpression");
		try { DebugEnterRule(GrammarFileName, "relationalNotEqExprassion");
		DebugLocation(131, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:132:2: ( ( additiveExpression -> additiveExpression ) ( (opToken= '<' |opToken= '>' |opToken= '<=' |opToken= '>=' ) expr= additiveExpression -> ^( INFIX[$opToken] $relationalNotEqExprassion $expr) )* )
			DebugEnterAlt(1);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:132:4: ( additiveExpression -> additiveExpression ) ( (opToken= '<' |opToken= '>' |opToken= '<=' |opToken= '>=' ) expr= additiveExpression -> ^( INFIX[$opToken] $relationalNotEqExprassion $expr) )*
			{
			DebugLocation(132, 4);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:132:4: ( additiveExpression -> additiveExpression )
			DebugEnterAlt(1);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:132:5: additiveExpression
			{
			DebugLocation(132, 5);
			PushFollow(Follow._additiveExpression_in_relationalNotEqExprassion977);
			additiveExpression69=additiveExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_additiveExpression.Add(additiveExpression69.Tree);


			{
			// AST REWRITE
			// elements: additiveExpression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 132:24: -> additiveExpression
			{
				DebugLocation(132, 26);
				adaptor.AddChild(root_0, stream_additiveExpression.NextTree());

			}

			retval.Tree = root_0;
			}
			}

			}

			DebugLocation(132, 46);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:132:46: ( (opToken= '<' |opToken= '>' |opToken= '<=' |opToken= '>=' ) expr= additiveExpression -> ^( INFIX[$opToken] $relationalNotEqExprassion $expr) )*
			try { DebugEnterSubRule(30);
			while (true)
			{
				int alt30=2;
				try { DebugEnterDecision(30, false);
				switch (input.LA(1))
				{
				case 74:
					{
					alt30 = 1;
					}
					break;
				case 78:
					{
					alt30 = 1;
					}
					break;
				case 75:
					{
					alt30 = 1;
					}
					break;
				case 79:
					{
					alt30 = 1;
					}
					break;

				}

				} finally { DebugExitDecision(30); }
				switch ( alt30 )
				{
				case 1:
					DebugEnterAlt(1);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:132:47: (opToken= '<' |opToken= '>' |opToken= '<=' |opToken= '>=' ) expr= additiveExpression
					{
					DebugLocation(132, 47);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:132:47: (opToken= '<' |opToken= '>' |opToken= '<=' |opToken= '>=' )
					int alt29=4;
					try { DebugEnterSubRule(29);
					try { DebugEnterDecision(29, false);
					switch (input.LA(1))
					{
					case 74:
						{
						alt29 = 1;
						}
						break;
					case 78:
						{
						alt29 = 2;
						}
						break;
					case 75:
						{
						alt29 = 3;
						}
						break;
					case 79:
						{
						alt29 = 4;
						}
						break;
					default:
						{
							if (state.backtracking>0) {state.failed=true; return retval;}
							NoViableAltException nvae = new NoViableAltException("", 29, 0, input);
							DebugRecognitionException(nvae);
							throw nvae;
						}
					}

					} finally { DebugExitDecision(29); }
					switch (alt29)
					{
					case 1:
						DebugEnterAlt(1);
						// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:132:48: opToken= '<'
						{
						DebugLocation(132, 55);
						opToken=(CommonToken)Match(input,74,Follow._74_in_relationalNotEqExprassion987); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_74.Add(opToken);


						}
						break;
					case 2:
						DebugEnterAlt(2);
						// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:132:61: opToken= '>'
						{
						DebugLocation(132, 68);
						opToken=(CommonToken)Match(input,78,Follow._78_in_relationalNotEqExprassion992); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_78.Add(opToken);


						}
						break;
					case 3:
						DebugEnterAlt(3);
						// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:132:74: opToken= '<='
						{
						DebugLocation(132, 81);
						opToken=(CommonToken)Match(input,75,Follow._75_in_relationalNotEqExprassion997); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_75.Add(opToken);


						}
						break;
					case 4:
						DebugEnterAlt(4);
						// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:132:88: opToken= '>='
						{
						DebugLocation(132, 95);
						opToken=(CommonToken)Match(input,79,Follow._79_in_relationalNotEqExprassion1002); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_79.Add(opToken);


						}
						break;

					}
					} finally { DebugExitSubRule(29); }

					DebugLocation(132, 106);
					PushFollow(Follow._additiveExpression_in_relationalNotEqExprassion1007);
					expr=additiveExpression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_additiveExpression.Add(expr.Tree);


					{
					// AST REWRITE
					// elements: relationalNotEqExprassion, expr
					// token labels: 
					// rule labels: expr, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if (state.backtracking == 0) {
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_expr=new RewriteRuleSubtreeStream(adaptor,"rule expr",expr!=null?expr.Tree:null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (object)adaptor.Nil();
					// 132:125: -> ^( INFIX[$opToken] $relationalNotEqExprassion $expr)
					{
						DebugLocation(132, 127);
						// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:132:127: ^( INFIX[$opToken] $relationalNotEqExprassion $expr)
						{
						object root_1 = (object)adaptor.Nil();
						DebugLocation(132, 129);
						root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(INFIX, opToken), root_1);

						DebugLocation(132, 146);
						adaptor.AddChild(root_1, stream_retval.NextTree());
						DebugLocation(132, 173);
						adaptor.AddChild(root_1, stream_expr.NextTree());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}
					}

					}
					break;

				default:
					goto loop30;
				}
			}

			loop30:
				;

			} finally { DebugExitSubRule(30); }


			}

			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("relationalNotEqExprassion", 23);
			LeaveRule("relationalNotEqExprassion", 23);
			LeaveRule_relationalNotEqExprassion();
		}
		DebugLocation(133, 1);
		} finally { DebugExitRule(GrammarFileName, "relationalNotEqExprassion"); }
		return retval;

	}
	// $ANTLR end "relationalNotEqExprassion"

	private sealed partial class additiveExpression_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public additiveExpression_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_additiveExpression();
	partial void LeaveRule_additiveExpression();

	// $ANTLR start "additiveExpression"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:135:1: additiveExpression : ( multiplicativeExpression -> multiplicativeExpression ) ( (opToken= '+' |opToken= '-' ) expr= multiplicativeExpression -> ^( INFIX[$opToken] $additiveExpression $expr) )* ;
	[GrammarRule("additiveExpression")]
	private OCLSyntaxParser.additiveExpression_return additiveExpression()
	{
		EnterRule_additiveExpression();
		EnterRule("additiveExpression", 24);
		TraceIn("additiveExpression", 24);
		OCLSyntaxParser.additiveExpression_return retval = new OCLSyntaxParser.additiveExpression_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		CommonToken opToken = default(CommonToken);
		OCLSyntaxParser.multiplicativeExpression_return expr = default(OCLSyntaxParser.multiplicativeExpression_return);
		OCLSyntaxParser.multiplicativeExpression_return multiplicativeExpression70 = default(OCLSyntaxParser.multiplicativeExpression_return);

		object opToken_tree = default(object);
		RewriteRuleITokenStream stream_65=new RewriteRuleITokenStream(adaptor,"token 65");
		RewriteRuleITokenStream stream_67=new RewriteRuleITokenStream(adaptor,"token 67");
		RewriteRuleSubtreeStream stream_multiplicativeExpression=new RewriteRuleSubtreeStream(adaptor,"rule multiplicativeExpression");
		try { DebugEnterRule(GrammarFileName, "additiveExpression");
		DebugLocation(135, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:136:2: ( ( multiplicativeExpression -> multiplicativeExpression ) ( (opToken= '+' |opToken= '-' ) expr= multiplicativeExpression -> ^( INFIX[$opToken] $additiveExpression $expr) )* )
			DebugEnterAlt(1);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:136:4: ( multiplicativeExpression -> multiplicativeExpression ) ( (opToken= '+' |opToken= '-' ) expr= multiplicativeExpression -> ^( INFIX[$opToken] $additiveExpression $expr) )*
			{
			DebugLocation(136, 4);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:136:4: ( multiplicativeExpression -> multiplicativeExpression )
			DebugEnterAlt(1);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:136:5: multiplicativeExpression
			{
			DebugLocation(136, 5);
			PushFollow(Follow._multiplicativeExpression_in_additiveExpression1033);
			multiplicativeExpression70=multiplicativeExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_multiplicativeExpression.Add(multiplicativeExpression70.Tree);


			{
			// AST REWRITE
			// elements: multiplicativeExpression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 136:29: -> multiplicativeExpression
			{
				DebugLocation(136, 31);
				adaptor.AddChild(root_0, stream_multiplicativeExpression.NextTree());

			}

			retval.Tree = root_0;
			}
			}

			}

			DebugLocation(136, 57);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:136:57: ( (opToken= '+' |opToken= '-' ) expr= multiplicativeExpression -> ^( INFIX[$opToken] $additiveExpression $expr) )*
			try { DebugEnterSubRule(32);
			while (true)
			{
				int alt32=2;
				try { DebugEnterDecision(32, false);
				int LA32_0 = input.LA(1);

				if ((LA32_0==65))
				{
					alt32 = 1;
				}
				else if ((LA32_0==67))
				{
					alt32 = 1;
				}


				} finally { DebugExitDecision(32); }
				switch ( alt32 )
				{
				case 1:
					DebugEnterAlt(1);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:136:58: (opToken= '+' |opToken= '-' ) expr= multiplicativeExpression
					{
					DebugLocation(136, 58);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:136:58: (opToken= '+' |opToken= '-' )
					int alt31=2;
					try { DebugEnterSubRule(31);
					try { DebugEnterDecision(31, false);
					int LA31_0 = input.LA(1);

					if ((LA31_0==65))
					{
						alt31 = 1;
					}
					else if ((LA31_0==67))
					{
						alt31 = 2;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 31, 0, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					} finally { DebugExitDecision(31); }
					switch (alt31)
					{
					case 1:
						DebugEnterAlt(1);
						// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:136:59: opToken= '+'
						{
						DebugLocation(136, 66);
						opToken=(CommonToken)Match(input,65,Follow._65_in_additiveExpression1042); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_65.Add(opToken);


						}
						break;
					case 2:
						DebugEnterAlt(2);
						// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:136:71: opToken= '-'
						{
						DebugLocation(136, 78);
						opToken=(CommonToken)Match(input,67,Follow._67_in_additiveExpression1046); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_67.Add(opToken);


						}
						break;

					}
					} finally { DebugExitSubRule(31); }

					DebugLocation(136, 88);
					PushFollow(Follow._multiplicativeExpression_in_additiveExpression1052);
					expr=multiplicativeExpression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_multiplicativeExpression.Add(expr.Tree);


					{
					// AST REWRITE
					// elements: additiveExpression, expr
					// token labels: 
					// rule labels: expr, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if (state.backtracking == 0) {
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_expr=new RewriteRuleSubtreeStream(adaptor,"rule expr",expr!=null?expr.Tree:null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (object)adaptor.Nil();
					// 136:114: -> ^( INFIX[$opToken] $additiveExpression $expr)
					{
						DebugLocation(136, 116);
						// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:136:116: ^( INFIX[$opToken] $additiveExpression $expr)
						{
						object root_1 = (object)adaptor.Nil();
						DebugLocation(136, 118);
						root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(INFIX, opToken), root_1);

						DebugLocation(136, 135);
						adaptor.AddChild(root_1, stream_retval.NextTree());
						DebugLocation(136, 155);
						adaptor.AddChild(root_1, stream_expr.NextTree());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}
					}

					}
					break;

				default:
					goto loop32;
				}
			}

			loop32:
				;

			} finally { DebugExitSubRule(32); }


			}

			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("additiveExpression", 24);
			LeaveRule("additiveExpression", 24);
			LeaveRule_additiveExpression();
		}
		DebugLocation(137, 1);
		} finally { DebugExitRule(GrammarFileName, "additiveExpression"); }
		return retval;

	}
	// $ANTLR end "additiveExpression"

	private sealed partial class multiplicativeExpression_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public multiplicativeExpression_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_multiplicativeExpression();
	partial void LeaveRule_multiplicativeExpression();

	// $ANTLR start "multiplicativeExpression"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:139:1: multiplicativeExpression : ( unaryExpression -> unaryExpression ) ( (opToken= '*' |opToken= '/' ) expr= unaryExpression -> ^( INFIX[$opToken] $multiplicativeExpression $expr) )* ;
	[GrammarRule("multiplicativeExpression")]
	private OCLSyntaxParser.multiplicativeExpression_return multiplicativeExpression()
	{
		EnterRule_multiplicativeExpression();
		EnterRule("multiplicativeExpression", 25);
		TraceIn("multiplicativeExpression", 25);
		OCLSyntaxParser.multiplicativeExpression_return retval = new OCLSyntaxParser.multiplicativeExpression_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		CommonToken opToken = default(CommonToken);
		OCLSyntaxParser.unaryExpression_return expr = default(OCLSyntaxParser.unaryExpression_return);
		OCLSyntaxParser.unaryExpression_return unaryExpression71 = default(OCLSyntaxParser.unaryExpression_return);

		object opToken_tree = default(object);
		RewriteRuleITokenStream stream_UnlimitedNaturalLiteralExp=new RewriteRuleITokenStream(adaptor,"token UnlimitedNaturalLiteralExp");
		RewriteRuleITokenStream stream_70=new RewriteRuleITokenStream(adaptor,"token 70");
		RewriteRuleSubtreeStream stream_unaryExpression=new RewriteRuleSubtreeStream(adaptor,"rule unaryExpression");
		try { DebugEnterRule(GrammarFileName, "multiplicativeExpression");
		DebugLocation(139, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:140:2: ( ( unaryExpression -> unaryExpression ) ( (opToken= '*' |opToken= '/' ) expr= unaryExpression -> ^( INFIX[$opToken] $multiplicativeExpression $expr) )* )
			DebugEnterAlt(1);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:140:4: ( unaryExpression -> unaryExpression ) ( (opToken= '*' |opToken= '/' ) expr= unaryExpression -> ^( INFIX[$opToken] $multiplicativeExpression $expr) )*
			{
			DebugLocation(140, 4);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:140:4: ( unaryExpression -> unaryExpression )
			DebugEnterAlt(1);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:140:5: unaryExpression
			{
			DebugLocation(140, 5);
			PushFollow(Follow._unaryExpression_in_multiplicativeExpression1079);
			unaryExpression71=unaryExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_unaryExpression.Add(unaryExpression71.Tree);


			{
			// AST REWRITE
			// elements: unaryExpression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 140:20: -> unaryExpression
			{
				DebugLocation(140, 22);
				adaptor.AddChild(root_0, stream_unaryExpression.NextTree());

			}

			retval.Tree = root_0;
			}
			}

			}

			DebugLocation(140, 39);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:140:39: ( (opToken= '*' |opToken= '/' ) expr= unaryExpression -> ^( INFIX[$opToken] $multiplicativeExpression $expr) )*
			try { DebugEnterSubRule(34);
			while (true)
			{
				int alt34=2;
				try { DebugEnterDecision(34, false);
				int LA34_0 = input.LA(1);

				if ((LA34_0==UnlimitedNaturalLiteralExp))
				{
					alt34 = 1;
				}
				else if ((LA34_0==70))
				{
					alt34 = 1;
				}


				} finally { DebugExitDecision(34); }
				switch ( alt34 )
				{
				case 1:
					DebugEnterAlt(1);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:140:40: (opToken= '*' |opToken= '/' ) expr= unaryExpression
					{
					DebugLocation(140, 40);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:140:40: (opToken= '*' |opToken= '/' )
					int alt33=2;
					try { DebugEnterSubRule(33);
					try { DebugEnterDecision(33, false);
					int LA33_0 = input.LA(1);

					if ((LA33_0==UnlimitedNaturalLiteralExp))
					{
						alt33 = 1;
					}
					else if ((LA33_0==70))
					{
						alt33 = 2;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 33, 0, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					} finally { DebugExitDecision(33); }
					switch (alt33)
					{
					case 1:
						DebugEnterAlt(1);
						// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:140:41: opToken= '*'
						{
						DebugLocation(140, 48);
						opToken=(CommonToken)Match(input,UnlimitedNaturalLiteralExp,Follow._UnlimitedNaturalLiteralExp_in_multiplicativeExpression1088); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_UnlimitedNaturalLiteralExp.Add(opToken);


						}
						break;
					case 2:
						DebugEnterAlt(2);
						// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:140:53: opToken= '/'
						{
						DebugLocation(140, 60);
						opToken=(CommonToken)Match(input,70,Follow._70_in_multiplicativeExpression1092); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_70.Add(opToken);


						}
						break;

					}
					} finally { DebugExitSubRule(33); }

					DebugLocation(140, 70);
					PushFollow(Follow._unaryExpression_in_multiplicativeExpression1097);
					expr=unaryExpression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_unaryExpression.Add(expr.Tree);


					{
					// AST REWRITE
					// elements: multiplicativeExpression, expr
					// token labels: 
					// rule labels: expr, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if (state.backtracking == 0) {
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_expr=new RewriteRuleSubtreeStream(adaptor,"rule expr",expr!=null?expr.Tree:null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (object)adaptor.Nil();
					// 140:86: -> ^( INFIX[$opToken] $multiplicativeExpression $expr)
					{
						DebugLocation(140, 88);
						// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:140:88: ^( INFIX[$opToken] $multiplicativeExpression $expr)
						{
						object root_1 = (object)adaptor.Nil();
						DebugLocation(140, 90);
						root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(INFIX, opToken), root_1);

						DebugLocation(140, 107);
						adaptor.AddChild(root_1, stream_retval.NextTree());
						DebugLocation(140, 133);
						adaptor.AddChild(root_1, stream_expr.NextTree());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}
					}

					}
					break;

				default:
					goto loop34;
				}
			}

			loop34:
				;

			} finally { DebugExitSubRule(34); }


			}

			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("multiplicativeExpression", 25);
			LeaveRule("multiplicativeExpression", 25);
			LeaveRule_multiplicativeExpression();
		}
		DebugLocation(141, 1);
		} finally { DebugExitRule(GrammarFileName, "multiplicativeExpression"); }
		return retval;

	}
	// $ANTLR end "multiplicativeExpression"

	private sealed partial class unaryExpression_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public unaryExpression_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_unaryExpression();
	partial void LeaveRule_unaryExpression();

	// $ANTLR start "unaryExpression"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:143:1: unaryExpression : ( (opToken= '-' |opToken= 'not' ) term= termExpression -> ^( UNARY[$opToken] $term) | termExpression );
	[GrammarRule("unaryExpression")]
	private OCLSyntaxParser.unaryExpression_return unaryExpression()
	{
		EnterRule_unaryExpression();
		EnterRule("unaryExpression", 26);
		TraceIn("unaryExpression", 26);
		OCLSyntaxParser.unaryExpression_return retval = new OCLSyntaxParser.unaryExpression_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		CommonToken opToken = default(CommonToken);
		OCLSyntaxParser.termExpression_return term = default(OCLSyntaxParser.termExpression_return);
		OCLSyntaxParser.termExpression_return termExpression72 = default(OCLSyntaxParser.termExpression_return);

		object opToken_tree = default(object);
		RewriteRuleITokenStream stream_67=new RewriteRuleITokenStream(adaptor,"token 67");
		RewriteRuleITokenStream stream_118=new RewriteRuleITokenStream(adaptor,"token 118");
		RewriteRuleSubtreeStream stream_termExpression=new RewriteRuleSubtreeStream(adaptor,"rule termExpression");
		try { DebugEnterRule(GrammarFileName, "unaryExpression");
		DebugLocation(143, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:144:2: ( (opToken= '-' |opToken= 'not' ) term= termExpression -> ^( UNARY[$opToken] $term) | termExpression )
			int alt36=2;
			try { DebugEnterDecision(36, false);
			int LA36_0 = input.LA(1);

			if ((LA36_0==67||LA36_0==118))
			{
				alt36 = 1;
			}
			else if (((LA36_0>=IntegerLiteralExp && LA36_0<=InvalidLiteralExp)||LA36_0==NullLiteralExp||(LA36_0>=RealLiteralExp && LA36_0<=SimpleName)||LA36_0==StringLiteralExp||LA36_0==UnlimitedNaturalLiteralExp||LA36_0==63||(LA36_0>=82 && LA36_0<=96)||(LA36_0>=108 && LA36_0<=109)||(LA36_0>=114 && LA36_0<=115)||LA36_0==117||LA36_0==125))
			{
				alt36 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 36, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(36); }
			switch (alt36)
			{
			case 1:
				DebugEnterAlt(1);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:144:4: (opToken= '-' |opToken= 'not' ) term= termExpression
				{
				DebugLocation(144, 4);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:144:4: (opToken= '-' |opToken= 'not' )
				int alt35=2;
				try { DebugEnterSubRule(35);
				try { DebugEnterDecision(35, false);
				int LA35_0 = input.LA(1);

				if ((LA35_0==67))
				{
					alt35 = 1;
				}
				else if ((LA35_0==118))
				{
					alt35 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 35, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				} finally { DebugExitDecision(35); }
				switch (alt35)
				{
				case 1:
					DebugEnterAlt(1);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:144:5: opToken= '-'
					{
					DebugLocation(144, 12);
					opToken=(CommonToken)Match(input,67,Follow._67_in_unaryExpression1125); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_67.Add(opToken);


					}
					break;
				case 2:
					DebugEnterAlt(2);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:144:17: opToken= 'not'
					{
					DebugLocation(144, 24);
					opToken=(CommonToken)Match(input,118,Follow._118_in_unaryExpression1129); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_118.Add(opToken);


					}
					break;

				}
				} finally { DebugExitSubRule(35); }

				DebugLocation(144, 36);
				PushFollow(Follow._termExpression_in_unaryExpression1134);
				term=termExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_termExpression.Add(term.Tree);


				{
				// AST REWRITE
				// elements: term
				// token labels: 
				// rule labels: term, retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_term=new RewriteRuleSubtreeStream(adaptor,"rule term",term!=null?term.Tree:null);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 144:52: -> ^( UNARY[$opToken] $term)
				{
					DebugLocation(144, 54);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:144:54: ^( UNARY[$opToken] $term)
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(144, 56);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(UNARY, opToken), root_1);

					DebugLocation(144, 73);
					adaptor.AddChild(root_1, stream_term.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:145:4: termExpression
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(145, 4);
				PushFollow(Follow._termExpression_in_unaryExpression1148);
				termExpression72=termExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, termExpression72.Tree);

				}
				break;

			}
			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("unaryExpression", 26);
			LeaveRule("unaryExpression", 26);
			LeaveRule_unaryExpression();
		}
		DebugLocation(146, 1);
		} finally { DebugExitRule(GrammarFileName, "unaryExpression"); }
		return retval;

	}
	// $ANTLR end "unaryExpression"

	private sealed partial class termExpression_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public termExpression_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_termExpression();
	partial void LeaveRule_termExpression();

	// $ANTLR start "termExpression"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:148:1: termExpression : ( primaryExperession -> primaryExperession ) ( ( (token= '.' |token= '->' ) expr= propertyCall -> ^( $token $termExpression $expr) ) | ( oclMessageExp -> MESSAGE oclMessageExp ) )* ;
	[GrammarRule("termExpression")]
	private OCLSyntaxParser.termExpression_return termExpression()
	{
		EnterRule_termExpression();
		EnterRule("termExpression", 27);
		TraceIn("termExpression", 27);
		OCLSyntaxParser.termExpression_return retval = new OCLSyntaxParser.termExpression_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		CommonToken token = default(CommonToken);
		OCLSyntaxParser.propertyCall_return expr = default(OCLSyntaxParser.propertyCall_return);
		OCLSyntaxParser.primaryExperession_return primaryExperession73 = default(OCLSyntaxParser.primaryExperession_return);
		OCLSyntaxParser.oclMessageExp_return oclMessageExp74 = default(OCLSyntaxParser.oclMessageExp_return);

		object token_tree = default(object);
		RewriteRuleITokenStream stream_69=new RewriteRuleITokenStream(adaptor,"token 69");
		RewriteRuleITokenStream stream_68=new RewriteRuleITokenStream(adaptor,"token 68");
		RewriteRuleSubtreeStream stream_primaryExperession=new RewriteRuleSubtreeStream(adaptor,"rule primaryExperession");
		RewriteRuleSubtreeStream stream_propertyCall=new RewriteRuleSubtreeStream(adaptor,"rule propertyCall");
		RewriteRuleSubtreeStream stream_oclMessageExp=new RewriteRuleSubtreeStream(adaptor,"rule oclMessageExp");
		try { DebugEnterRule(GrammarFileName, "termExpression");
		DebugLocation(148, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:149:2: ( ( primaryExperession -> primaryExperession ) ( ( (token= '.' |token= '->' ) expr= propertyCall -> ^( $token $termExpression $expr) ) | ( oclMessageExp -> MESSAGE oclMessageExp ) )* )
			DebugEnterAlt(1);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:149:4: ( primaryExperession -> primaryExperession ) ( ( (token= '.' |token= '->' ) expr= propertyCall -> ^( $token $termExpression $expr) ) | ( oclMessageExp -> MESSAGE oclMessageExp ) )*
			{
			DebugLocation(149, 4);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:149:4: ( primaryExperession -> primaryExperession )
			DebugEnterAlt(1);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:149:5: primaryExperession
			{
			DebugLocation(149, 5);
			PushFollow(Follow._primaryExperession_in_termExpression1162);
			primaryExperession73=primaryExperession();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_primaryExperession.Add(primaryExperession73.Tree);


			{
			// AST REWRITE
			// elements: primaryExperession
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 149:23: -> primaryExperession
			{
				DebugLocation(149, 25);
				adaptor.AddChild(root_0, stream_primaryExperession.NextTree());

			}

			retval.Tree = root_0;
			}
			}

			}

			DebugLocation(149, 45);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:149:45: ( ( (token= '.' |token= '->' ) expr= propertyCall -> ^( $token $termExpression $expr) ) | ( oclMessageExp -> MESSAGE oclMessageExp ) )*
			try { DebugEnterSubRule(38);
			while (true)
			{
				int alt38=3;
				try { DebugEnterDecision(38, false);
				switch (input.LA(1))
				{
				case 69:
					{
					alt38 = 1;
					}
					break;
				case 68:
					{
					alt38 = 1;
					}
					break;
				case 100:
					{
					alt38 = 2;
					}
					break;
				case 99:
					{
					alt38 = 2;
					}
					break;

				}

				} finally { DebugExitDecision(38); }
				switch ( alt38 )
				{
				case 1:
					DebugEnterAlt(1);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:149:47: ( (token= '.' |token= '->' ) expr= propertyCall -> ^( $token $termExpression $expr) )
					{
					DebugLocation(149, 47);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:149:47: ( (token= '.' |token= '->' ) expr= propertyCall -> ^( $token $termExpression $expr) )
					DebugEnterAlt(1);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:149:48: (token= '.' |token= '->' ) expr= propertyCall
					{
					DebugLocation(149, 48);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:149:48: (token= '.' |token= '->' )
					int alt37=2;
					try { DebugEnterSubRule(37);
					try { DebugEnterDecision(37, false);
					int LA37_0 = input.LA(1);

					if ((LA37_0==69))
					{
						alt37 = 1;
					}
					else if ((LA37_0==68))
					{
						alt37 = 2;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 37, 0, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					} finally { DebugExitDecision(37); }
					switch (alt37)
					{
					case 1:
						DebugEnterAlt(1);
						// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:149:49: token= '.'
						{
						DebugLocation(149, 54);
						token=(CommonToken)Match(input,69,Follow._69_in_termExpression1173); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_69.Add(token);


						}
						break;
					case 2:
						DebugEnterAlt(2);
						// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:149:59: token= '->'
						{
						DebugLocation(149, 64);
						token=(CommonToken)Match(input,68,Follow._68_in_termExpression1177); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_68.Add(token);


						}
						break;

					}
					} finally { DebugExitSubRule(37); }

					DebugLocation(149, 75);
					PushFollow(Follow._propertyCall_in_termExpression1182);
					expr=propertyCall();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_propertyCall.Add(expr.Tree);


					{
					// AST REWRITE
					// elements: token, termExpression, expr
					// token labels: token
					// rule labels: expr, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if (state.backtracking == 0) {
					retval.Tree = root_0;
					RewriteRuleITokenStream stream_token=new RewriteRuleITokenStream(adaptor,"token token",token);
					RewriteRuleSubtreeStream stream_expr=new RewriteRuleSubtreeStream(adaptor,"rule expr",expr!=null?expr.Tree:null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (object)adaptor.Nil();
					// 149:89: -> ^( $token $termExpression $expr)
					{
						DebugLocation(149, 92);
						// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:149:92: ^( $token $termExpression $expr)
						{
						object root_1 = (object)adaptor.Nil();
						DebugLocation(149, 95);
						root_1 = (object)adaptor.BecomeRoot(stream_token.NextNode(), root_1);

						DebugLocation(149, 102);
						adaptor.AddChild(root_1, stream_retval.NextTree());
						DebugLocation(149, 118);
						adaptor.AddChild(root_1, stream_expr.NextTree());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}
					}

					}


					}
					break;
				case 2:
					DebugEnterAlt(2);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:150:6: ( oclMessageExp -> MESSAGE oclMessageExp )
					{
					DebugLocation(150, 6);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:150:6: ( oclMessageExp -> MESSAGE oclMessageExp )
					DebugEnterAlt(1);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:150:7: oclMessageExp
					{
					DebugLocation(150, 7);
					PushFollow(Follow._oclMessageExp_in_termExpression1206);
					oclMessageExp74=oclMessageExp();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_oclMessageExp.Add(oclMessageExp74.Tree);


					{
					// AST REWRITE
					// elements: oclMessageExp
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if (state.backtracking == 0) {
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (object)adaptor.Nil();
					// 150:21: -> MESSAGE oclMessageExp
					{
						DebugLocation(150, 24);
						adaptor.AddChild(root_0, (object)adaptor.Create(MESSAGE, "MESSAGE"));
						DebugLocation(150, 32);
						adaptor.AddChild(root_0, stream_oclMessageExp.NextTree());

					}

					retval.Tree = root_0;
					}
					}

					}


					}
					break;

				default:
					goto loop38;
				}
			}

			loop38:
				;

			} finally { DebugExitSubRule(38); }


			}

			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("termExpression", 27);
			LeaveRule("termExpression", 27);
			LeaveRule_termExpression();
		}
		DebugLocation(153, 1);
		} finally { DebugExitRule(GrammarFileName, "termExpression"); }
		return retval;

	}
	// $ANTLR end "termExpression"

	private sealed partial class primaryExperession_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public primaryExperession_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_primaryExperession();
	partial void LeaveRule_primaryExperession();

	// $ANTLR start "primaryExperession"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:155:1: primaryExperession : ( collectionLiteralExpAndType | tupleLiteralExp | classLiteralExp | primitiveLiteralExp -> ^( PRIMITIVELITERAL primitiveLiteralExp ) | enumAndType -> ^( TYPE enumAndType ) | propertyCall | '(' oclExpression ')' | ifExp | letExp );
	[GrammarRule("primaryExperession")]
	private OCLSyntaxParser.primaryExperession_return primaryExperession()
	{
		EnterRule_primaryExperession();
		EnterRule("primaryExperession", 28);
		TraceIn("primaryExperession", 28);
		OCLSyntaxParser.primaryExperession_return retval = new OCLSyntaxParser.primaryExperession_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		CommonToken char_literal81 = default(CommonToken);
		CommonToken char_literal83 = default(CommonToken);
		OCLSyntaxParser.collectionLiteralExpAndType_return collectionLiteralExpAndType75 = default(OCLSyntaxParser.collectionLiteralExpAndType_return);
		OCLSyntaxParser.tupleLiteralExp_return tupleLiteralExp76 = default(OCLSyntaxParser.tupleLiteralExp_return);
		OCLSyntaxParser.classLiteralExp_return classLiteralExp77 = default(OCLSyntaxParser.classLiteralExp_return);
		OCLSyntaxParser.primitiveLiteralExp_return primitiveLiteralExp78 = default(OCLSyntaxParser.primitiveLiteralExp_return);
		OCLSyntaxParser.enumAndType_return enumAndType79 = default(OCLSyntaxParser.enumAndType_return);
		OCLSyntaxParser.propertyCall_return propertyCall80 = default(OCLSyntaxParser.propertyCall_return);
		OCLSyntaxParser.oclExpression_return oclExpression82 = default(OCLSyntaxParser.oclExpression_return);
		OCLSyntaxParser.ifExp_return ifExp84 = default(OCLSyntaxParser.ifExp_return);
		OCLSyntaxParser.letExp_return letExp85 = default(OCLSyntaxParser.letExp_return);

		object char_literal81_tree = default(object);
		object char_literal83_tree = default(object);
		RewriteRuleSubtreeStream stream_primitiveLiteralExp=new RewriteRuleSubtreeStream(adaptor,"rule primitiveLiteralExp");
		RewriteRuleSubtreeStream stream_enumAndType=new RewriteRuleSubtreeStream(adaptor,"rule enumAndType");
		try { DebugEnterRule(GrammarFileName, "primaryExperession");
		DebugLocation(155, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:156:2: ( collectionLiteralExpAndType | tupleLiteralExp | classLiteralExp | primitiveLiteralExp -> ^( PRIMITIVELITERAL primitiveLiteralExp ) | enumAndType -> ^( TYPE enumAndType ) | propertyCall | '(' oclExpression ')' | ifExp | letExp )
			int alt39=9;
			try { DebugEnterDecision(39, false);
			try
			{
				alt39 = dfa39.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(39); }
			switch (alt39)
			{
			case 1:
				DebugEnterAlt(1);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:160:8: collectionLiteralExpAndType
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(160, 8);
				PushFollow(Follow._collectionLiteralExpAndType_in_primaryExperession1248);
				collectionLiteralExpAndType75=collectionLiteralExpAndType();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, collectionLiteralExpAndType75.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:162:4: tupleLiteralExp
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(162, 4);
				PushFollow(Follow._tupleLiteralExp_in_primaryExperession1256);
				tupleLiteralExp76=tupleLiteralExp();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, tupleLiteralExp76.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:163:4: classLiteralExp
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(163, 4);
				PushFollow(Follow._classLiteralExp_in_primaryExperession1262);
				classLiteralExp77=classLiteralExp();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, classLiteralExp77.Tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:164:4: primitiveLiteralExp
				{
				DebugLocation(164, 4);
				PushFollow(Follow._primitiveLiteralExp_in_primaryExperession1269);
				primitiveLiteralExp78=primitiveLiteralExp();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_primitiveLiteralExp.Add(primitiveLiteralExp78.Tree);


				{
				// AST REWRITE
				// elements: primitiveLiteralExp
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 165:4: -> ^( PRIMITIVELITERAL primitiveLiteralExp )
				{
					DebugLocation(165, 6);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:165:6: ^( PRIMITIVELITERAL primitiveLiteralExp )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(165, 8);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(PRIMITIVELITERAL, "PRIMITIVELITERAL"), root_1);

					DebugLocation(165, 25);
					adaptor.AddChild(root_1, stream_primitiveLiteralExp.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:167:4: enumAndType
				{
				DebugLocation(167, 4);
				PushFollow(Follow._enumAndType_in_primaryExperession1287);
				enumAndType79=enumAndType();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_enumAndType.Add(enumAndType79.Tree);


				{
				// AST REWRITE
				// elements: enumAndType
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 168:4: -> ^( TYPE enumAndType )
				{
					DebugLocation(168, 6);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:168:6: ^( TYPE enumAndType )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(168, 8);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(TYPE, "TYPE"), root_1);

					DebugLocation(168, 13);
					adaptor.AddChild(root_1, stream_enumAndType.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:169:4: propertyCall
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(169, 4);
				PushFollow(Follow._propertyCall_in_primaryExperession1303);
				propertyCall80=propertyCall();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, propertyCall80.Tree);

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:170:4: '(' oclExpression ')'
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(170, 7);
				char_literal81=(CommonToken)Match(input,63,Follow._63_in_primaryExperession1308); if (state.failed) return retval;
				DebugLocation(170, 8);
				PushFollow(Follow._oclExpression_in_primaryExperession1310);
				oclExpression82=oclExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, oclExpression82.Tree);
				DebugLocation(170, 24);
				char_literal83=(CommonToken)Match(input,64,Follow._64_in_primaryExperession1311); if (state.failed) return retval;

				}
				break;
			case 8:
				DebugEnterAlt(8);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:171:4: ifExp
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(171, 4);
				PushFollow(Follow._ifExp_in_primaryExperession1317);
				ifExp84=ifExp();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, ifExp84.Tree);

				}
				break;
			case 9:
				DebugEnterAlt(9);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:172:4: letExp
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(172, 4);
				PushFollow(Follow._letExp_in_primaryExperession1322);
				letExp85=letExp();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, letExp85.Tree);

				}
				break;

			}
			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("primaryExperession", 28);
			LeaveRule("primaryExperession", 28);
			LeaveRule_primaryExperession();
		}
		DebugLocation(173, 1);
		} finally { DebugExitRule(GrammarFileName, "primaryExperession"); }
		return retval;

	}
	// $ANTLR end "primaryExperession"

	private sealed partial class propertyCall_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public propertyCall_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_propertyCall();
	partial void LeaveRule_propertyCall();

	// $ANTLR start "propertyCall"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:174:1: propertyCall : ( pathName ( '[' arguments ']' )? ( isMarkedPre )? ( '(' propertyCallParametrs ')' )? -> ^( CALL pathName ( propertyCallParametrs )? ( ^( INDEX arguments ) )? ( isMarkedPre )? ) |it= 'iterate' '(' ( ( ( SimpleName ( ( ':' ) type )? ';' )=>itName= SimpleName ( ( ':' ) itType= type )? ';' accName= SimpleName ( ':' accType= type )? '=' accExpr= oclExpression ) | (accName= SimpleName ( ':' accType= type )? '=' accExpr= oclExpression ) ) '|' body= oclExpression ')' -> ^( ITERATE[$it] ( ^( DECL $itName ( $itType)? ) )? ^( ACC $accName ( $accType)? $accExpr) $body) );
	[GrammarRule("propertyCall")]
	private OCLSyntaxParser.propertyCall_return propertyCall()
	{
		EnterRule_propertyCall();
		EnterRule("propertyCall", 29);
		TraceIn("propertyCall", 29);
		OCLSyntaxParser.propertyCall_return retval = new OCLSyntaxParser.propertyCall_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		CommonToken it = default(CommonToken);
		CommonToken itName = default(CommonToken);
		CommonToken accName = default(CommonToken);
		CommonToken char_literal87 = default(CommonToken);
		CommonToken char_literal89 = default(CommonToken);
		CommonToken char_literal91 = default(CommonToken);
		CommonToken char_literal93 = default(CommonToken);
		CommonToken char_literal94 = default(CommonToken);
		CommonToken char_literal95 = default(CommonToken);
		CommonToken char_literal96 = default(CommonToken);
		CommonToken char_literal97 = default(CommonToken);
		CommonToken char_literal98 = default(CommonToken);
		CommonToken char_literal99 = default(CommonToken);
		CommonToken char_literal100 = default(CommonToken);
		CommonToken char_literal101 = default(CommonToken);
		CommonToken char_literal102 = default(CommonToken);
		OCLSyntaxParser.type_return itType = default(OCLSyntaxParser.type_return);
		OCLSyntaxParser.type_return accType = default(OCLSyntaxParser.type_return);
		OCLSyntaxParser.oclExpression_return accExpr = default(OCLSyntaxParser.oclExpression_return);
		OCLSyntaxParser.oclExpression_return body = default(OCLSyntaxParser.oclExpression_return);
		OCLSyntaxParser.pathName_return pathName86 = default(OCLSyntaxParser.pathName_return);
		OCLSyntaxParser.arguments_return arguments88 = default(OCLSyntaxParser.arguments_return);
		OCLSyntaxParser.isMarkedPre_return isMarkedPre90 = default(OCLSyntaxParser.isMarkedPre_return);
		OCLSyntaxParser.propertyCallParametrs_return propertyCallParametrs92 = default(OCLSyntaxParser.propertyCallParametrs_return);

		object it_tree = default(object);
		object itName_tree = default(object);
		object accName_tree = default(object);
		object char_literal87_tree = default(object);
		object char_literal89_tree = default(object);
		object char_literal91_tree = default(object);
		object char_literal93_tree = default(object);
		object char_literal94_tree = default(object);
		object char_literal95_tree = default(object);
		object char_literal96_tree = default(object);
		object char_literal97_tree = default(object);
		object char_literal98_tree = default(object);
		object char_literal99_tree = default(object);
		object char_literal100_tree = default(object);
		object char_literal101_tree = default(object);
		object char_literal102_tree = default(object);
		RewriteRuleITokenStream stream_97=new RewriteRuleITokenStream(adaptor,"token 97");
		RewriteRuleITokenStream stream_98=new RewriteRuleITokenStream(adaptor,"token 98");
		RewriteRuleITokenStream stream_63=new RewriteRuleITokenStream(adaptor,"token 63");
		RewriteRuleITokenStream stream_64=new RewriteRuleITokenStream(adaptor,"token 64");
		RewriteRuleITokenStream stream_114=new RewriteRuleITokenStream(adaptor,"token 114");
		RewriteRuleITokenStream stream_SimpleName=new RewriteRuleITokenStream(adaptor,"token SimpleName");
		RewriteRuleITokenStream stream_71=new RewriteRuleITokenStream(adaptor,"token 71");
		RewriteRuleITokenStream stream_73=new RewriteRuleITokenStream(adaptor,"token 73");
		RewriteRuleITokenStream stream_77=new RewriteRuleITokenStream(adaptor,"token 77");
		RewriteRuleITokenStream stream_128=new RewriteRuleITokenStream(adaptor,"token 128");
		RewriteRuleSubtreeStream stream_pathName=new RewriteRuleSubtreeStream(adaptor,"rule pathName");
		RewriteRuleSubtreeStream stream_arguments=new RewriteRuleSubtreeStream(adaptor,"rule arguments");
		RewriteRuleSubtreeStream stream_isMarkedPre=new RewriteRuleSubtreeStream(adaptor,"rule isMarkedPre");
		RewriteRuleSubtreeStream stream_propertyCallParametrs=new RewriteRuleSubtreeStream(adaptor,"rule propertyCallParametrs");
		RewriteRuleSubtreeStream stream_type=new RewriteRuleSubtreeStream(adaptor,"rule type");
		RewriteRuleSubtreeStream stream_oclExpression=new RewriteRuleSubtreeStream(adaptor,"rule oclExpression");
		try { DebugEnterRule(GrammarFileName, "propertyCall");
		DebugLocation(174, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:175:2: ( pathName ( '[' arguments ']' )? ( isMarkedPre )? ( '(' propertyCallParametrs ')' )? -> ^( CALL pathName ( propertyCallParametrs )? ( ^( INDEX arguments ) )? ( isMarkedPre )? ) |it= 'iterate' '(' ( ( ( SimpleName ( ( ':' ) type )? ';' )=>itName= SimpleName ( ( ':' ) itType= type )? ';' accName= SimpleName ( ':' accType= type )? '=' accExpr= oclExpression ) | (accName= SimpleName ( ':' accType= type )? '=' accExpr= oclExpression ) ) '|' body= oclExpression ')' -> ^( ITERATE[$it] ( ^( DECL $itName ( $itType)? ) )? ^( ACC $accName ( $accType)? $accExpr) $body) )
			int alt47=2;
			try { DebugEnterDecision(47, false);
			int LA47_0 = input.LA(1);

			if ((LA47_0==SimpleName))
			{
				alt47 = 1;
			}
			else if ((LA47_0==114))
			{
				alt47 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 47, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(47); }
			switch (alt47)
			{
			case 1:
				DebugEnterAlt(1);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:175:4: pathName ( '[' arguments ']' )? ( isMarkedPre )? ( '(' propertyCallParametrs ')' )?
				{
				DebugLocation(175, 4);
				PushFollow(Follow._pathName_in_propertyCall1332);
				pathName86=pathName();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_pathName.Add(pathName86.Tree);
				DebugLocation(175, 13);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:175:13: ( '[' arguments ']' )?
				int alt40=2;
				try { DebugEnterSubRule(40);
				try { DebugEnterDecision(40, false);
				int LA40_0 = input.LA(1);

				if ((LA40_0==97))
				{
					alt40 = 1;
				}
				} finally { DebugExitDecision(40); }
				switch (alt40)
				{
				case 1:
					DebugEnterAlt(1);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:175:14: '[' arguments ']'
					{
					DebugLocation(175, 14);
					char_literal87=(CommonToken)Match(input,97,Follow._97_in_propertyCall1335); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_97.Add(char_literal87);

					DebugLocation(175, 17);
					PushFollow(Follow._arguments_in_propertyCall1336);
					arguments88=arguments();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_arguments.Add(arguments88.Tree);
					DebugLocation(175, 26);
					char_literal89=(CommonToken)Match(input,98,Follow._98_in_propertyCall1337); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_98.Add(char_literal89);


					}
					break;

				}
				} finally { DebugExitSubRule(40); }

				DebugLocation(175, 32);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:175:32: ( isMarkedPre )?
				int alt41=2;
				try { DebugEnterSubRule(41);
				try { DebugEnterDecision(41, false);
				int LA41_0 = input.LA(1);

				if ((LA41_0==81))
				{
					alt41 = 1;
				}
				} finally { DebugExitDecision(41); }
				switch (alt41)
				{
				case 1:
					DebugEnterAlt(1);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:175:32: isMarkedPre
					{
					DebugLocation(175, 32);
					PushFollow(Follow._isMarkedPre_in_propertyCall1341);
					isMarkedPre90=isMarkedPre();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_isMarkedPre.Add(isMarkedPre90.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(41); }

				DebugLocation(175, 45);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:175:45: ( '(' propertyCallParametrs ')' )?
				int alt42=2;
				try { DebugEnterSubRule(42);
				try { DebugEnterDecision(42, false);
				int LA42_0 = input.LA(1);

				if ((LA42_0==63))
				{
					alt42 = 1;
				}
				} finally { DebugExitDecision(42); }
				switch (alt42)
				{
				case 1:
					DebugEnterAlt(1);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:175:46: '(' propertyCallParametrs ')'
					{
					DebugLocation(175, 46);
					char_literal91=(CommonToken)Match(input,63,Follow._63_in_propertyCall1345); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_63.Add(char_literal91);

					DebugLocation(175, 49);
					PushFollow(Follow._propertyCallParametrs_in_propertyCall1346);
					propertyCallParametrs92=propertyCallParametrs();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_propertyCallParametrs.Add(propertyCallParametrs92.Tree);
					DebugLocation(175, 70);
					char_literal93=(CommonToken)Match(input,64,Follow._64_in_propertyCall1347); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_64.Add(char_literal93);


					}
					break;

				}
				} finally { DebugExitSubRule(42); }



				{
				// AST REWRITE
				// elements: pathName, propertyCallParametrs, arguments, isMarkedPre
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 178:4: -> ^( CALL pathName ( propertyCallParametrs )? ( ^( INDEX arguments ) )? ( isMarkedPre )? )
				{
					DebugLocation(178, 6);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:178:6: ^( CALL pathName ( propertyCallParametrs )? ( ^( INDEX arguments ) )? ( isMarkedPre )? )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(178, 8);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(CALL, "CALL"), root_1);

					DebugLocation(178, 13);
					adaptor.AddChild(root_1, stream_pathName.NextTree());
					DebugLocation(178, 22);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:178:22: ( propertyCallParametrs )?
					if (stream_propertyCallParametrs.HasNext)
					{
						DebugLocation(178, 22);
						adaptor.AddChild(root_1, stream_propertyCallParametrs.NextTree());

					}
					stream_propertyCallParametrs.Reset();
					DebugLocation(178, 46);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:178:46: ( ^( INDEX arguments ) )?
					if (stream_arguments.HasNext)
					{
						DebugLocation(178, 46);
						// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:178:46: ^( INDEX arguments )
						{
						object root_2 = (object)adaptor.Nil();
						DebugLocation(178, 48);
						root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(INDEX, "INDEX"), root_2);

						DebugLocation(178, 54);
						adaptor.AddChild(root_2, stream_arguments.NextTree());

						adaptor.AddChild(root_1, root_2);
						}

					}
					stream_arguments.Reset();
					DebugLocation(178, 66);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:178:66: ( isMarkedPre )?
					if (stream_isMarkedPre.HasNext)
					{
						DebugLocation(178, 66);
						adaptor.AddChild(root_1, stream_isMarkedPre.NextTree());

					}
					stream_isMarkedPre.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:183:3: it= 'iterate' '(' ( ( ( SimpleName ( ( ':' ) type )? ';' )=>itName= SimpleName ( ( ':' ) itType= type )? ';' accName= SimpleName ( ':' accType= type )? '=' accExpr= oclExpression ) | (accName= SimpleName ( ':' accType= type )? '=' accExpr= oclExpression ) ) '|' body= oclExpression ')'
				{
				DebugLocation(183, 5);
				it=(CommonToken)Match(input,114,Follow._114_in_propertyCall1396); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_114.Add(it);

				DebugLocation(183, 16);
				char_literal94=(CommonToken)Match(input,63,Follow._63_in_propertyCall1398); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_63.Add(char_literal94);

				DebugLocation(183, 20);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:183:20: ( ( ( SimpleName ( ( ':' ) type )? ';' )=>itName= SimpleName ( ( ':' ) itType= type )? ';' accName= SimpleName ( ':' accType= type )? '=' accExpr= oclExpression ) | (accName= SimpleName ( ':' accType= type )? '=' accExpr= oclExpression ) )
				int alt46=2;
				try { DebugEnterSubRule(46);
				try { DebugEnterDecision(46, false);
				int LA46_0 = input.LA(1);

				if ((LA46_0==SimpleName))
				{
					int LA46_1 = input.LA(2);

					if ((EvaluatePredicate(synpred1_OCLSyntax_fragment)))
					{
						alt46 = 1;
					}
					else if ((true))
					{
						alt46 = 2;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 46, 1, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 46, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				} finally { DebugExitDecision(46); }
				switch (alt46)
				{
				case 1:
					DebugEnterAlt(1);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:184:5: ( ( SimpleName ( ( ':' ) type )? ';' )=>itName= SimpleName ( ( ':' ) itType= type )? ';' accName= SimpleName ( ':' accType= type )? '=' accExpr= oclExpression )
					{
					DebugLocation(184, 5);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:184:5: ( ( SimpleName ( ( ':' ) type )? ';' )=>itName= SimpleName ( ( ':' ) itType= type )? ';' accName= SimpleName ( ':' accType= type )? '=' accExpr= oclExpression )
					DebugEnterAlt(1);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:184:6: ( SimpleName ( ( ':' ) type )? ';' )=>itName= SimpleName ( ( ':' ) itType= type )? ';' accName= SimpleName ( ':' accType= type )? '=' accExpr= oclExpression
					{
					DebugLocation(184, 44);
					itName=(CommonToken)Match(input,SimpleName,Follow._SimpleName_in_propertyCall1425); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_SimpleName.Add(itName);

					DebugLocation(184, 56);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:184:56: ( ( ':' ) itType= type )?
					int alt43=2;
					try { DebugEnterSubRule(43);
					try { DebugEnterDecision(43, false);
					int LA43_0 = input.LA(1);

					if ((LA43_0==71))
					{
						alt43 = 1;
					}
					} finally { DebugExitDecision(43); }
					switch (alt43)
					{
					case 1:
						DebugEnterAlt(1);
						// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:184:57: ( ':' ) itType= type
						{
						DebugLocation(184, 57);
						// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:184:57: ( ':' )
						DebugEnterAlt(1);
						// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:184:58: ':'
						{
						DebugLocation(184, 58);
						char_literal95=(CommonToken)Match(input,71,Follow._71_in_propertyCall1429); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_71.Add(char_literal95);


						}

						DebugLocation(184, 70);
						PushFollow(Follow._type_in_propertyCall1436);
						itType=type();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_type.Add(itType.Tree);

						}
						break;

					}
					} finally { DebugExitSubRule(43); }

					DebugLocation(184, 79);
					char_literal96=(CommonToken)Match(input,73,Follow._73_in_propertyCall1440); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_73.Add(char_literal96);

					DebugLocation(184, 90);
					accName=(CommonToken)Match(input,SimpleName,Follow._SimpleName_in_propertyCall1445); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_SimpleName.Add(accName);

					DebugLocation(184, 103);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:184:103: ( ':' accType= type )?
					int alt44=2;
					try { DebugEnterSubRule(44);
					try { DebugEnterDecision(44, false);
					int LA44_0 = input.LA(1);

					if ((LA44_0==71))
					{
						alt44 = 1;
					}
					} finally { DebugExitDecision(44); }
					switch (alt44)
					{
					case 1:
						DebugEnterAlt(1);
						// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:184:104: ':' accType= type
						{
						DebugLocation(184, 104);
						char_literal97=(CommonToken)Match(input,71,Follow._71_in_propertyCall1448); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_71.Add(char_literal97);

						DebugLocation(184, 116);
						PushFollow(Follow._type_in_propertyCall1454);
						accType=type();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_type.Add(accType.Tree);

						}
						break;

					}
					} finally { DebugExitSubRule(44); }

					DebugLocation(184, 124);
					char_literal98=(CommonToken)Match(input,77,Follow._77_in_propertyCall1457); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_77.Add(char_literal98);

					DebugLocation(184, 136);
					PushFollow(Follow._oclExpression_in_propertyCall1463);
					accExpr=oclExpression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_oclExpression.Add(accExpr.Tree);

					}


					}
					break;
				case 2:
					DebugEnterAlt(2);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:185:7: (accName= SimpleName ( ':' accType= type )? '=' accExpr= oclExpression )
					{
					DebugLocation(185, 7);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:185:7: (accName= SimpleName ( ':' accType= type )? '=' accExpr= oclExpression )
					DebugEnterAlt(1);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:185:8: accName= SimpleName ( ':' accType= type )? '=' accExpr= oclExpression
					{
					DebugLocation(185, 16);
					accName=(CommonToken)Match(input,SimpleName,Follow._SimpleName_in_propertyCall1479); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_SimpleName.Add(accName);

					DebugLocation(185, 29);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:185:29: ( ':' accType= type )?
					int alt45=2;
					try { DebugEnterSubRule(45);
					try { DebugEnterDecision(45, false);
					int LA45_0 = input.LA(1);

					if ((LA45_0==71))
					{
						alt45 = 1;
					}
					} finally { DebugExitDecision(45); }
					switch (alt45)
					{
					case 1:
						DebugEnterAlt(1);
						// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:185:30: ':' accType= type
						{
						DebugLocation(185, 30);
						char_literal99=(CommonToken)Match(input,71,Follow._71_in_propertyCall1482); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_71.Add(char_literal99);

						DebugLocation(185, 42);
						PushFollow(Follow._type_in_propertyCall1487);
						accType=type();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_type.Add(accType.Tree);

						}
						break;

					}
					} finally { DebugExitSubRule(45); }

					DebugLocation(185, 49);
					char_literal100=(CommonToken)Match(input,77,Follow._77_in_propertyCall1490); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_77.Add(char_literal100);

					DebugLocation(185, 62);
					PushFollow(Follow._oclExpression_in_propertyCall1496);
					accExpr=oclExpression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_oclExpression.Add(accExpr.Tree);

					}


					}
					break;

				}
				} finally { DebugExitSubRule(46); }

				DebugLocation(187, 4);
				char_literal101=(CommonToken)Match(input,128,Follow._128_in_propertyCall1508); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_128.Add(char_literal101);

				DebugLocation(187, 13);
				PushFollow(Follow._oclExpression_in_propertyCall1514);
				body=oclExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_oclExpression.Add(body.Tree);
				DebugLocation(187, 29);
				char_literal102=(CommonToken)Match(input,64,Follow._64_in_propertyCall1516); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_64.Add(char_literal102);



				{
				// AST REWRITE
				// elements: itName, itType, accName, accType, accExpr, body
				// token labels: itName, accName
				// rule labels: itType, accType, accExpr, body, retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleITokenStream stream_itName=new RewriteRuleITokenStream(adaptor,"token itName",itName);
				RewriteRuleITokenStream stream_accName=new RewriteRuleITokenStream(adaptor,"token accName",accName);
				RewriteRuleSubtreeStream stream_itType=new RewriteRuleSubtreeStream(adaptor,"rule itType",itType!=null?itType.Tree:null);
				RewriteRuleSubtreeStream stream_accType=new RewriteRuleSubtreeStream(adaptor,"rule accType",accType!=null?accType.Tree:null);
				RewriteRuleSubtreeStream stream_accExpr=new RewriteRuleSubtreeStream(adaptor,"rule accExpr",accExpr!=null?accExpr.Tree:null);
				RewriteRuleSubtreeStream stream_body=new RewriteRuleSubtreeStream(adaptor,"rule body",body!=null?body.Tree:null);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 188:3: -> ^( ITERATE[$it] ( ^( DECL $itName ( $itType)? ) )? ^( ACC $accName ( $accType)? $accExpr) $body)
				{
					DebugLocation(188, 5);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:188:5: ^( ITERATE[$it] ( ^( DECL $itName ( $itType)? ) )? ^( ACC $accName ( $accType)? $accExpr) $body)
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(188, 7);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(ITERATE, it), root_1);

					DebugLocation(188, 21);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:188:21: ( ^( DECL $itName ( $itType)? ) )?
					if (stream_itName.HasNext||stream_itType.HasNext)
					{
						DebugLocation(188, 21);
						// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:188:21: ^( DECL $itName ( $itType)? )
						{
						object root_2 = (object)adaptor.Nil();
						DebugLocation(188, 23);
						root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(DECL, "DECL"), root_2);

						DebugLocation(188, 29);
						adaptor.AddChild(root_2, stream_itName.NextNode());
						DebugLocation(188, 37);
						// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:188:37: ( $itType)?
						if (stream_itType.HasNext)
						{
							DebugLocation(188, 37);
							adaptor.AddChild(root_2, stream_itType.NextTree());

						}
						stream_itType.Reset();

						adaptor.AddChild(root_1, root_2);
						}

					}
					stream_itName.Reset();
					stream_itType.Reset();
					DebugLocation(188, 47);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:188:47: ^( ACC $accName ( $accType)? $accExpr)
					{
					object root_2 = (object)adaptor.Nil();
					DebugLocation(188, 49);
					root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(ACC, "ACC"), root_2);

					DebugLocation(188, 54);
					adaptor.AddChild(root_2, stream_accName.NextNode());
					DebugLocation(188, 63);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:188:63: ( $accType)?
					if (stream_accType.HasNext)
					{
						DebugLocation(188, 63);
						adaptor.AddChild(root_2, stream_accType.NextTree());

					}
					stream_accType.Reset();
					DebugLocation(188, 73);
					adaptor.AddChild(root_2, stream_accExpr.NextTree());

					adaptor.AddChild(root_1, root_2);
					}
					DebugLocation(188, 83);
					adaptor.AddChild(root_1, stream_body.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("propertyCall", 29);
			LeaveRule("propertyCall", 29);
			LeaveRule_propertyCall();
		}
		DebugLocation(191, 1);
		} finally { DebugExitRule(GrammarFileName, "propertyCall"); }
		return retval;

	}
	// $ANTLR end "propertyCall"

	private sealed partial class propertyCallParametrs_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public propertyCallParametrs_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_propertyCallParametrs();
	partial void LeaveRule_propertyCallParametrs();

	// $ANTLR start "propertyCallParametrs"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:192:1: propertyCallParametrs : ( declarePropertyCallParametrs )? ( arguments )? -> ^( ARGS ( declarePropertyCallParametrs )? ( arguments )? ) ;
	[GrammarRule("propertyCallParametrs")]
	private OCLSyntaxParser.propertyCallParametrs_return propertyCallParametrs()
	{
		EnterRule_propertyCallParametrs();
		EnterRule("propertyCallParametrs", 30);
		TraceIn("propertyCallParametrs", 30);
		OCLSyntaxParser.propertyCallParametrs_return retval = new OCLSyntaxParser.propertyCallParametrs_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		OCLSyntaxParser.declarePropertyCallParametrs_return declarePropertyCallParametrs103 = default(OCLSyntaxParser.declarePropertyCallParametrs_return);
		OCLSyntaxParser.arguments_return arguments104 = default(OCLSyntaxParser.arguments_return);

		RewriteRuleSubtreeStream stream_declarePropertyCallParametrs=new RewriteRuleSubtreeStream(adaptor,"rule declarePropertyCallParametrs");
		RewriteRuleSubtreeStream stream_arguments=new RewriteRuleSubtreeStream(adaptor,"rule arguments");
		try { DebugEnterRule(GrammarFileName, "propertyCallParametrs");
		DebugLocation(192, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:193:2: ( ( declarePropertyCallParametrs )? ( arguments )? -> ^( ARGS ( declarePropertyCallParametrs )? ( arguments )? ) )
			DebugEnterAlt(1);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:193:4: ( declarePropertyCallParametrs )? ( arguments )?
			{
			DebugLocation(193, 4);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:193:4: ( declarePropertyCallParametrs )?
			int alt48=2;
			try { DebugEnterSubRule(48);
			try { DebugEnterDecision(48, false);
			int LA48_0 = input.LA(1);

			if ((LA48_0==SimpleName))
			{
				int LA48_1 = input.LA(2);

				if ((LA48_1==71||LA48_1==128))
				{
					alt48 = 1;
				}
				else if ((LA48_1==66))
				{
					int LA48_4 = input.LA(3);

					if ((LA48_4==SimpleName))
					{
						int LA48_5 = input.LA(4);

						if ((LA48_5==71||LA48_5==128))
						{
							alt48 = 1;
						}
					}
				}
			}
			} finally { DebugExitDecision(48); }
			switch (alt48)
			{
			case 1:
				DebugEnterAlt(1);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:193:4: declarePropertyCallParametrs
				{
				DebugLocation(193, 4);
				PushFollow(Follow._declarePropertyCallParametrs_in_propertyCallParametrs1572);
				declarePropertyCallParametrs103=declarePropertyCallParametrs();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_declarePropertyCallParametrs.Add(declarePropertyCallParametrs103.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(48); }

			DebugLocation(193, 34);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:193:34: ( arguments )?
			int alt49=2;
			try { DebugEnterSubRule(49);
			try { DebugEnterDecision(49, false);
			int LA49_0 = input.LA(1);

			if (((LA49_0>=IntegerLiteralExp && LA49_0<=InvalidLiteralExp)||LA49_0==NullLiteralExp||(LA49_0>=RealLiteralExp && LA49_0<=SimpleName)||LA49_0==StringLiteralExp||LA49_0==UnlimitedNaturalLiteralExp||LA49_0==63||LA49_0==67||(LA49_0>=82 && LA49_0<=96)||(LA49_0>=108 && LA49_0<=109)||(LA49_0>=114 && LA49_0<=115)||(LA49_0>=117 && LA49_0<=118)||LA49_0==125))
			{
				alt49 = 1;
			}
			} finally { DebugExitDecision(49); }
			switch (alt49)
			{
			case 1:
				DebugEnterAlt(1);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:193:34: arguments
				{
				DebugLocation(193, 34);
				PushFollow(Follow._arguments_in_propertyCallParametrs1575);
				arguments104=arguments();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_arguments.Add(arguments104.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(49); }



			{
			// AST REWRITE
			// elements: declarePropertyCallParametrs, arguments
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 193:45: -> ^( ARGS ( declarePropertyCallParametrs )? ( arguments )? )
			{
				DebugLocation(193, 48);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:193:48: ^( ARGS ( declarePropertyCallParametrs )? ( arguments )? )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(193, 50);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(ARGS, "ARGS"), root_1);

				DebugLocation(193, 55);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:193:55: ( declarePropertyCallParametrs )?
				if (stream_declarePropertyCallParametrs.HasNext)
				{
					DebugLocation(193, 55);
					adaptor.AddChild(root_1, stream_declarePropertyCallParametrs.NextTree());

				}
				stream_declarePropertyCallParametrs.Reset();
				DebugLocation(193, 85);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:193:85: ( arguments )?
				if (stream_arguments.HasNext)
				{
					DebugLocation(193, 85);
					adaptor.AddChild(root_1, stream_arguments.NextTree());

				}
				stream_arguments.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("propertyCallParametrs", 30);
			LeaveRule("propertyCallParametrs", 30);
			LeaveRule_propertyCallParametrs();
		}
		DebugLocation(196, 1);
		} finally { DebugExitRule(GrammarFileName, "propertyCallParametrs"); }
		return retval;

	}
	// $ANTLR end "propertyCallParametrs"

	private sealed partial class declarePropertyCallParametrs_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public declarePropertyCallParametrs_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_declarePropertyCallParametrs();
	partial void LeaveRule_declarePropertyCallParametrs();

	// $ANTLR start "declarePropertyCallParametrs"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:197:1: declarePropertyCallParametrs : (t1= typedef ( ',' t2= typedef )? '|' ) -> ^( VARDECL $t1 ( $t2)? ) ;
	[GrammarRule("declarePropertyCallParametrs")]
	private OCLSyntaxParser.declarePropertyCallParametrs_return declarePropertyCallParametrs()
	{
		EnterRule_declarePropertyCallParametrs();
		EnterRule("declarePropertyCallParametrs", 31);
		TraceIn("declarePropertyCallParametrs", 31);
		OCLSyntaxParser.declarePropertyCallParametrs_return retval = new OCLSyntaxParser.declarePropertyCallParametrs_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		CommonToken char_literal105 = default(CommonToken);
		CommonToken char_literal106 = default(CommonToken);
		OCLSyntaxParser.typedef_return t1 = default(OCLSyntaxParser.typedef_return);
		OCLSyntaxParser.typedef_return t2 = default(OCLSyntaxParser.typedef_return);

		object char_literal105_tree = default(object);
		object char_literal106_tree = default(object);
		RewriteRuleITokenStream stream_66=new RewriteRuleITokenStream(adaptor,"token 66");
		RewriteRuleITokenStream stream_128=new RewriteRuleITokenStream(adaptor,"token 128");
		RewriteRuleSubtreeStream stream_typedef=new RewriteRuleSubtreeStream(adaptor,"rule typedef");
		try { DebugEnterRule(GrammarFileName, "declarePropertyCallParametrs");
		DebugLocation(197, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:198:2: ( (t1= typedef ( ',' t2= typedef )? '|' ) -> ^( VARDECL $t1 ( $t2)? ) )
			DebugEnterAlt(1);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:198:4: (t1= typedef ( ',' t2= typedef )? '|' )
			{
			DebugLocation(198, 4);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:198:4: (t1= typedef ( ',' t2= typedef )? '|' )
			DebugEnterAlt(1);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:198:6: t1= typedef ( ',' t2= typedef )? '|'
			{
			DebugLocation(198, 8);
			PushFollow(Follow._typedef_in_declarePropertyCallParametrs1609);
			t1=typedef();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_typedef.Add(t1.Tree);
			DebugLocation(198, 17);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:198:17: ( ',' t2= typedef )?
			int alt50=2;
			try { DebugEnterSubRule(50);
			try { DebugEnterDecision(50, false);
			int LA50_0 = input.LA(1);

			if ((LA50_0==66))
			{
				alt50 = 1;
			}
			} finally { DebugExitDecision(50); }
			switch (alt50)
			{
			case 1:
				DebugEnterAlt(1);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:198:18: ',' t2= typedef
				{
				DebugLocation(198, 18);
				char_literal105=(CommonToken)Match(input,66,Follow._66_in_declarePropertyCallParametrs1612); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_66.Add(char_literal105);

				DebugLocation(198, 24);
				PushFollow(Follow._typedef_in_declarePropertyCallParametrs1616);
				t2=typedef();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_typedef.Add(t2.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(50); }

			DebugLocation(198, 35);
			char_literal106=(CommonToken)Match(input,128,Follow._128_in_declarePropertyCallParametrs1620); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_128.Add(char_literal106);


			}



			{
			// AST REWRITE
			// elements: t1, t2
			// token labels: 
			// rule labels: t1, t2, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_t1=new RewriteRuleSubtreeStream(adaptor,"rule t1",t1!=null?t1.Tree:null);
			RewriteRuleSubtreeStream stream_t2=new RewriteRuleSubtreeStream(adaptor,"rule t2",t2!=null?t2.Tree:null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 199:3: -> ^( VARDECL $t1 ( $t2)? )
			{
				DebugLocation(199, 6);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:199:6: ^( VARDECL $t1 ( $t2)? )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(199, 8);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(VARDECL, "VARDECL"), root_1);

				DebugLocation(199, 17);
				adaptor.AddChild(root_1, stream_t1.NextTree());
				DebugLocation(199, 21);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:199:21: ( $t2)?
				if (stream_t2.HasNext)
				{
					DebugLocation(199, 21);
					adaptor.AddChild(root_1, stream_t2.NextTree());

				}
				stream_t2.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("declarePropertyCallParametrs", 31);
			LeaveRule("declarePropertyCallParametrs", 31);
			LeaveRule_declarePropertyCallParametrs();
		}
		DebugLocation(201, 1);
		} finally { DebugExitRule(GrammarFileName, "declarePropertyCallParametrs"); }
		return retval;

	}
	// $ANTLR end "declarePropertyCallParametrs"

	private sealed partial class typedef_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public typedef_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_typedef();
	partial void LeaveRule_typedef();

	// $ANTLR start "typedef"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:202:1: typedef : SimpleName ( ':' type )? -> ^( DECL SimpleName ( type )? ) ;
	[GrammarRule("typedef")]
	private OCLSyntaxParser.typedef_return typedef()
	{
		EnterRule_typedef();
		EnterRule("typedef", 32);
		TraceIn("typedef", 32);
		OCLSyntaxParser.typedef_return retval = new OCLSyntaxParser.typedef_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		CommonToken SimpleName107 = default(CommonToken);
		CommonToken char_literal108 = default(CommonToken);
		OCLSyntaxParser.type_return type109 = default(OCLSyntaxParser.type_return);

		object SimpleName107_tree = default(object);
		object char_literal108_tree = default(object);
		RewriteRuleITokenStream stream_SimpleName=new RewriteRuleITokenStream(adaptor,"token SimpleName");
		RewriteRuleITokenStream stream_71=new RewriteRuleITokenStream(adaptor,"token 71");
		RewriteRuleSubtreeStream stream_type=new RewriteRuleSubtreeStream(adaptor,"rule type");
		try { DebugEnterRule(GrammarFileName, "typedef");
		DebugLocation(202, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:203:2: ( SimpleName ( ':' type )? -> ^( DECL SimpleName ( type )? ) )
			DebugEnterAlt(1);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:203:4: SimpleName ( ':' type )?
			{
			DebugLocation(203, 4);
			SimpleName107=(CommonToken)Match(input,SimpleName,Follow._SimpleName_in_typedef1648); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_SimpleName.Add(SimpleName107);

			DebugLocation(203, 14);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:203:14: ( ':' type )?
			int alt51=2;
			try { DebugEnterSubRule(51);
			try { DebugEnterDecision(51, false);
			int LA51_0 = input.LA(1);

			if ((LA51_0==71))
			{
				alt51 = 1;
			}
			} finally { DebugExitDecision(51); }
			switch (alt51)
			{
			case 1:
				DebugEnterAlt(1);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:203:15: ':' type
				{
				DebugLocation(203, 15);
				char_literal108=(CommonToken)Match(input,71,Follow._71_in_typedef1650); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_71.Add(char_literal108);

				DebugLocation(203, 18);
				PushFollow(Follow._type_in_typedef1651);
				type109=type();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_type.Add(type109.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(51); }



			{
			// AST REWRITE
			// elements: SimpleName, type
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 204:3: -> ^( DECL SimpleName ( type )? )
			{
				DebugLocation(204, 6);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:204:6: ^( DECL SimpleName ( type )? )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(204, 8);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(DECL, "DECL"), root_1);

				DebugLocation(204, 13);
				adaptor.AddChild(root_1, stream_SimpleName.NextNode());
				DebugLocation(204, 24);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:204:24: ( type )?
				if (stream_type.HasNext)
				{
					DebugLocation(204, 24);
					adaptor.AddChild(root_1, stream_type.NextTree());

				}
				stream_type.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("typedef", 32);
			LeaveRule("typedef", 32);
			LeaveRule_typedef();
		}
		DebugLocation(205, 1);
		} finally { DebugExitRule(GrammarFileName, "typedef"); }
		return retval;

	}
	// $ANTLR end "typedef"

	private sealed partial class enumAndType_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public enumAndType_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_enumAndType();
	partial void LeaveRule_enumAndType();

	// $ANTLR start "enumAndType"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:207:1: enumAndType : ( tupleType tupleType | primitiveType primitiveType | oclType oclType );
	[GrammarRule("enumAndType")]
	private OCLSyntaxParser.enumAndType_return enumAndType()
	{
		EnterRule_enumAndType();
		EnterRule("enumAndType", 33);
		TraceIn("enumAndType", 33);
		OCLSyntaxParser.enumAndType_return retval = new OCLSyntaxParser.enumAndType_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		OCLSyntaxParser.tupleType_return tupleType110 = default(OCLSyntaxParser.tupleType_return);
		OCLSyntaxParser.tupleType_return tupleType111 = default(OCLSyntaxParser.tupleType_return);
		OCLSyntaxParser.primitiveType_return primitiveType112 = default(OCLSyntaxParser.primitiveType_return);
		OCLSyntaxParser.primitiveType_return primitiveType113 = default(OCLSyntaxParser.primitiveType_return);
		OCLSyntaxParser.oclType_return oclType114 = default(OCLSyntaxParser.oclType_return);
		OCLSyntaxParser.oclType_return oclType115 = default(OCLSyntaxParser.oclType_return);


		try { DebugEnterRule(GrammarFileName, "enumAndType");
		DebugLocation(207, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:211:2: ( tupleType tupleType | primitiveType primitiveType | oclType oclType )
			int alt52=3;
			try { DebugEnterDecision(52, false);
			switch (input.LA(1))
			{
			case 95:
				{
				alt52 = 1;
				}
				break;
			case 83:
			case 85:
			case 91:
			case 94:
			case 96:
				{
				alt52 = 2;
				}
				break;
			case 86:
			case 87:
			case 88:
			case 89:
				{
				alt52 = 3;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 52, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(52); }
			switch (alt52)
			{
			case 1:
				DebugEnterAlt(1);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:211:4: tupleType tupleType
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(211, 4);
				PushFollow(Follow._tupleType_in_enumAndType1688);
				tupleType110=tupleType();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, tupleType110.Tree);
				DebugLocation(212, 4);
				PushFollow(Follow._tupleType_in_enumAndType1696);
				tupleType111=tupleType();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, tupleType111.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:213:4: primitiveType primitiveType
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(213, 4);
				PushFollow(Follow._primitiveType_in_enumAndType1701);
				primitiveType112=primitiveType();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, primitiveType112.Tree);
				DebugLocation(214, 4);
				PushFollow(Follow._primitiveType_in_enumAndType1706);
				primitiveType113=primitiveType();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, primitiveType113.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:215:4: oclType oclType
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(215, 4);
				PushFollow(Follow._oclType_in_enumAndType1711);
				oclType114=oclType();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, oclType114.Tree);
				DebugLocation(216, 3);
				PushFollow(Follow._oclType_in_enumAndType1715);
				oclType115=oclType();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, oclType115.Tree);

				}
				break;

			}
			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("enumAndType", 33);
			LeaveRule("enumAndType", 33);
			LeaveRule_enumAndType();
		}
		DebugLocation(218, 1);
		} finally { DebugExitRule(GrammarFileName, "enumAndType"); }
		return retval;

	}
	// $ANTLR end "enumAndType"

	private sealed partial class pathName_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public pathName_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_pathName();
	partial void LeaveRule_pathName();

	// $ANTLR start "pathName"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:222:1: pathName : SimpleName ( '::' SimpleName )* -> ^( PATH ( SimpleName )+ ) ;
	[GrammarRule("pathName")]
	private OCLSyntaxParser.pathName_return pathName()
	{
		EnterRule_pathName();
		EnterRule("pathName", 34);
		TraceIn("pathName", 34);
		OCLSyntaxParser.pathName_return retval = new OCLSyntaxParser.pathName_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		CommonToken SimpleName116 = default(CommonToken);
		CommonToken string_literal117 = default(CommonToken);
		CommonToken SimpleName118 = default(CommonToken);

		object SimpleName116_tree = default(object);
		object string_literal117_tree = default(object);
		object SimpleName118_tree = default(object);
		RewriteRuleITokenStream stream_SimpleName=new RewriteRuleITokenStream(adaptor,"token SimpleName");
		RewriteRuleITokenStream stream_72=new RewriteRuleITokenStream(adaptor,"token 72");

		try { DebugEnterRule(GrammarFileName, "pathName");
		DebugLocation(222, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:224:2: ( SimpleName ( '::' SimpleName )* -> ^( PATH ( SimpleName )+ ) )
			DebugEnterAlt(1);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:224:4: SimpleName ( '::' SimpleName )*
			{
			DebugLocation(224, 4);
			SimpleName116=(CommonToken)Match(input,SimpleName,Follow._SimpleName_in_pathName1732); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_SimpleName.Add(SimpleName116);

			DebugLocation(224, 15);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:224:15: ( '::' SimpleName )*
			try { DebugEnterSubRule(53);
			while (true)
			{
				int alt53=2;
				try { DebugEnterDecision(53, false);
				int LA53_0 = input.LA(1);

				if ((LA53_0==72))
				{
					int LA53_2 = input.LA(2);

					if ((LA53_2==SimpleName))
					{
						int LA53_3 = input.LA(3);

						if ((LA53_3==EOF))
						{
							int LA53_4 = input.LA(4);

							if ((LA53_4==EOF))
							{
								alt53 = 1;
							}


						}
						else if ((LA53_3==DoubleDot||LA53_3==UnlimitedNaturalLiteralExp||(LA53_3>=63 && LA53_3<=70)||(LA53_3>=72 && LA53_3<=79)||LA53_3==81||(LA53_3>=97 && LA53_3<=107)||(LA53_3>=110 && LA53_3<=113)||LA53_3==116||(LA53_3>=119 && LA53_3<=121)||(LA53_3>=123 && LA53_3<=124)||(LA53_3>=126 && LA53_3<=129)))
						{
							alt53 = 1;
						}


					}


				}


				} finally { DebugExitDecision(53); }
				switch ( alt53 )
				{
				case 1:
					DebugEnterAlt(1);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:224:16: '::' SimpleName
					{
					DebugLocation(224, 16);
					string_literal117=(CommonToken)Match(input,72,Follow._72_in_pathName1735); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_72.Add(string_literal117);

					DebugLocation(224, 21);
					SimpleName118=(CommonToken)Match(input,SimpleName,Follow._SimpleName_in_pathName1737); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_SimpleName.Add(SimpleName118);


					}
					break;

				default:
					goto loop53;
				}
			}

			loop53:
				;

			} finally { DebugExitSubRule(53); }



			{
			// AST REWRITE
			// elements: SimpleName
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 225:3: -> ^( PATH ( SimpleName )+ )
			{
				DebugLocation(225, 6);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:225:6: ^( PATH ( SimpleName )+ )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(225, 8);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(PATH, "PATH"), root_1);

				DebugLocation(225, 13);
				if (!(stream_SimpleName.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_SimpleName.HasNext )
				{
					DebugLocation(225, 13);
					adaptor.AddChild(root_1, stream_SimpleName.NextNode());

				}
				stream_SimpleName.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("pathName", 34);
			LeaveRule("pathName", 34);
			LeaveRule_pathName();
		}
		DebugLocation(226, 1);
		} finally { DebugExitRule(GrammarFileName, "pathName"); }
		return retval;

	}
	// $ANTLR end "pathName"

	private sealed partial class collectionLiteralExpAndType_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public collectionLiteralExpAndType_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_collectionLiteralExpAndType();
	partial void LeaveRule_collectionLiteralExpAndType();

	// $ANTLR start "collectionLiteralExpAndType"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:229:1: collectionLiteralExpAndType : ( collectionTypeIdentifier ( '{' ( collectionLiteralParts )? '}' )? -> ^( COLLECTIONLITERAL collectionTypeIdentifier ( collectionLiteralParts )? ) | collectionTypeIdentifier ( '(' type ')' ) ( ( '{' ( collectionLiteralParts )? '}' -> ^( COLLECTIONLITERAL collectionTypeIdentifier type ( collectionLiteralParts )? ) ) | -> ^( COLLTYPE collectionTypeIdentifier type ) ) );
	[GrammarRule("collectionLiteralExpAndType")]
	private OCLSyntaxParser.collectionLiteralExpAndType_return collectionLiteralExpAndType()
	{
		EnterRule_collectionLiteralExpAndType();
		EnterRule("collectionLiteralExpAndType", 35);
		TraceIn("collectionLiteralExpAndType", 35);
		OCLSyntaxParser.collectionLiteralExpAndType_return retval = new OCLSyntaxParser.collectionLiteralExpAndType_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		CommonToken char_literal120 = default(CommonToken);
		CommonToken char_literal122 = default(CommonToken);
		CommonToken char_literal124 = default(CommonToken);
		CommonToken char_literal126 = default(CommonToken);
		CommonToken char_literal127 = default(CommonToken);
		CommonToken char_literal129 = default(CommonToken);
		OCLSyntaxParser.collectionTypeIdentifier_return collectionTypeIdentifier119 = default(OCLSyntaxParser.collectionTypeIdentifier_return);
		OCLSyntaxParser.collectionLiteralParts_return collectionLiteralParts121 = default(OCLSyntaxParser.collectionLiteralParts_return);
		OCLSyntaxParser.collectionTypeIdentifier_return collectionTypeIdentifier123 = default(OCLSyntaxParser.collectionTypeIdentifier_return);
		OCLSyntaxParser.type_return type125 = default(OCLSyntaxParser.type_return);
		OCLSyntaxParser.collectionLiteralParts_return collectionLiteralParts128 = default(OCLSyntaxParser.collectionLiteralParts_return);

		object char_literal120_tree = default(object);
		object char_literal122_tree = default(object);
		object char_literal124_tree = default(object);
		object char_literal126_tree = default(object);
		object char_literal127_tree = default(object);
		object char_literal129_tree = default(object);
		RewriteRuleITokenStream stream_127=new RewriteRuleITokenStream(adaptor,"token 127");
		RewriteRuleITokenStream stream_129=new RewriteRuleITokenStream(adaptor,"token 129");
		RewriteRuleITokenStream stream_63=new RewriteRuleITokenStream(adaptor,"token 63");
		RewriteRuleITokenStream stream_64=new RewriteRuleITokenStream(adaptor,"token 64");
		RewriteRuleSubtreeStream stream_collectionTypeIdentifier=new RewriteRuleSubtreeStream(adaptor,"rule collectionTypeIdentifier");
		RewriteRuleSubtreeStream stream_collectionLiteralParts=new RewriteRuleSubtreeStream(adaptor,"rule collectionLiteralParts");
		RewriteRuleSubtreeStream stream_type=new RewriteRuleSubtreeStream(adaptor,"rule type");
		try { DebugEnterRule(GrammarFileName, "collectionLiteralExpAndType");
		DebugLocation(229, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:231:2: ( collectionTypeIdentifier ( '{' ( collectionLiteralParts )? '}' )? -> ^( COLLECTIONLITERAL collectionTypeIdentifier ( collectionLiteralParts )? ) | collectionTypeIdentifier ( '(' type ')' ) ( ( '{' ( collectionLiteralParts )? '}' -> ^( COLLECTIONLITERAL collectionTypeIdentifier type ( collectionLiteralParts )? ) ) | -> ^( COLLTYPE collectionTypeIdentifier type ) ) )
			int alt58=2;
			try { DebugEnterDecision(58, false);
			int LA58_0 = input.LA(1);

			if ((LA58_0==82||LA58_0==84||LA58_0==90||(LA58_0>=92 && LA58_0<=93)))
			{
				int LA58_1 = input.LA(2);

				if ((LA58_1==EOF||LA58_1==DoubleDot||LA58_1==UnlimitedNaturalLiteralExp||(LA58_1>=64 && LA58_1<=70)||(LA58_1>=74 && LA58_1<=79)||(LA58_1>=98 && LA58_1<=107)||(LA58_1>=110 && LA58_1<=113)||LA58_1==116||(LA58_1>=119 && LA58_1<=121)||(LA58_1>=123 && LA58_1<=124)||(LA58_1>=126 && LA58_1<=129)))
				{
					alt58 = 1;
				}
				else if ((LA58_1==63))
				{
					alt58 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 58, 1, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 58, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(58); }
			switch (alt58)
			{
			case 1:
				DebugEnterAlt(1);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:231:3: collectionTypeIdentifier ( '{' ( collectionLiteralParts )? '}' )?
				{
				DebugLocation(231, 3);
				PushFollow(Follow._collectionTypeIdentifier_in_collectionLiteralExpAndType1766);
				collectionTypeIdentifier119=collectionTypeIdentifier();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_collectionTypeIdentifier.Add(collectionTypeIdentifier119.Tree);
				DebugLocation(231, 28);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:231:28: ( '{' ( collectionLiteralParts )? '}' )?
				int alt55=2;
				try { DebugEnterSubRule(55);
				try { DebugEnterDecision(55, false);
				int LA55_0 = input.LA(1);

				if ((LA55_0==127))
				{
					alt55 = 1;
				}
				} finally { DebugExitDecision(55); }
				switch (alt55)
				{
				case 1:
					DebugEnterAlt(1);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:231:29: '{' ( collectionLiteralParts )? '}'
					{
					DebugLocation(231, 29);
					char_literal120=(CommonToken)Match(input,127,Follow._127_in_collectionLiteralExpAndType1769); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_127.Add(char_literal120);

					DebugLocation(231, 33);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:231:33: ( collectionLiteralParts )?
					int alt54=2;
					try { DebugEnterSubRule(54);
					try { DebugEnterDecision(54, false);
					int LA54_0 = input.LA(1);

					if (((LA54_0>=IntegerLiteralExp && LA54_0<=InvalidLiteralExp)||LA54_0==NullLiteralExp||(LA54_0>=RealLiteralExp && LA54_0<=SimpleName)||LA54_0==StringLiteralExp||LA54_0==UnlimitedNaturalLiteralExp||LA54_0==63||LA54_0==67||(LA54_0>=82 && LA54_0<=96)||(LA54_0>=108 && LA54_0<=109)||(LA54_0>=114 && LA54_0<=115)||(LA54_0>=117 && LA54_0<=118)||LA54_0==125))
					{
						alt54 = 1;
					}
					} finally { DebugExitDecision(54); }
					switch (alt54)
					{
					case 1:
						DebugEnterAlt(1);
						// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:231:33: collectionLiteralParts
						{
						DebugLocation(231, 33);
						PushFollow(Follow._collectionLiteralParts_in_collectionLiteralExpAndType1771);
						collectionLiteralParts121=collectionLiteralParts();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_collectionLiteralParts.Add(collectionLiteralParts121.Tree);

						}
						break;

					}
					} finally { DebugExitSubRule(54); }

					DebugLocation(231, 57);
					char_literal122=(CommonToken)Match(input,129,Follow._129_in_collectionLiteralExpAndType1774); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_129.Add(char_literal122);


					}
					break;

				}
				} finally { DebugExitSubRule(55); }



				{
				// AST REWRITE
				// elements: collectionTypeIdentifier, collectionLiteralParts
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 232:3: -> ^( COLLECTIONLITERAL collectionTypeIdentifier ( collectionLiteralParts )? )
				{
					DebugLocation(232, 6);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:232:6: ^( COLLECTIONLITERAL collectionTypeIdentifier ( collectionLiteralParts )? )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(232, 8);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(COLLECTIONLITERAL, "COLLECTIONLITERAL"), root_1);

					DebugLocation(232, 26);
					adaptor.AddChild(root_1, stream_collectionTypeIdentifier.NextTree());
					DebugLocation(232, 51);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:232:51: ( collectionLiteralParts )?
					if (stream_collectionLiteralParts.HasNext)
					{
						DebugLocation(232, 51);
						adaptor.AddChild(root_1, stream_collectionLiteralParts.NextTree());

					}
					stream_collectionLiteralParts.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:234:4: collectionTypeIdentifier ( '(' type ')' ) ( ( '{' ( collectionLiteralParts )? '}' -> ^( COLLECTIONLITERAL collectionTypeIdentifier type ( collectionLiteralParts )? ) ) | -> ^( COLLTYPE collectionTypeIdentifier type ) )
				{
				DebugLocation(234, 4);
				PushFollow(Follow._collectionTypeIdentifier_in_collectionLiteralExpAndType1796);
				collectionTypeIdentifier123=collectionTypeIdentifier();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_collectionTypeIdentifier.Add(collectionTypeIdentifier123.Tree);
				DebugLocation(234, 29);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:234:29: ( '(' type ')' )
				DebugEnterAlt(1);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:234:30: '(' type ')'
				{
				DebugLocation(234, 30);
				char_literal124=(CommonToken)Match(input,63,Follow._63_in_collectionLiteralExpAndType1799); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_63.Add(char_literal124);

				DebugLocation(234, 34);
				PushFollow(Follow._type_in_collectionLiteralExpAndType1801);
				type125=type();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_type.Add(type125.Tree);
				DebugLocation(234, 40);
				char_literal126=(CommonToken)Match(input,64,Follow._64_in_collectionLiteralExpAndType1804); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_64.Add(char_literal126);


				}

				DebugLocation(235, 2);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:235:2: ( ( '{' ( collectionLiteralParts )? '}' -> ^( COLLECTIONLITERAL collectionTypeIdentifier type ( collectionLiteralParts )? ) ) | -> ^( COLLTYPE collectionTypeIdentifier type ) )
				int alt57=2;
				try { DebugEnterSubRule(57);
				try { DebugEnterDecision(57, false);
				int LA57_0 = input.LA(1);

				if ((LA57_0==127))
				{
					alt57 = 1;
				}
				else if ((LA57_0==EOF||LA57_0==DoubleDot||LA57_0==UnlimitedNaturalLiteralExp||(LA57_0>=64 && LA57_0<=70)||(LA57_0>=74 && LA57_0<=79)||(LA57_0>=98 && LA57_0<=107)||(LA57_0>=110 && LA57_0<=113)||LA57_0==116||(LA57_0>=119 && LA57_0<=121)||(LA57_0>=123 && LA57_0<=124)||LA57_0==126||(LA57_0>=128 && LA57_0<=129)))
				{
					alt57 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 57, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				} finally { DebugExitDecision(57); }
				switch (alt57)
				{
				case 1:
					DebugEnterAlt(1);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:236:3: ( '{' ( collectionLiteralParts )? '}' -> ^( COLLECTIONLITERAL collectionTypeIdentifier type ( collectionLiteralParts )? ) )
					{
					DebugLocation(236, 3);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:236:3: ( '{' ( collectionLiteralParts )? '}' -> ^( COLLECTIONLITERAL collectionTypeIdentifier type ( collectionLiteralParts )? ) )
					DebugEnterAlt(1);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:236:4: '{' ( collectionLiteralParts )? '}'
					{
					DebugLocation(236, 4);
					char_literal127=(CommonToken)Match(input,127,Follow._127_in_collectionLiteralExpAndType1814); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_127.Add(char_literal127);

					DebugLocation(236, 8);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:236:8: ( collectionLiteralParts )?
					int alt56=2;
					try { DebugEnterSubRule(56);
					try { DebugEnterDecision(56, false);
					int LA56_0 = input.LA(1);

					if (((LA56_0>=IntegerLiteralExp && LA56_0<=InvalidLiteralExp)||LA56_0==NullLiteralExp||(LA56_0>=RealLiteralExp && LA56_0<=SimpleName)||LA56_0==StringLiteralExp||LA56_0==UnlimitedNaturalLiteralExp||LA56_0==63||LA56_0==67||(LA56_0>=82 && LA56_0<=96)||(LA56_0>=108 && LA56_0<=109)||(LA56_0>=114 && LA56_0<=115)||(LA56_0>=117 && LA56_0<=118)||LA56_0==125))
					{
						alt56 = 1;
					}
					} finally { DebugExitDecision(56); }
					switch (alt56)
					{
					case 1:
						DebugEnterAlt(1);
						// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:236:8: collectionLiteralParts
						{
						DebugLocation(236, 8);
						PushFollow(Follow._collectionLiteralParts_in_collectionLiteralExpAndType1816);
						collectionLiteralParts128=collectionLiteralParts();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_collectionLiteralParts.Add(collectionLiteralParts128.Tree);

						}
						break;

					}
					} finally { DebugExitSubRule(56); }

					DebugLocation(236, 32);
					char_literal129=(CommonToken)Match(input,129,Follow._129_in_collectionLiteralExpAndType1819); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_129.Add(char_literal129);



					{
					// AST REWRITE
					// elements: collectionTypeIdentifier, type, collectionLiteralParts
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if (state.backtracking == 0) {
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (object)adaptor.Nil();
					// 237:4: -> ^( COLLECTIONLITERAL collectionTypeIdentifier type ( collectionLiteralParts )? )
					{
						DebugLocation(237, 7);
						// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:237:7: ^( COLLECTIONLITERAL collectionTypeIdentifier type ( collectionLiteralParts )? )
						{
						object root_1 = (object)adaptor.Nil();
						DebugLocation(237, 9);
						root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(COLLECTIONLITERAL, "COLLECTIONLITERAL"), root_1);

						DebugLocation(237, 27);
						adaptor.AddChild(root_1, stream_collectionTypeIdentifier.NextTree());
						DebugLocation(237, 52);
						adaptor.AddChild(root_1, stream_type.NextTree());
						DebugLocation(237, 57);
						// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:237:57: ( collectionLiteralParts )?
						if (stream_collectionLiteralParts.HasNext)
						{
							DebugLocation(237, 57);
							adaptor.AddChild(root_1, stream_collectionLiteralParts.NextTree());

						}
						stream_collectionLiteralParts.Reset();

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}
					}

					}


					}
					break;
				case 2:
					DebugEnterAlt(2);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:239:5: 
					{

					{
					// AST REWRITE
					// elements: collectionTypeIdentifier, type
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if (state.backtracking == 0) {
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (object)adaptor.Nil();
					// 239:5: -> ^( COLLTYPE collectionTypeIdentifier type )
					{
						DebugLocation(239, 7);
						// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:239:7: ^( COLLTYPE collectionTypeIdentifier type )
						{
						object root_1 = (object)adaptor.Nil();
						DebugLocation(239, 9);
						root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(COLLTYPE, "COLLTYPE"), root_1);

						DebugLocation(239, 18);
						adaptor.AddChild(root_1, stream_collectionTypeIdentifier.NextTree());
						DebugLocation(239, 43);
						adaptor.AddChild(root_1, stream_type.NextTree());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}
					}

					}
					break;

				}
				} finally { DebugExitSubRule(57); }


				}
				break;

			}
			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("collectionLiteralExpAndType", 35);
			LeaveRule("collectionLiteralExpAndType", 35);
			LeaveRule_collectionLiteralExpAndType();
		}
		DebugLocation(241, 1);
		} finally { DebugExitRule(GrammarFileName, "collectionLiteralExpAndType"); }
		return retval;

	}
	// $ANTLR end "collectionLiteralExpAndType"

	private sealed partial class enumLiteralExp_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public enumLiteralExp_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_enumLiteralExp();
	partial void LeaveRule_enumLiteralExp();

	// $ANTLR start "enumLiteralExp"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:243:1: enumLiteralExp : pathName '::' SimpleName ;
	[GrammarRule("enumLiteralExp")]
	private OCLSyntaxParser.enumLiteralExp_return enumLiteralExp()
	{
		EnterRule_enumLiteralExp();
		EnterRule("enumLiteralExp", 36);
		TraceIn("enumLiteralExp", 36);
		OCLSyntaxParser.enumLiteralExp_return retval = new OCLSyntaxParser.enumLiteralExp_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		CommonToken string_literal131 = default(CommonToken);
		CommonToken SimpleName132 = default(CommonToken);
		OCLSyntaxParser.pathName_return pathName130 = default(OCLSyntaxParser.pathName_return);

		object string_literal131_tree = default(object);
		object SimpleName132_tree = default(object);

		try { DebugEnterRule(GrammarFileName, "enumLiteralExp");
		DebugLocation(243, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:244:2: ( pathName '::' SimpleName )
			DebugEnterAlt(1);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:244:3: pathName '::' SimpleName
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(244, 3);
			PushFollow(Follow._pathName_in_enumLiteralExp1867);
			pathName130=pathName();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, pathName130.Tree);
			DebugLocation(244, 11);
			string_literal131=(CommonToken)Match(input,72,Follow._72_in_enumLiteralExp1868); if (state.failed) return retval;
			if (state.backtracking == 0) {
			string_literal131_tree = (object)adaptor.Create(string_literal131);
			adaptor.AddChild(root_0, string_literal131_tree);
			}
			DebugLocation(244, 16);
			SimpleName132=(CommonToken)Match(input,SimpleName,Follow._SimpleName_in_enumLiteralExp1870); if (state.failed) return retval;
			if (state.backtracking == 0) {
			SimpleName132_tree = (object)adaptor.Create(SimpleName132);
			adaptor.AddChild(root_0, SimpleName132_tree);
			}

			}

			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("enumLiteralExp", 36);
			LeaveRule("enumLiteralExp", 36);
			LeaveRule_enumLiteralExp();
		}
		DebugLocation(245, 1);
		} finally { DebugExitRule(GrammarFileName, "enumLiteralExp"); }
		return retval;

	}
	// $ANTLR end "enumLiteralExp"

	private sealed partial class collectionLiteralExp_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public collectionLiteralExp_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_collectionLiteralExp();
	partial void LeaveRule_collectionLiteralExp();

	// $ANTLR start "collectionLiteralExp"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:247:1: collectionLiteralExp : ( collectionTypeIdentifier '{' ( collectionLiteralParts )? '}' | collectionType '{' ( collectionLiteralParts )? '}' );
	[GrammarRule("collectionLiteralExp")]
	private OCLSyntaxParser.collectionLiteralExp_return collectionLiteralExp()
	{
		EnterRule_collectionLiteralExp();
		EnterRule("collectionLiteralExp", 37);
		TraceIn("collectionLiteralExp", 37);
		OCLSyntaxParser.collectionLiteralExp_return retval = new OCLSyntaxParser.collectionLiteralExp_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		CommonToken char_literal134 = default(CommonToken);
		CommonToken char_literal136 = default(CommonToken);
		CommonToken char_literal138 = default(CommonToken);
		CommonToken char_literal140 = default(CommonToken);
		OCLSyntaxParser.collectionTypeIdentifier_return collectionTypeIdentifier133 = default(OCLSyntaxParser.collectionTypeIdentifier_return);
		OCLSyntaxParser.collectionLiteralParts_return collectionLiteralParts135 = default(OCLSyntaxParser.collectionLiteralParts_return);
		OCLSyntaxParser.collectionType_return collectionType137 = default(OCLSyntaxParser.collectionType_return);
		OCLSyntaxParser.collectionLiteralParts_return collectionLiteralParts139 = default(OCLSyntaxParser.collectionLiteralParts_return);

		object char_literal134_tree = default(object);
		object char_literal136_tree = default(object);
		object char_literal138_tree = default(object);
		object char_literal140_tree = default(object);

		try { DebugEnterRule(GrammarFileName, "collectionLiteralExp");
		DebugLocation(247, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:248:2: ( collectionTypeIdentifier '{' ( collectionLiteralParts )? '}' | collectionType '{' ( collectionLiteralParts )? '}' )
			int alt61=2;
			try { DebugEnterDecision(61, false);
			int LA61_0 = input.LA(1);

			if ((LA61_0==82||LA61_0==84||LA61_0==90||(LA61_0>=92 && LA61_0<=93)))
			{
				int LA61_1 = input.LA(2);

				if ((LA61_1==127))
				{
					alt61 = 1;
				}
				else if ((LA61_1==63))
				{
					alt61 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 61, 1, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 61, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(61); }
			switch (alt61)
			{
			case 1:
				DebugEnterAlt(1);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:248:3: collectionTypeIdentifier '{' ( collectionLiteralParts )? '}'
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(248, 3);
				PushFollow(Follow._collectionTypeIdentifier_in_collectionLiteralExp1882);
				collectionTypeIdentifier133=collectionTypeIdentifier();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, collectionTypeIdentifier133.Tree);
				DebugLocation(248, 29);
				char_literal134=(CommonToken)Match(input,127,Follow._127_in_collectionLiteralExp1885); if (state.failed) return retval;
				if (state.backtracking == 0) {
				char_literal134_tree = (object)adaptor.Create(char_literal134);
				adaptor.AddChild(root_0, char_literal134_tree);
				}
				DebugLocation(248, 33);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:248:33: ( collectionLiteralParts )?
				int alt59=2;
				try { DebugEnterSubRule(59);
				try { DebugEnterDecision(59, false);
				int LA59_0 = input.LA(1);

				if (((LA59_0>=IntegerLiteralExp && LA59_0<=InvalidLiteralExp)||LA59_0==NullLiteralExp||(LA59_0>=RealLiteralExp && LA59_0<=SimpleName)||LA59_0==StringLiteralExp||LA59_0==UnlimitedNaturalLiteralExp||LA59_0==63||LA59_0==67||(LA59_0>=82 && LA59_0<=96)||(LA59_0>=108 && LA59_0<=109)||(LA59_0>=114 && LA59_0<=115)||(LA59_0>=117 && LA59_0<=118)||LA59_0==125))
				{
					alt59 = 1;
				}
				} finally { DebugExitDecision(59); }
				switch (alt59)
				{
				case 1:
					DebugEnterAlt(1);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:248:33: collectionLiteralParts
					{
					DebugLocation(248, 33);
					PushFollow(Follow._collectionLiteralParts_in_collectionLiteralExp1887);
					collectionLiteralParts135=collectionLiteralParts();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, collectionLiteralParts135.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(59); }

				DebugLocation(248, 57);
				char_literal136=(CommonToken)Match(input,129,Follow._129_in_collectionLiteralExp1890); if (state.failed) return retval;
				if (state.backtracking == 0) {
				char_literal136_tree = (object)adaptor.Create(char_literal136);
				adaptor.AddChild(root_0, char_literal136_tree);
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:249:3: collectionType '{' ( collectionLiteralParts )? '}'
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(249, 3);
				PushFollow(Follow._collectionType_in_collectionLiteralExp1894);
				collectionType137=collectionType();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, collectionType137.Tree);
				DebugLocation(249, 18);
				char_literal138=(CommonToken)Match(input,127,Follow._127_in_collectionLiteralExp1896); if (state.failed) return retval;
				if (state.backtracking == 0) {
				char_literal138_tree = (object)adaptor.Create(char_literal138);
				adaptor.AddChild(root_0, char_literal138_tree);
				}
				DebugLocation(249, 22);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:249:22: ( collectionLiteralParts )?
				int alt60=2;
				try { DebugEnterSubRule(60);
				try { DebugEnterDecision(60, false);
				int LA60_0 = input.LA(1);

				if (((LA60_0>=IntegerLiteralExp && LA60_0<=InvalidLiteralExp)||LA60_0==NullLiteralExp||(LA60_0>=RealLiteralExp && LA60_0<=SimpleName)||LA60_0==StringLiteralExp||LA60_0==UnlimitedNaturalLiteralExp||LA60_0==63||LA60_0==67||(LA60_0>=82 && LA60_0<=96)||(LA60_0>=108 && LA60_0<=109)||(LA60_0>=114 && LA60_0<=115)||(LA60_0>=117 && LA60_0<=118)||LA60_0==125))
				{
					alt60 = 1;
				}
				} finally { DebugExitDecision(60); }
				switch (alt60)
				{
				case 1:
					DebugEnterAlt(1);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:249:22: collectionLiteralParts
					{
					DebugLocation(249, 22);
					PushFollow(Follow._collectionLiteralParts_in_collectionLiteralExp1898);
					collectionLiteralParts139=collectionLiteralParts();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, collectionLiteralParts139.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(60); }

				DebugLocation(249, 46);
				char_literal140=(CommonToken)Match(input,129,Follow._129_in_collectionLiteralExp1901); if (state.failed) return retval;
				if (state.backtracking == 0) {
				char_literal140_tree = (object)adaptor.Create(char_literal140);
				adaptor.AddChild(root_0, char_literal140_tree);
				}

				}
				break;

			}
			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("collectionLiteralExp", 37);
			LeaveRule("collectionLiteralExp", 37);
			LeaveRule_collectionLiteralExp();
		}
		DebugLocation(250, 1);
		} finally { DebugExitRule(GrammarFileName, "collectionLiteralExp"); }
		return retval;

	}
	// $ANTLR end "collectionLiteralExp"

	private sealed partial class collectionTypeIdentifier_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public collectionTypeIdentifier_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_collectionTypeIdentifier();
	partial void LeaveRule_collectionTypeIdentifier();

	// $ANTLR start "collectionTypeIdentifier"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:257:1: collectionTypeIdentifier : ( 'Set' | 'Bag' | 'Sequence' | 'Collection' | 'OrderedSet' );
	[GrammarRule("collectionTypeIdentifier")]
	private OCLSyntaxParser.collectionTypeIdentifier_return collectionTypeIdentifier()
	{
		EnterRule_collectionTypeIdentifier();
		EnterRule("collectionTypeIdentifier", 38);
		TraceIn("collectionTypeIdentifier", 38);
		OCLSyntaxParser.collectionTypeIdentifier_return retval = new OCLSyntaxParser.collectionTypeIdentifier_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		CommonToken set141 = default(CommonToken);

		object set141_tree = default(object);

		try { DebugEnterRule(GrammarFileName, "collectionTypeIdentifier");
		DebugLocation(257, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:258:2: ( 'Set' | 'Bag' | 'Sequence' | 'Collection' | 'OrderedSet' )
			DebugEnterAlt(1);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(258, 2);
			set141=(CommonToken)input.LT(1);
			if (input.LA(1)==82||input.LA(1)==84||input.LA(1)==90||(input.LA(1)>=92 && input.LA(1)<=93))
			{
				input.Consume();
				if (state.backtracking == 0) adaptor.AddChild(root_0, (object)adaptor.Create(set141));
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("collectionTypeIdentifier", 38);
			LeaveRule("collectionTypeIdentifier", 38);
			LeaveRule_collectionTypeIdentifier();
		}
		DebugLocation(263, 1);
		} finally { DebugExitRule(GrammarFileName, "collectionTypeIdentifier"); }
		return retval;

	}
	// $ANTLR end "collectionTypeIdentifier"

	private sealed partial class collectionLiteralParts_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public collectionLiteralParts_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_collectionLiteralParts();
	partial void LeaveRule_collectionLiteralParts();

	// $ANTLR start "collectionLiteralParts"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:265:1: collectionLiteralParts : collectionLiteralPart ( ',' collectionLiteralPart )* ;
	[GrammarRule("collectionLiteralParts")]
	private OCLSyntaxParser.collectionLiteralParts_return collectionLiteralParts()
	{
		EnterRule_collectionLiteralParts();
		EnterRule("collectionLiteralParts", 39);
		TraceIn("collectionLiteralParts", 39);
		OCLSyntaxParser.collectionLiteralParts_return retval = new OCLSyntaxParser.collectionLiteralParts_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		CommonToken char_literal143 = default(CommonToken);
		OCLSyntaxParser.collectionLiteralPart_return collectionLiteralPart142 = default(OCLSyntaxParser.collectionLiteralPart_return);
		OCLSyntaxParser.collectionLiteralPart_return collectionLiteralPart144 = default(OCLSyntaxParser.collectionLiteralPart_return);

		object char_literal143_tree = default(object);

		try { DebugEnterRule(GrammarFileName, "collectionLiteralParts");
		DebugLocation(265, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:266:2: ( collectionLiteralPart ( ',' collectionLiteralPart )* )
			DebugEnterAlt(1);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:266:4: collectionLiteralPart ( ',' collectionLiteralPart )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(266, 4);
			PushFollow(Follow._collectionLiteralPart_in_collectionLiteralParts1948);
			collectionLiteralPart142=collectionLiteralPart();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, collectionLiteralPart142.Tree);
			DebugLocation(266, 26);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:266:26: ( ',' collectionLiteralPart )*
			try { DebugEnterSubRule(62);
			while (true)
			{
				int alt62=2;
				try { DebugEnterDecision(62, false);
				int LA62_0 = input.LA(1);

				if ((LA62_0==66))
				{
					alt62 = 1;
				}


				} finally { DebugExitDecision(62); }
				switch ( alt62 )
				{
				case 1:
					DebugEnterAlt(1);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:266:28: ',' collectionLiteralPart
					{
					DebugLocation(266, 31);
					char_literal143=(CommonToken)Match(input,66,Follow._66_in_collectionLiteralParts1952); if (state.failed) return retval;
					DebugLocation(266, 33);
					PushFollow(Follow._collectionLiteralPart_in_collectionLiteralParts1955);
					collectionLiteralPart144=collectionLiteralPart();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, collectionLiteralPart144.Tree);

					}
					break;

				default:
					goto loop62;
				}
			}

			loop62:
				;

			} finally { DebugExitSubRule(62); }


			}

			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("collectionLiteralParts", 39);
			LeaveRule("collectionLiteralParts", 39);
			LeaveRule_collectionLiteralParts();
		}
		DebugLocation(267, 1);
		} finally { DebugExitRule(GrammarFileName, "collectionLiteralParts"); }
		return retval;

	}
	// $ANTLR end "collectionLiteralParts"

	private sealed partial class collectionLiteralPart_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public collectionLiteralPart_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_collectionLiteralPart();
	partial void LeaveRule_collectionLiteralPart();

	// $ANTLR start "collectionLiteralPart"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:269:1: collectionLiteralPart : exp1= oclExpression ( ( DoubleDot exp2= oclExpression ) -> ^( COLLPARTRANGE $exp1 $exp2) | -> ^( COLLPART $exp1) ) ;
	[GrammarRule("collectionLiteralPart")]
	private OCLSyntaxParser.collectionLiteralPart_return collectionLiteralPart()
	{
		EnterRule_collectionLiteralPart();
		EnterRule("collectionLiteralPart", 40);
		TraceIn("collectionLiteralPart", 40);
		OCLSyntaxParser.collectionLiteralPart_return retval = new OCLSyntaxParser.collectionLiteralPart_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		CommonToken DoubleDot145 = default(CommonToken);
		OCLSyntaxParser.oclExpression_return exp1 = default(OCLSyntaxParser.oclExpression_return);
		OCLSyntaxParser.oclExpression_return exp2 = default(OCLSyntaxParser.oclExpression_return);

		object DoubleDot145_tree = default(object);
		RewriteRuleITokenStream stream_DoubleDot=new RewriteRuleITokenStream(adaptor,"token DoubleDot");
		RewriteRuleSubtreeStream stream_oclExpression=new RewriteRuleSubtreeStream(adaptor,"rule oclExpression");
		try { DebugEnterRule(GrammarFileName, "collectionLiteralPart");
		DebugLocation(269, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:270:2: (exp1= oclExpression ( ( DoubleDot exp2= oclExpression ) -> ^( COLLPARTRANGE $exp1 $exp2) | -> ^( COLLPART $exp1) ) )
			DebugEnterAlt(1);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:270:4: exp1= oclExpression ( ( DoubleDot exp2= oclExpression ) -> ^( COLLPARTRANGE $exp1 $exp2) | -> ^( COLLPART $exp1) )
			{
			DebugLocation(270, 8);
			PushFollow(Follow._oclExpression_in_collectionLiteralPart1972);
			exp1=oclExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_oclExpression.Add(exp1.Tree);
			DebugLocation(270, 23);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:270:23: ( ( DoubleDot exp2= oclExpression ) -> ^( COLLPARTRANGE $exp1 $exp2) | -> ^( COLLPART $exp1) )
			int alt63=2;
			try { DebugEnterSubRule(63);
			try { DebugEnterDecision(63, false);
			int LA63_0 = input.LA(1);

			if ((LA63_0==DoubleDot))
			{
				alt63 = 1;
			}
			else if ((LA63_0==66||LA63_0==129))
			{
				alt63 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 63, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(63); }
			switch (alt63)
			{
			case 1:
				DebugEnterAlt(1);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:270:24: ( DoubleDot exp2= oclExpression )
				{
				DebugLocation(270, 24);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:270:24: ( DoubleDot exp2= oclExpression )
				DebugEnterAlt(1);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:270:25: DoubleDot exp2= oclExpression
				{
				DebugLocation(270, 25);
				DoubleDot145=(CommonToken)Match(input,DoubleDot,Follow._DoubleDot_in_collectionLiteralPart1976); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_DoubleDot.Add(DoubleDot145);

				DebugLocation(270, 39);
				PushFollow(Follow._oclExpression_in_collectionLiteralPart1980);
				exp2=oclExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_oclExpression.Add(exp2.Tree);

				}



				{
				// AST REWRITE
				// elements: exp1, exp2
				// token labels: 
				// rule labels: exp1, exp2, retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_exp1=new RewriteRuleSubtreeStream(adaptor,"rule exp1",exp1!=null?exp1.Tree:null);
				RewriteRuleSubtreeStream stream_exp2=new RewriteRuleSubtreeStream(adaptor,"rule exp2",exp2!=null?exp2.Tree:null);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 270:54: -> ^( COLLPARTRANGE $exp1 $exp2)
				{
					DebugLocation(270, 56);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:270:56: ^( COLLPARTRANGE $exp1 $exp2)
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(270, 58);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(COLLPARTRANGE, "COLLPARTRANGE"), root_1);

					DebugLocation(270, 73);
					adaptor.AddChild(root_1, stream_exp1.NextTree());
					DebugLocation(270, 79);
					adaptor.AddChild(root_1, stream_exp2.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:270:85: 
				{

				{
				// AST REWRITE
				// elements: exp1
				// token labels: 
				// rule labels: exp1, retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_exp1=new RewriteRuleSubtreeStream(adaptor,"rule exp1",exp1!=null?exp1.Tree:null);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 270:85: -> ^( COLLPART $exp1)
				{
					DebugLocation(270, 87);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:270:87: ^( COLLPART $exp1)
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(270, 89);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(COLLPART, "COLLPART"), root_1);

					DebugLocation(270, 99);
					adaptor.AddChild(root_1, stream_exp1.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			} finally { DebugExitSubRule(63); }


			}

			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("collectionLiteralPart", 40);
			LeaveRule("collectionLiteralPart", 40);
			LeaveRule_collectionLiteralPart();
		}
		DebugLocation(271, 1);
		} finally { DebugExitRule(GrammarFileName, "collectionLiteralPart"); }
		return retval;

	}
	// $ANTLR end "collectionLiteralPart"

	private sealed partial class primitiveLiteralExp_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public primitiveLiteralExp_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_primitiveLiteralExp();
	partial void LeaveRule_primitiveLiteralExp();

	// $ANTLR start "primitiveLiteralExp"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:274:1: primitiveLiteralExp : ( IntegerLiteralExp | RealLiteralExp | StringLiteralExp | 'true' | 'false' | UnlimitedNaturalLiteralExp | NullLiteralExp | InvalidLiteralExp );
	[GrammarRule("primitiveLiteralExp")]
	private OCLSyntaxParser.primitiveLiteralExp_return primitiveLiteralExp()
	{
		EnterRule_primitiveLiteralExp();
		EnterRule("primitiveLiteralExp", 41);
		TraceIn("primitiveLiteralExp", 41);
		OCLSyntaxParser.primitiveLiteralExp_return retval = new OCLSyntaxParser.primitiveLiteralExp_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		CommonToken set146 = default(CommonToken);

		object set146_tree = default(object);

		try { DebugEnterRule(GrammarFileName, "primitiveLiteralExp");
		DebugLocation(274, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:275:2: ( IntegerLiteralExp | RealLiteralExp | StringLiteralExp | 'true' | 'false' | UnlimitedNaturalLiteralExp | NullLiteralExp | InvalidLiteralExp )
			DebugEnterAlt(1);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(275, 2);
			set146=(CommonToken)input.LT(1);
			if ((input.LA(1)>=IntegerLiteralExp && input.LA(1)<=InvalidLiteralExp)||input.LA(1)==NullLiteralExp||input.LA(1)==RealLiteralExp||input.LA(1)==StringLiteralExp||input.LA(1)==UnlimitedNaturalLiteralExp||input.LA(1)==108||input.LA(1)==125)
			{
				input.Consume();
				if (state.backtracking == 0) adaptor.AddChild(root_0, (object)adaptor.Create(set146));
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("primitiveLiteralExp", 41);
			LeaveRule("primitiveLiteralExp", 41);
			LeaveRule_primitiveLiteralExp();
		}
		DebugLocation(283, 1);
		} finally { DebugExitRule(GrammarFileName, "primitiveLiteralExp"); }
		return retval;

	}
	// $ANTLR end "primitiveLiteralExp"

	private sealed partial class tupleLiteralExp_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public tupleLiteralExp_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_tupleLiteralExp();
	partial void LeaveRule_tupleLiteralExp();

	// $ANTLR start "tupleLiteralExp"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:285:1: tupleLiteralExp : roottoken= 'Tuple' '{' variableDeclarationList[VariableDeclarationRequirement.TupleLiteral] '}' -> ^( TUPLELITERAL[$roottoken] variableDeclarationList ) ;
	[GrammarRule("tupleLiteralExp")]
	private OCLSyntaxParser.tupleLiteralExp_return tupleLiteralExp()
	{
		EnterRule_tupleLiteralExp();
		EnterRule("tupleLiteralExp", 42);
		TraceIn("tupleLiteralExp", 42);
		OCLSyntaxParser.tupleLiteralExp_return retval = new OCLSyntaxParser.tupleLiteralExp_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		CommonToken roottoken = default(CommonToken);
		CommonToken char_literal147 = default(CommonToken);
		CommonToken char_literal149 = default(CommonToken);
		OCLSyntaxParser.variableDeclarationList_return variableDeclarationList148 = default(OCLSyntaxParser.variableDeclarationList_return);

		object roottoken_tree = default(object);
		object char_literal147_tree = default(object);
		object char_literal149_tree = default(object);
		RewriteRuleITokenStream stream_95=new RewriteRuleITokenStream(adaptor,"token 95");
		RewriteRuleITokenStream stream_127=new RewriteRuleITokenStream(adaptor,"token 127");
		RewriteRuleITokenStream stream_129=new RewriteRuleITokenStream(adaptor,"token 129");
		RewriteRuleSubtreeStream stream_variableDeclarationList=new RewriteRuleSubtreeStream(adaptor,"rule variableDeclarationList");
		try { DebugEnterRule(GrammarFileName, "tupleLiteralExp");
		DebugLocation(285, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:286:2: (roottoken= 'Tuple' '{' variableDeclarationList[VariableDeclarationRequirement.TupleLiteral] '}' -> ^( TUPLELITERAL[$roottoken] variableDeclarationList ) )
			DebugEnterAlt(1);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:286:4: roottoken= 'Tuple' '{' variableDeclarationList[VariableDeclarationRequirement.TupleLiteral] '}'
			{
			DebugLocation(286, 13);
			roottoken=(CommonToken)Match(input,95,Follow._95_in_tupleLiteralExp2068); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_95.Add(roottoken);

			DebugLocation(286, 22);
			char_literal147=(CommonToken)Match(input,127,Follow._127_in_tupleLiteralExp2070); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_127.Add(char_literal147);

			DebugLocation(286, 26);
			PushFollow(Follow._variableDeclarationList_in_tupleLiteralExp2072);
			variableDeclarationList148=variableDeclarationList(VariableDeclarationRequirement.TupleLiteral);
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_variableDeclarationList.Add(variableDeclarationList148.Tree);
			DebugLocation(286, 95);
			char_literal149=(CommonToken)Match(input,129,Follow._129_in_tupleLiteralExp2075); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_129.Add(char_literal149);



			{
			// AST REWRITE
			// elements: variableDeclarationList
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 286:99: -> ^( TUPLELITERAL[$roottoken] variableDeclarationList )
			{
				DebugLocation(286, 102);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:286:102: ^( TUPLELITERAL[$roottoken] variableDeclarationList )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(286, 104);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(TUPLELITERAL, roottoken), root_1);

				DebugLocation(286, 130);
				adaptor.AddChild(root_1, stream_variableDeclarationList.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("tupleLiteralExp", 42);
			LeaveRule("tupleLiteralExp", 42);
			LeaveRule_tupleLiteralExp();
		}
		DebugLocation(287, 1);
		} finally { DebugExitRule(GrammarFileName, "tupleLiteralExp"); }
		return retval;

	}
	// $ANTLR end "tupleLiteralExp"

	private sealed partial class classLiteralExp_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public classLiteralExp_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_classLiteralExp();
	partial void LeaveRule_classLiteralExp();

	// $ANTLR start "classLiteralExp"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:289:1: classLiteralExp : roottoken= 'new' pathName '{' variableDeclarationList[VariableDeclarationRequirement.TupleLiteral] '}' -> ^( CLASSLITERAL[$roottoken] variableDeclarationList pathName ) ;
	[GrammarRule("classLiteralExp")]
	private OCLSyntaxParser.classLiteralExp_return classLiteralExp()
	{
		EnterRule_classLiteralExp();
		EnterRule("classLiteralExp", 43);
		TraceIn("classLiteralExp", 43);
		OCLSyntaxParser.classLiteralExp_return retval = new OCLSyntaxParser.classLiteralExp_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		CommonToken roottoken = default(CommonToken);
		CommonToken char_literal151 = default(CommonToken);
		CommonToken char_literal153 = default(CommonToken);
		OCLSyntaxParser.pathName_return pathName150 = default(OCLSyntaxParser.pathName_return);
		OCLSyntaxParser.variableDeclarationList_return variableDeclarationList152 = default(OCLSyntaxParser.variableDeclarationList_return);

		object roottoken_tree = default(object);
		object char_literal151_tree = default(object);
		object char_literal153_tree = default(object);
		RewriteRuleITokenStream stream_117=new RewriteRuleITokenStream(adaptor,"token 117");
		RewriteRuleITokenStream stream_127=new RewriteRuleITokenStream(adaptor,"token 127");
		RewriteRuleITokenStream stream_129=new RewriteRuleITokenStream(adaptor,"token 129");
		RewriteRuleSubtreeStream stream_pathName=new RewriteRuleSubtreeStream(adaptor,"rule pathName");
		RewriteRuleSubtreeStream stream_variableDeclarationList=new RewriteRuleSubtreeStream(adaptor,"rule variableDeclarationList");
		try { DebugEnterRule(GrammarFileName, "classLiteralExp");
		DebugLocation(289, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:290:2: (roottoken= 'new' pathName '{' variableDeclarationList[VariableDeclarationRequirement.TupleLiteral] '}' -> ^( CLASSLITERAL[$roottoken] variableDeclarationList pathName ) )
			DebugEnterAlt(1);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:290:4: roottoken= 'new' pathName '{' variableDeclarationList[VariableDeclarationRequirement.TupleLiteral] '}'
			{
			DebugLocation(290, 13);
			roottoken=(CommonToken)Match(input,117,Follow._117_in_classLiteralExp2099); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_117.Add(roottoken);

			DebugLocation(290, 20);
			PushFollow(Follow._pathName_in_classLiteralExp2101);
			pathName150=pathName();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_pathName.Add(pathName150.Tree);
			DebugLocation(290, 29);
			char_literal151=(CommonToken)Match(input,127,Follow._127_in_classLiteralExp2103); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_127.Add(char_literal151);

			DebugLocation(290, 33);
			PushFollow(Follow._variableDeclarationList_in_classLiteralExp2105);
			variableDeclarationList152=variableDeclarationList(VariableDeclarationRequirement.TupleLiteral);
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_variableDeclarationList.Add(variableDeclarationList152.Tree);
			DebugLocation(290, 102);
			char_literal153=(CommonToken)Match(input,129,Follow._129_in_classLiteralExp2108); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_129.Add(char_literal153);



			{
			// AST REWRITE
			// elements: variableDeclarationList, pathName
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 290:105: -> ^( CLASSLITERAL[$roottoken] variableDeclarationList pathName )
			{
				DebugLocation(290, 108);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:290:108: ^( CLASSLITERAL[$roottoken] variableDeclarationList pathName )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(290, 110);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(CLASSLITERAL, roottoken), root_1);

				DebugLocation(290, 136);
				adaptor.AddChild(root_1, stream_variableDeclarationList.NextTree());
				DebugLocation(290, 160);
				adaptor.AddChild(root_1, stream_pathName.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("classLiteralExp", 43);
			LeaveRule("classLiteralExp", 43);
			LeaveRule_classLiteralExp();
		}
		DebugLocation(291, 1);
		} finally { DebugExitRule(GrammarFileName, "classLiteralExp"); }
		return retval;

	}
	// $ANTLR end "classLiteralExp"

	private sealed partial class typeLiteralExp_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public typeLiteralExp_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_typeLiteralExp();
	partial void LeaveRule_typeLiteralExp();

	// $ANTLR start "typeLiteralExp"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:293:1: typeLiteralExp : type ;
	[GrammarRule("typeLiteralExp")]
	private OCLSyntaxParser.typeLiteralExp_return typeLiteralExp()
	{
		EnterRule_typeLiteralExp();
		EnterRule("typeLiteralExp", 44);
		TraceIn("typeLiteralExp", 44);
		OCLSyntaxParser.typeLiteralExp_return retval = new OCLSyntaxParser.typeLiteralExp_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		OCLSyntaxParser.type_return type154 = default(OCLSyntaxParser.type_return);


		try { DebugEnterRule(GrammarFileName, "typeLiteralExp");
		DebugLocation(293, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:294:2: ( type )
			DebugEnterAlt(1);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:294:3: type
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(294, 3);
			PushFollow(Follow._type_in_typeLiteralExp2130);
			type154=type();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, type154.Tree);

			}

			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("typeLiteralExp", 44);
			LeaveRule("typeLiteralExp", 44);
			LeaveRule_typeLiteralExp();
		}
		DebugLocation(295, 1);
		} finally { DebugExitRule(GrammarFileName, "typeLiteralExp"); }
		return retval;

	}
	// $ANTLR end "typeLiteralExp"

	private sealed partial class variableDeclaration_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public variableDeclaration_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_variableDeclaration();
	partial void LeaveRule_variableDeclaration();

	// $ANTLR start "variableDeclaration"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:297:1: variableDeclaration[VariableDeclarationRequirement requirement] : ({...}? SimpleName ':' type -> ^( DECL SimpleName ( type )? ) |{...}? SimpleName ( ':' type )? '=' oclExpression -> ^( DECL SimpleName ( type )? ( oclExpression )? ) );
	[GrammarRule("variableDeclaration")]
	private OCLSyntaxParser.variableDeclaration_return variableDeclaration(VariableDeclarationRequirement requirement)
	{
		EnterRule_variableDeclaration();
		EnterRule("variableDeclaration", 45);
		TraceIn("variableDeclaration", 45);
		OCLSyntaxParser.variableDeclaration_return retval = new OCLSyntaxParser.variableDeclaration_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		CommonToken SimpleName155 = default(CommonToken);
		CommonToken char_literal156 = default(CommonToken);
		CommonToken SimpleName158 = default(CommonToken);
		CommonToken char_literal159 = default(CommonToken);
		CommonToken char_literal161 = default(CommonToken);
		OCLSyntaxParser.type_return type157 = default(OCLSyntaxParser.type_return);
		OCLSyntaxParser.type_return type160 = default(OCLSyntaxParser.type_return);
		OCLSyntaxParser.oclExpression_return oclExpression162 = default(OCLSyntaxParser.oclExpression_return);

		object SimpleName155_tree = default(object);
		object char_literal156_tree = default(object);
		object SimpleName158_tree = default(object);
		object char_literal159_tree = default(object);
		object char_literal161_tree = default(object);
		RewriteRuleITokenStream stream_SimpleName=new RewriteRuleITokenStream(adaptor,"token SimpleName");
		RewriteRuleITokenStream stream_71=new RewriteRuleITokenStream(adaptor,"token 71");
		RewriteRuleITokenStream stream_77=new RewriteRuleITokenStream(adaptor,"token 77");
		RewriteRuleSubtreeStream stream_type=new RewriteRuleSubtreeStream(adaptor,"rule type");
		RewriteRuleSubtreeStream stream_oclExpression=new RewriteRuleSubtreeStream(adaptor,"rule oclExpression");
		try { DebugEnterRule(GrammarFileName, "variableDeclaration");
		DebugLocation(297, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:298:2: ({...}? SimpleName ':' type -> ^( DECL SimpleName ( type )? ) |{...}? SimpleName ( ':' type )? '=' oclExpression -> ^( DECL SimpleName ( type )? ( oclExpression )? ) )
			int alt65=2;
			try { DebugEnterDecision(65, false);
			int LA65_0 = input.LA(1);

			if ((LA65_0==SimpleName))
			{
				int LA65_1 = input.LA(2);

				if (((requirement==VariableDeclarationRequirement.TupleType ||
						requirement==VariableDeclarationRequirement.Iterator)))
				{
					alt65 = 1;
				}
				else if (((requirement==VariableDeclarationRequirement.TupleLiteral ||
						requirement==VariableDeclarationRequirement.Let)))
				{
					alt65 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 65, 1, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 65, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(65); }
			switch (alt65)
			{
			case 1:
				DebugEnterAlt(1);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:298:3: {...}? SimpleName ':' type
				{
				DebugLocation(298, 3);
				if (!((requirement==VariableDeclarationRequirement.TupleType ||
						requirement==VariableDeclarationRequirement.Iterator)))
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					throw new FailedPredicateException(input, "variableDeclaration", "$requirement==VariableDeclarationRequirement.TupleType ||\r\n\t\t$requirement==VariableDeclarationRequirement.Iterator");
				}
				DebugLocation(300, 3);
				SimpleName155=(CommonToken)Match(input,SimpleName,Follow._SimpleName_in_variableDeclaration2145); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_SimpleName.Add(SimpleName155);

				DebugLocation(300, 14);
				char_literal156=(CommonToken)Match(input,71,Follow._71_in_variableDeclaration2147); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_71.Add(char_literal156);

				DebugLocation(300, 18);
				PushFollow(Follow._type_in_variableDeclaration2149);
				type157=type();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_type.Add(type157.Tree);


				{
				// AST REWRITE
				// elements: SimpleName, type
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 300:24: -> ^( DECL SimpleName ( type )? )
				{
					DebugLocation(300, 27);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:300:27: ^( DECL SimpleName ( type )? )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(300, 29);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(DECL, "DECL"), root_1);

					DebugLocation(300, 34);
					adaptor.AddChild(root_1, stream_SimpleName.NextNode());
					DebugLocation(300, 45);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:300:45: ( type )?
					if (stream_type.HasNext)
					{
						DebugLocation(300, 45);
						adaptor.AddChild(root_1, stream_type.NextTree());

					}
					stream_type.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:301:3: {...}? SimpleName ( ':' type )? '=' oclExpression
				{
				DebugLocation(301, 3);
				if (!((requirement==VariableDeclarationRequirement.TupleLiteral ||
						requirement==VariableDeclarationRequirement.Let)))
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					throw new FailedPredicateException(input, "variableDeclaration", "$requirement==VariableDeclarationRequirement.TupleLiteral ||\r\n\t\t$requirement==VariableDeclarationRequirement.Let");
				}
				DebugLocation(303, 3);
				SimpleName158=(CommonToken)Match(input,SimpleName,Follow._SimpleName_in_variableDeclaration2172); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_SimpleName.Add(SimpleName158);

				DebugLocation(303, 14);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:303:14: ( ':' type )?
				int alt64=2;
				try { DebugEnterSubRule(64);
				try { DebugEnterDecision(64, false);
				int LA64_0 = input.LA(1);

				if ((LA64_0==71))
				{
					alt64 = 1;
				}
				} finally { DebugExitDecision(64); }
				switch (alt64)
				{
				case 1:
					DebugEnterAlt(1);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:303:15: ':' type
					{
					DebugLocation(303, 15);
					char_literal159=(CommonToken)Match(input,71,Follow._71_in_variableDeclaration2175); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_71.Add(char_literal159);

					DebugLocation(303, 19);
					PushFollow(Follow._type_in_variableDeclaration2177);
					type160=type();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_type.Add(type160.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(64); }

				DebugLocation(303, 27);
				char_literal161=(CommonToken)Match(input,77,Follow._77_in_variableDeclaration2182); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_77.Add(char_literal161);

				DebugLocation(303, 31);
				PushFollow(Follow._oclExpression_in_variableDeclaration2184);
				oclExpression162=oclExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_oclExpression.Add(oclExpression162.Tree);


				{
				// AST REWRITE
				// elements: SimpleName, type, oclExpression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 303:46: -> ^( DECL SimpleName ( type )? ( oclExpression )? )
				{
					DebugLocation(303, 49);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:303:49: ^( DECL SimpleName ( type )? ( oclExpression )? )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(303, 51);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(DECL, "DECL"), root_1);

					DebugLocation(303, 56);
					adaptor.AddChild(root_1, stream_SimpleName.NextNode());
					DebugLocation(303, 67);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:303:67: ( type )?
					if (stream_type.HasNext)
					{
						DebugLocation(303, 67);
						adaptor.AddChild(root_1, stream_type.NextTree());

					}
					stream_type.Reset();
					DebugLocation(303, 73);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:303:73: ( oclExpression )?
					if (stream_oclExpression.HasNext)
					{
						DebugLocation(303, 73);
						adaptor.AddChild(root_1, stream_oclExpression.NextTree());

					}
					stream_oclExpression.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("variableDeclaration", 45);
			LeaveRule("variableDeclaration", 45);
			LeaveRule_variableDeclaration();
		}
		DebugLocation(305, 1);
		} finally { DebugExitRule(GrammarFileName, "variableDeclaration"); }
		return retval;

	}
	// $ANTLR end "variableDeclaration"

	private sealed partial class type_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public type_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_type();
	partial void LeaveRule_type();

	// $ANTLR start "type"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:307:1: type : ( pathName | collectionType | tupleType | primitiveType | oclType );
	[GrammarRule("type")]
	private OCLSyntaxParser.type_return type()
	{
		EnterRule_type();
		EnterRule("type", 46);
		TraceIn("type", 46);
		OCLSyntaxParser.type_return retval = new OCLSyntaxParser.type_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		OCLSyntaxParser.pathName_return pathName163 = default(OCLSyntaxParser.pathName_return);
		OCLSyntaxParser.collectionType_return collectionType164 = default(OCLSyntaxParser.collectionType_return);
		OCLSyntaxParser.tupleType_return tupleType165 = default(OCLSyntaxParser.tupleType_return);
		OCLSyntaxParser.primitiveType_return primitiveType166 = default(OCLSyntaxParser.primitiveType_return);
		OCLSyntaxParser.oclType_return oclType167 = default(OCLSyntaxParser.oclType_return);


		try { DebugEnterRule(GrammarFileName, "type");
		DebugLocation(307, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:308:2: ( pathName | collectionType | tupleType | primitiveType | oclType )
			int alt66=5;
			try { DebugEnterDecision(66, false);
			switch (input.LA(1))
			{
			case SimpleName:
				{
				alt66 = 1;
				}
				break;
			case 82:
			case 84:
			case 90:
			case 92:
			case 93:
				{
				alt66 = 2;
				}
				break;
			case 95:
				{
				alt66 = 3;
				}
				break;
			case 83:
			case 85:
			case 91:
			case 94:
			case 96:
				{
				alt66 = 4;
				}
				break;
			case 86:
			case 87:
			case 88:
			case 89:
				{
				alt66 = 5;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 66, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(66); }
			switch (alt66)
			{
			case 1:
				DebugEnterAlt(1);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:308:4: pathName
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(308, 4);
				PushFollow(Follow._pathName_in_type2213);
				pathName163=pathName();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, pathName163.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:309:4: collectionType
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(309, 4);
				PushFollow(Follow._collectionType_in_type2221);
				collectionType164=collectionType();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, collectionType164.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:310:4: tupleType
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(310, 4);
				PushFollow(Follow._tupleType_in_type2227);
				tupleType165=tupleType();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, tupleType165.Tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:311:4: primitiveType
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(311, 4);
				PushFollow(Follow._primitiveType_in_type2234);
				primitiveType166=primitiveType();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, primitiveType166.Tree);

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:312:4: oclType
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(312, 4);
				PushFollow(Follow._oclType_in_type2241);
				oclType167=oclType();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, oclType167.Tree);

				}
				break;

			}
			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("type", 46);
			LeaveRule("type", 46);
			LeaveRule_type();
		}
		DebugLocation(313, 1);
		} finally { DebugExitRule(GrammarFileName, "type"); }
		return retval;

	}
	// $ANTLR end "type"

	private sealed partial class primitiveType_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public primitiveType_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_primitiveType();
	partial void LeaveRule_primitiveType();

	// $ANTLR start "primitiveType"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:315:1: primitiveType : ( 'Boolean' | 'Integer' | 'Real' | 'String' | 'UnlimitedNatural' );
	[GrammarRule("primitiveType")]
	private OCLSyntaxParser.primitiveType_return primitiveType()
	{
		EnterRule_primitiveType();
		EnterRule("primitiveType", 47);
		TraceIn("primitiveType", 47);
		OCLSyntaxParser.primitiveType_return retval = new OCLSyntaxParser.primitiveType_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		CommonToken set168 = default(CommonToken);

		object set168_tree = default(object);

		try { DebugEnterRule(GrammarFileName, "primitiveType");
		DebugLocation(315, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:316:2: ( 'Boolean' | 'Integer' | 'Real' | 'String' | 'UnlimitedNatural' )
			DebugEnterAlt(1);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(316, 2);
			set168=(CommonToken)input.LT(1);
			if (input.LA(1)==83||input.LA(1)==85||input.LA(1)==91||input.LA(1)==94||input.LA(1)==96)
			{
				input.Consume();
				if (state.backtracking == 0) adaptor.AddChild(root_0, (object)adaptor.Create(set168));
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("primitiveType", 47);
			LeaveRule("primitiveType", 47);
			LeaveRule_primitiveType();
		}
		DebugLocation(321, 1);
		} finally { DebugExitRule(GrammarFileName, "primitiveType"); }
		return retval;

	}
	// $ANTLR end "primitiveType"

	private sealed partial class oclType_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public oclType_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_oclType();
	partial void LeaveRule_oclType();

	// $ANTLR start "oclType"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:323:1: oclType : ( 'OclAny' | 'OclInvalid' | 'OclMessage' | 'OclVoid' );
	[GrammarRule("oclType")]
	private OCLSyntaxParser.oclType_return oclType()
	{
		EnterRule_oclType();
		EnterRule("oclType", 48);
		TraceIn("oclType", 48);
		OCLSyntaxParser.oclType_return retval = new OCLSyntaxParser.oclType_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		CommonToken set169 = default(CommonToken);

		object set169_tree = default(object);

		try { DebugEnterRule(GrammarFileName, "oclType");
		DebugLocation(323, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:324:2: ( 'OclAny' | 'OclInvalid' | 'OclMessage' | 'OclVoid' )
			DebugEnterAlt(1);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(324, 2);
			set169=(CommonToken)input.LT(1);
			if ((input.LA(1)>=86 && input.LA(1)<=89))
			{
				input.Consume();
				if (state.backtracking == 0) adaptor.AddChild(root_0, (object)adaptor.Create(set169));
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("oclType", 48);
			LeaveRule("oclType", 48);
			LeaveRule_oclType();
		}
		DebugLocation(328, 1);
		} finally { DebugExitRule(GrammarFileName, "oclType"); }
		return retval;

	}
	// $ANTLR end "oclType"

	private sealed partial class collectionType_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public collectionType_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_collectionType();
	partial void LeaveRule_collectionType();

	// $ANTLR start "collectionType"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:330:1: collectionType : collectionTypeIdentifier '(' type ')' -> ^( COLLTYPE collectionTypeIdentifier type ) ;
	[GrammarRule("collectionType")]
	private OCLSyntaxParser.collectionType_return collectionType()
	{
		EnterRule_collectionType();
		EnterRule("collectionType", 49);
		TraceIn("collectionType", 49);
		OCLSyntaxParser.collectionType_return retval = new OCLSyntaxParser.collectionType_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		CommonToken char_literal171 = default(CommonToken);
		CommonToken char_literal173 = default(CommonToken);
		OCLSyntaxParser.collectionTypeIdentifier_return collectionTypeIdentifier170 = default(OCLSyntaxParser.collectionTypeIdentifier_return);
		OCLSyntaxParser.type_return type172 = default(OCLSyntaxParser.type_return);

		object char_literal171_tree = default(object);
		object char_literal173_tree = default(object);
		RewriteRuleITokenStream stream_63=new RewriteRuleITokenStream(adaptor,"token 63");
		RewriteRuleITokenStream stream_64=new RewriteRuleITokenStream(adaptor,"token 64");
		RewriteRuleSubtreeStream stream_collectionTypeIdentifier=new RewriteRuleSubtreeStream(adaptor,"rule collectionTypeIdentifier");
		RewriteRuleSubtreeStream stream_type=new RewriteRuleSubtreeStream(adaptor,"rule type");
		try { DebugEnterRule(GrammarFileName, "collectionType");
		DebugLocation(330, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:331:2: ( collectionTypeIdentifier '(' type ')' -> ^( COLLTYPE collectionTypeIdentifier type ) )
			DebugEnterAlt(1);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:331:4: collectionTypeIdentifier '(' type ')'
			{
			DebugLocation(331, 4);
			PushFollow(Follow._collectionTypeIdentifier_in_collectionType2347);
			collectionTypeIdentifier170=collectionTypeIdentifier();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_collectionTypeIdentifier.Add(collectionTypeIdentifier170.Tree);
			DebugLocation(331, 29);
			char_literal171=(CommonToken)Match(input,63,Follow._63_in_collectionType2349); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_63.Add(char_literal171);

			DebugLocation(331, 33);
			PushFollow(Follow._type_in_collectionType2351);
			type172=type();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_type.Add(type172.Tree);
			DebugLocation(331, 39);
			char_literal173=(CommonToken)Match(input,64,Follow._64_in_collectionType2354); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_64.Add(char_literal173);



			{
			// AST REWRITE
			// elements: collectionTypeIdentifier, type
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 331:43: -> ^( COLLTYPE collectionTypeIdentifier type )
			{
				DebugLocation(331, 46);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:331:46: ^( COLLTYPE collectionTypeIdentifier type )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(331, 48);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(COLLTYPE, "COLLTYPE"), root_1);

				DebugLocation(331, 58);
				adaptor.AddChild(root_1, stream_collectionTypeIdentifier.NextTree());
				DebugLocation(331, 83);
				adaptor.AddChild(root_1, stream_type.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("collectionType", 49);
			LeaveRule("collectionType", 49);
			LeaveRule_collectionType();
		}
		DebugLocation(332, 1);
		} finally { DebugExitRule(GrammarFileName, "collectionType"); }
		return retval;

	}
	// $ANTLR end "collectionType"

	private sealed partial class tupleType_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public tupleType_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_tupleType();
	partial void LeaveRule_tupleType();

	// $ANTLR start "tupleType"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:334:1: tupleType : 'Tuple' '(' ( variableDeclarationList[VariableDeclarationRequirement.TupleType] )? ')' ;
	[GrammarRule("tupleType")]
	private OCLSyntaxParser.tupleType_return tupleType()
	{
		EnterRule_tupleType();
		EnterRule("tupleType", 50);
		TraceIn("tupleType", 50);
		OCLSyntaxParser.tupleType_return retval = new OCLSyntaxParser.tupleType_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		CommonToken string_literal174 = default(CommonToken);
		CommonToken char_literal175 = default(CommonToken);
		CommonToken char_literal177 = default(CommonToken);
		OCLSyntaxParser.variableDeclarationList_return variableDeclarationList176 = default(OCLSyntaxParser.variableDeclarationList_return);

		object string_literal174_tree = default(object);
		object char_literal175_tree = default(object);
		object char_literal177_tree = default(object);

		try { DebugEnterRule(GrammarFileName, "tupleType");
		DebugLocation(334, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:335:2: ( 'Tuple' '(' ( variableDeclarationList[VariableDeclarationRequirement.TupleType] )? ')' )
			DebugEnterAlt(1);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:335:4: 'Tuple' '(' ( variableDeclarationList[VariableDeclarationRequirement.TupleType] )? ')'
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(335, 11);
			string_literal174=(CommonToken)Match(input,95,Follow._95_in_tupleType2379); if (state.failed) return retval;
			if (state.backtracking == 0) {
			string_literal174_tree = (object)adaptor.Create(string_literal174);
			root_0 = (object)adaptor.BecomeRoot(string_literal174_tree, root_0);
			}
			DebugLocation(335, 16);
			char_literal175=(CommonToken)Match(input,63,Follow._63_in_tupleType2382); if (state.failed) return retval;
			DebugLocation(335, 18);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:335:18: ( variableDeclarationList[VariableDeclarationRequirement.TupleType] )?
			int alt67=2;
			try { DebugEnterSubRule(67);
			try { DebugEnterDecision(67, false);
			int LA67_0 = input.LA(1);

			if ((LA67_0==SimpleName))
			{
				alt67 = 1;
			}
			} finally { DebugExitDecision(67); }
			switch (alt67)
			{
			case 1:
				DebugEnterAlt(1);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:335:18: variableDeclarationList[VariableDeclarationRequirement.TupleType]
				{
				DebugLocation(335, 18);
				PushFollow(Follow._variableDeclarationList_in_tupleType2385);
				variableDeclarationList176=variableDeclarationList(VariableDeclarationRequirement.TupleType);
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, variableDeclarationList176.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(67); }

			DebugLocation(335, 88);
			char_literal177=(CommonToken)Match(input,64,Follow._64_in_tupleType2389); if (state.failed) return retval;

			}

			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("tupleType", 50);
			LeaveRule("tupleType", 50);
			LeaveRule_tupleType();
		}
		DebugLocation(336, 1);
		} finally { DebugExitRule(GrammarFileName, "tupleType"); }
		return retval;

	}
	// $ANTLR end "tupleType"

	private sealed partial class variableDeclarationList_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public variableDeclarationList_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_variableDeclarationList();
	partial void LeaveRule_variableDeclarationList();

	// $ANTLR start "variableDeclarationList"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:339:1: variableDeclarationList[VariableDeclarationRequirement requirement] : variableDeclaration[requirement] ( ',' variableDeclaration[requirement] )* ;
	[GrammarRule("variableDeclarationList")]
	private OCLSyntaxParser.variableDeclarationList_return variableDeclarationList(VariableDeclarationRequirement requirement)
	{
		EnterRule_variableDeclarationList();
		EnterRule("variableDeclarationList", 51);
		TraceIn("variableDeclarationList", 51);
		OCLSyntaxParser.variableDeclarationList_return retval = new OCLSyntaxParser.variableDeclarationList_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		CommonToken char_literal179 = default(CommonToken);
		OCLSyntaxParser.variableDeclaration_return variableDeclaration178 = default(OCLSyntaxParser.variableDeclaration_return);
		OCLSyntaxParser.variableDeclaration_return variableDeclaration180 = default(OCLSyntaxParser.variableDeclaration_return);

		object char_literal179_tree = default(object);

		try { DebugEnterRule(GrammarFileName, "variableDeclarationList");
		DebugLocation(339, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:340:2: ( variableDeclaration[requirement] ( ',' variableDeclaration[requirement] )* )
			DebugEnterAlt(1);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:340:4: variableDeclaration[requirement] ( ',' variableDeclaration[requirement] )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(340, 4);
			PushFollow(Follow._variableDeclaration_in_variableDeclarationList2405);
			variableDeclaration178=variableDeclaration(requirement);
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, variableDeclaration178.Tree);
			DebugLocation(340, 37);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:340:37: ( ',' variableDeclaration[requirement] )*
			try { DebugEnterSubRule(68);
			while (true)
			{
				int alt68=2;
				try { DebugEnterDecision(68, false);
				int LA68_0 = input.LA(1);

				if ((LA68_0==66))
				{
					alt68 = 1;
				}


				} finally { DebugExitDecision(68); }
				switch ( alt68 )
				{
				case 1:
					DebugEnterAlt(1);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:340:38: ',' variableDeclaration[requirement]
					{
					DebugLocation(340, 41);
					char_literal179=(CommonToken)Match(input,66,Follow._66_in_variableDeclarationList2409); if (state.failed) return retval;
					DebugLocation(340, 43);
					PushFollow(Follow._variableDeclaration_in_variableDeclarationList2412);
					variableDeclaration180=variableDeclaration(requirement);
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, variableDeclaration180.Tree);

					}
					break;

				default:
					goto loop68;
				}
			}

			loop68:
				;

			} finally { DebugExitSubRule(68); }


			}

			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("variableDeclarationList", 51);
			LeaveRule("variableDeclarationList", 51);
			LeaveRule_variableDeclarationList();
		}
		DebugLocation(341, 1);
		} finally { DebugExitRule(GrammarFileName, "variableDeclarationList"); }
		return retval;

	}
	// $ANTLR end "variableDeclarationList"

	private sealed partial class isMarkedPre_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public isMarkedPre_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_isMarkedPre();
	partial void LeaveRule_isMarkedPre();

	// $ANTLR start "isMarkedPre"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:342:1: isMarkedPre : '@' 'pre' ;
	[GrammarRule("isMarkedPre")]
	private OCLSyntaxParser.isMarkedPre_return isMarkedPre()
	{
		EnterRule_isMarkedPre();
		EnterRule("isMarkedPre", 52);
		TraceIn("isMarkedPre", 52);
		OCLSyntaxParser.isMarkedPre_return retval = new OCLSyntaxParser.isMarkedPre_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		CommonToken char_literal181 = default(CommonToken);
		CommonToken string_literal182 = default(CommonToken);

		object char_literal181_tree = default(object);
		object string_literal182_tree = default(object);

		try { DebugEnterRule(GrammarFileName, "isMarkedPre");
		DebugLocation(342, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:343:2: ( '@' 'pre' )
			DebugEnterAlt(1);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:343:4: '@' 'pre'
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(343, 7);
			char_literal181=(CommonToken)Match(input,81,Follow._81_in_isMarkedPre2428); if (state.failed) return retval;
			DebugLocation(343, 9);
			string_literal182=(CommonToken)Match(input,121,Follow._121_in_isMarkedPre2431); if (state.failed) return retval;
			if (state.backtracking == 0) {
			string_literal182_tree = (object)adaptor.Create(string_literal182);
			adaptor.AddChild(root_0, string_literal182_tree);
			}

			}

			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("isMarkedPre", 52);
			LeaveRule("isMarkedPre", 52);
			LeaveRule_isMarkedPre();
		}
		DebugLocation(344, 1);
		} finally { DebugExitRule(GrammarFileName, "isMarkedPre"); }
		return retval;

	}
	// $ANTLR end "isMarkedPre"

	private sealed partial class arguments_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public arguments_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_arguments();
	partial void LeaveRule_arguments();

	// $ANTLR start "arguments"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:346:1: arguments : exp1= oclExpression ( ',' exp2= oclExpression )* ;
	[GrammarRule("arguments")]
	private OCLSyntaxParser.arguments_return arguments()
	{
		EnterRule_arguments();
		EnterRule("arguments", 53);
		TraceIn("arguments", 53);
		OCLSyntaxParser.arguments_return retval = new OCLSyntaxParser.arguments_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		CommonToken char_literal183 = default(CommonToken);
		OCLSyntaxParser.oclExpression_return exp1 = default(OCLSyntaxParser.oclExpression_return);
		OCLSyntaxParser.oclExpression_return exp2 = default(OCLSyntaxParser.oclExpression_return);

		object char_literal183_tree = default(object);

		try { DebugEnterRule(GrammarFileName, "arguments");
		DebugLocation(346, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:347:2: (exp1= oclExpression ( ',' exp2= oclExpression )* )
			DebugEnterAlt(1);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:347:4: exp1= oclExpression ( ',' exp2= oclExpression )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(347, 9);
			PushFollow(Follow._oclExpression_in_arguments2447);
			exp1=oclExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, exp1.Tree);
			DebugLocation(347, 26);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:347:26: ( ',' exp2= oclExpression )*
			try { DebugEnterSubRule(69);
			while (true)
			{
				int alt69=2;
				try { DebugEnterDecision(69, false);
				int LA69_0 = input.LA(1);

				if ((LA69_0==66))
				{
					alt69 = 1;
				}


				} finally { DebugExitDecision(69); }
				switch ( alt69 )
				{
				case 1:
					DebugEnterAlt(1);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:347:28: ',' exp2= oclExpression
					{
					DebugLocation(347, 31);
					char_literal183=(CommonToken)Match(input,66,Follow._66_in_arguments2452); if (state.failed) return retval;
					DebugLocation(347, 37);
					PushFollow(Follow._oclExpression_in_arguments2457);
					exp2=oclExpression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, exp2.Tree);

					}
					break;

				default:
					goto loop69;
				}
			}

			loop69:
				;

			} finally { DebugExitSubRule(69); }


			}

			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("arguments", 53);
			LeaveRule("arguments", 53);
			LeaveRule_arguments();
		}
		DebugLocation(348, 1);
		} finally { DebugExitRule(GrammarFileName, "arguments"); }
		return retval;

	}
	// $ANTLR end "arguments"

	private sealed partial class letExp_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public letExp_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_letExp();
	partial void LeaveRule_letExp();

	// $ANTLR start "letExp"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:351:1: letExp : 'let' variableDeclaration[VariableDeclarationRequirement.Let] letExpSub -> ^( LET variableDeclaration letExpSub ) ;
	[GrammarRule("letExp")]
	private OCLSyntaxParser.letExp_return letExp()
	{
		EnterRule_letExp();
		EnterRule("letExp", 54);
		TraceIn("letExp", 54);
		OCLSyntaxParser.letExp_return retval = new OCLSyntaxParser.letExp_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		CommonToken string_literal184 = default(CommonToken);
		OCLSyntaxParser.variableDeclaration_return variableDeclaration185 = default(OCLSyntaxParser.variableDeclaration_return);
		OCLSyntaxParser.letExpSub_return letExpSub186 = default(OCLSyntaxParser.letExpSub_return);

		object string_literal184_tree = default(object);
		RewriteRuleITokenStream stream_115=new RewriteRuleITokenStream(adaptor,"token 115");
		RewriteRuleSubtreeStream stream_variableDeclaration=new RewriteRuleSubtreeStream(adaptor,"rule variableDeclaration");
		RewriteRuleSubtreeStream stream_letExpSub=new RewriteRuleSubtreeStream(adaptor,"rule letExpSub");
		try { DebugEnterRule(GrammarFileName, "letExp");
		DebugLocation(351, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:352:2: ( 'let' variableDeclaration[VariableDeclarationRequirement.Let] letExpSub -> ^( LET variableDeclaration letExpSub ) )
			DebugEnterAlt(1);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:352:4: 'let' variableDeclaration[VariableDeclarationRequirement.Let] letExpSub
			{
			DebugLocation(352, 4);
			string_literal184=(CommonToken)Match(input,115,Follow._115_in_letExp2473); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_115.Add(string_literal184);

			DebugLocation(352, 10);
			PushFollow(Follow._variableDeclaration_in_letExp2475);
			variableDeclaration185=variableDeclaration(VariableDeclarationRequirement.Let);
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_variableDeclaration.Add(variableDeclaration185.Tree);
			DebugLocation(352, 66);
			PushFollow(Follow._letExpSub_in_letExp2478);
			letExpSub186=letExpSub();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_letExpSub.Add(letExpSub186.Tree);


			{
			// AST REWRITE
			// elements: variableDeclaration, letExpSub
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 352:76: -> ^( LET variableDeclaration letExpSub )
			{
				DebugLocation(352, 79);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:352:79: ^( LET variableDeclaration letExpSub )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(352, 81);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(LET, "LET"), root_1);

				DebugLocation(352, 85);
				adaptor.AddChild(root_1, stream_variableDeclaration.NextTree());
				DebugLocation(352, 105);
				adaptor.AddChild(root_1, stream_letExpSub.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("letExp", 54);
			LeaveRule("letExp", 54);
			LeaveRule_letExp();
		}
		DebugLocation(353, 1);
		} finally { DebugExitRule(GrammarFileName, "letExp"); }
		return retval;

	}
	// $ANTLR end "letExp"

	private sealed partial class letExpSub_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public letExpSub_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_letExpSub();
	partial void LeaveRule_letExpSub();

	// $ANTLR start "letExpSub"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:355:1: letExpSub : ( ',' variableDeclaration[VariableDeclarationRequirement.Let] letExpSub -> ^( LET variableDeclaration letExpSub ) | 'in' ( options {greedy=false; } : oclExpression ) -> oclExpression );
	[GrammarRule("letExpSub")]
	private OCLSyntaxParser.letExpSub_return letExpSub()
	{
		EnterRule_letExpSub();
		EnterRule("letExpSub", 55);
		TraceIn("letExpSub", 55);
		OCLSyntaxParser.letExpSub_return retval = new OCLSyntaxParser.letExpSub_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		CommonToken char_literal187 = default(CommonToken);
		CommonToken string_literal190 = default(CommonToken);
		OCLSyntaxParser.variableDeclaration_return variableDeclaration188 = default(OCLSyntaxParser.variableDeclaration_return);
		OCLSyntaxParser.letExpSub_return letExpSub189 = default(OCLSyntaxParser.letExpSub_return);
		OCLSyntaxParser.oclExpression_return oclExpression191 = default(OCLSyntaxParser.oclExpression_return);

		object char_literal187_tree = default(object);
		object string_literal190_tree = default(object);
		RewriteRuleITokenStream stream_66=new RewriteRuleITokenStream(adaptor,"token 66");
		RewriteRuleITokenStream stream_111=new RewriteRuleITokenStream(adaptor,"token 111");
		RewriteRuleSubtreeStream stream_variableDeclaration=new RewriteRuleSubtreeStream(adaptor,"rule variableDeclaration");
		RewriteRuleSubtreeStream stream_letExpSub=new RewriteRuleSubtreeStream(adaptor,"rule letExpSub");
		RewriteRuleSubtreeStream stream_oclExpression=new RewriteRuleSubtreeStream(adaptor,"rule oclExpression");
		try { DebugEnterRule(GrammarFileName, "letExpSub");
		DebugLocation(355, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:356:2: ( ',' variableDeclaration[VariableDeclarationRequirement.Let] letExpSub -> ^( LET variableDeclaration letExpSub ) | 'in' ( options {greedy=false; } : oclExpression ) -> oclExpression )
			int alt70=2;
			try { DebugEnterDecision(70, false);
			int LA70_0 = input.LA(1);

			if ((LA70_0==66))
			{
				alt70 = 1;
			}
			else if ((LA70_0==111))
			{
				alt70 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 70, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(70); }
			switch (alt70)
			{
			case 1:
				DebugEnterAlt(1);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:356:4: ',' variableDeclaration[VariableDeclarationRequirement.Let] letExpSub
				{
				DebugLocation(356, 4);
				char_literal187=(CommonToken)Match(input,66,Follow._66_in_letExpSub2500); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_66.Add(char_literal187);

				DebugLocation(356, 8);
				PushFollow(Follow._variableDeclaration_in_letExpSub2502);
				variableDeclaration188=variableDeclaration(VariableDeclarationRequirement.Let);
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_variableDeclaration.Add(variableDeclaration188.Tree);
				DebugLocation(356, 64);
				PushFollow(Follow._letExpSub_in_letExpSub2505);
				letExpSub189=letExpSub();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_letExpSub.Add(letExpSub189.Tree);


				{
				// AST REWRITE
				// elements: variableDeclaration, letExpSub
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 356:74: -> ^( LET variableDeclaration letExpSub )
				{
					DebugLocation(356, 77);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:356:77: ^( LET variableDeclaration letExpSub )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(356, 79);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(LET, "LET"), root_1);

					DebugLocation(356, 83);
					adaptor.AddChild(root_1, stream_variableDeclaration.NextTree());
					DebugLocation(356, 103);
					adaptor.AddChild(root_1, stream_letExpSub.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:357:4: 'in' ( options {greedy=false; } : oclExpression )
				{
				DebugLocation(357, 4);
				string_literal190=(CommonToken)Match(input,111,Follow._111_in_letExpSub2520); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_111.Add(string_literal190);

				DebugLocation(357, 9);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:357:9: ( options {greedy=false; } : oclExpression )
				DebugEnterAlt(1);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:357:35: oclExpression
				{
				DebugLocation(357, 35);
				PushFollow(Follow._oclExpression_in_letExpSub2531);
				oclExpression191=oclExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_oclExpression.Add(oclExpression191.Tree);

				}



				{
				// AST REWRITE
				// elements: oclExpression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 357:50: -> oclExpression
				{
					DebugLocation(357, 53);
					adaptor.AddChild(root_0, stream_oclExpression.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("letExpSub", 55);
			LeaveRule("letExpSub", 55);
			LeaveRule_letExpSub();
		}
		DebugLocation(358, 1);
		} finally { DebugExitRule(GrammarFileName, "letExpSub"); }
		return retval;

	}
	// $ANTLR end "letExpSub"

	private sealed partial class oclMessageExp_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public oclMessageExp_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_oclMessageExp();
	partial void LeaveRule_oclMessageExp();

	// $ANTLR start "oclMessageExp"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:360:1: oclMessageExp : ( '^^' SimpleName '(' ( oclMessageArguments )? ')' | '^' SimpleName '(' ( oclMessageArguments )? ')' );
	[GrammarRule("oclMessageExp")]
	private OCLSyntaxParser.oclMessageExp_return oclMessageExp()
	{
		EnterRule_oclMessageExp();
		EnterRule("oclMessageExp", 56);
		TraceIn("oclMessageExp", 56);
		OCLSyntaxParser.oclMessageExp_return retval = new OCLSyntaxParser.oclMessageExp_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		CommonToken string_literal192 = default(CommonToken);
		CommonToken SimpleName193 = default(CommonToken);
		CommonToken char_literal194 = default(CommonToken);
		CommonToken char_literal196 = default(CommonToken);
		CommonToken char_literal197 = default(CommonToken);
		CommonToken SimpleName198 = default(CommonToken);
		CommonToken char_literal199 = default(CommonToken);
		CommonToken char_literal201 = default(CommonToken);
		OCLSyntaxParser.oclMessageArguments_return oclMessageArguments195 = default(OCLSyntaxParser.oclMessageArguments_return);
		OCLSyntaxParser.oclMessageArguments_return oclMessageArguments200 = default(OCLSyntaxParser.oclMessageArguments_return);

		object string_literal192_tree = default(object);
		object SimpleName193_tree = default(object);
		object char_literal194_tree = default(object);
		object char_literal196_tree = default(object);
		object char_literal197_tree = default(object);
		object SimpleName198_tree = default(object);
		object char_literal199_tree = default(object);
		object char_literal201_tree = default(object);

		try { DebugEnterRule(GrammarFileName, "oclMessageExp");
		DebugLocation(360, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:361:2: ( '^^' SimpleName '(' ( oclMessageArguments )? ')' | '^' SimpleName '(' ( oclMessageArguments )? ')' )
			int alt73=2;
			try { DebugEnterDecision(73, false);
			int LA73_0 = input.LA(1);

			if ((LA73_0==100))
			{
				alt73 = 1;
			}
			else if ((LA73_0==99))
			{
				alt73 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 73, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(73); }
			switch (alt73)
			{
			case 1:
				DebugEnterAlt(1);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:361:4: '^^' SimpleName '(' ( oclMessageArguments )? ')'
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(361, 4);
				string_literal192=(CommonToken)Match(input,100,Follow._100_in_oclMessageExp2547); if (state.failed) return retval;
				if (state.backtracking == 0) {
				string_literal192_tree = (object)adaptor.Create(string_literal192);
				adaptor.AddChild(root_0, string_literal192_tree);
				}
				DebugLocation(361, 9);
				SimpleName193=(CommonToken)Match(input,SimpleName,Follow._SimpleName_in_oclMessageExp2549); if (state.failed) return retval;
				if (state.backtracking == 0) {
				SimpleName193_tree = (object)adaptor.Create(SimpleName193);
				adaptor.AddChild(root_0, SimpleName193_tree);
				}
				DebugLocation(361, 20);
				char_literal194=(CommonToken)Match(input,63,Follow._63_in_oclMessageExp2551); if (state.failed) return retval;
				if (state.backtracking == 0) {
				char_literal194_tree = (object)adaptor.Create(char_literal194);
				adaptor.AddChild(root_0, char_literal194_tree);
				}
				DebugLocation(361, 24);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:361:24: ( oclMessageArguments )?
				int alt71=2;
				try { DebugEnterSubRule(71);
				try { DebugEnterDecision(71, false);
				int LA71_0 = input.LA(1);

				if (((LA71_0>=IntegerLiteralExp && LA71_0<=InvalidLiteralExp)||LA71_0==NullLiteralExp||(LA71_0>=RealLiteralExp && LA71_0<=SimpleName)||LA71_0==StringLiteralExp||LA71_0==UnlimitedNaturalLiteralExp||LA71_0==63||LA71_0==67||LA71_0==80||(LA71_0>=82 && LA71_0<=96)||(LA71_0>=108 && LA71_0<=109)||(LA71_0>=114 && LA71_0<=115)||(LA71_0>=117 && LA71_0<=118)||LA71_0==125))
				{
					alt71 = 1;
				}
				} finally { DebugExitDecision(71); }
				switch (alt71)
				{
				case 1:
					DebugEnterAlt(1);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:361:24: oclMessageArguments
					{
					DebugLocation(361, 24);
					PushFollow(Follow._oclMessageArguments_in_oclMessageExp2553);
					oclMessageArguments195=oclMessageArguments();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, oclMessageArguments195.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(71); }

				DebugLocation(361, 45);
				char_literal196=(CommonToken)Match(input,64,Follow._64_in_oclMessageExp2556); if (state.failed) return retval;
				if (state.backtracking == 0) {
				char_literal196_tree = (object)adaptor.Create(char_literal196);
				adaptor.AddChild(root_0, char_literal196_tree);
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:362:4: '^' SimpleName '(' ( oclMessageArguments )? ')'
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(362, 4);
				char_literal197=(CommonToken)Match(input,99,Follow._99_in_oclMessageExp2561); if (state.failed) return retval;
				if (state.backtracking == 0) {
				char_literal197_tree = (object)adaptor.Create(char_literal197);
				adaptor.AddChild(root_0, char_literal197_tree);
				}
				DebugLocation(362, 8);
				SimpleName198=(CommonToken)Match(input,SimpleName,Follow._SimpleName_in_oclMessageExp2563); if (state.failed) return retval;
				if (state.backtracking == 0) {
				SimpleName198_tree = (object)adaptor.Create(SimpleName198);
				adaptor.AddChild(root_0, SimpleName198_tree);
				}
				DebugLocation(362, 19);
				char_literal199=(CommonToken)Match(input,63,Follow._63_in_oclMessageExp2565); if (state.failed) return retval;
				if (state.backtracking == 0) {
				char_literal199_tree = (object)adaptor.Create(char_literal199);
				adaptor.AddChild(root_0, char_literal199_tree);
				}
				DebugLocation(362, 23);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:362:23: ( oclMessageArguments )?
				int alt72=2;
				try { DebugEnterSubRule(72);
				try { DebugEnterDecision(72, false);
				int LA72_0 = input.LA(1);

				if (((LA72_0>=IntegerLiteralExp && LA72_0<=InvalidLiteralExp)||LA72_0==NullLiteralExp||(LA72_0>=RealLiteralExp && LA72_0<=SimpleName)||LA72_0==StringLiteralExp||LA72_0==UnlimitedNaturalLiteralExp||LA72_0==63||LA72_0==67||LA72_0==80||(LA72_0>=82 && LA72_0<=96)||(LA72_0>=108 && LA72_0<=109)||(LA72_0>=114 && LA72_0<=115)||(LA72_0>=117 && LA72_0<=118)||LA72_0==125))
				{
					alt72 = 1;
				}
				} finally { DebugExitDecision(72); }
				switch (alt72)
				{
				case 1:
					DebugEnterAlt(1);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:362:23: oclMessageArguments
					{
					DebugLocation(362, 23);
					PushFollow(Follow._oclMessageArguments_in_oclMessageExp2567);
					oclMessageArguments200=oclMessageArguments();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, oclMessageArguments200.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(72); }

				DebugLocation(362, 44);
				char_literal201=(CommonToken)Match(input,64,Follow._64_in_oclMessageExp2570); if (state.failed) return retval;
				if (state.backtracking == 0) {
				char_literal201_tree = (object)adaptor.Create(char_literal201);
				adaptor.AddChild(root_0, char_literal201_tree);
				}

				}
				break;

			}
			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("oclMessageExp", 56);
			LeaveRule("oclMessageExp", 56);
			LeaveRule_oclMessageExp();
		}
		DebugLocation(363, 1);
		} finally { DebugExitRule(GrammarFileName, "oclMessageExp"); }
		return retval;

	}
	// $ANTLR end "oclMessageExp"

	private sealed partial class oclMessageArguments_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public oclMessageArguments_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_oclMessageArguments();
	partial void LeaveRule_oclMessageArguments();

	// $ANTLR start "oclMessageArguments"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:364:1: oclMessageArguments : oclMessageArg ( ',' oclMessageArguments )? ;
	[GrammarRule("oclMessageArguments")]
	private OCLSyntaxParser.oclMessageArguments_return oclMessageArguments()
	{
		EnterRule_oclMessageArguments();
		EnterRule("oclMessageArguments", 57);
		TraceIn("oclMessageArguments", 57);
		OCLSyntaxParser.oclMessageArguments_return retval = new OCLSyntaxParser.oclMessageArguments_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		CommonToken char_literal203 = default(CommonToken);
		OCLSyntaxParser.oclMessageArg_return oclMessageArg202 = default(OCLSyntaxParser.oclMessageArg_return);
		OCLSyntaxParser.oclMessageArguments_return oclMessageArguments204 = default(OCLSyntaxParser.oclMessageArguments_return);

		object char_literal203_tree = default(object);

		try { DebugEnterRule(GrammarFileName, "oclMessageArguments");
		DebugLocation(364, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:365:2: ( oclMessageArg ( ',' oclMessageArguments )? )
			DebugEnterAlt(1);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:365:4: oclMessageArg ( ',' oclMessageArguments )?
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(365, 4);
			PushFollow(Follow._oclMessageArg_in_oclMessageArguments2580);
			oclMessageArg202=oclMessageArg();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, oclMessageArg202.Tree);
			DebugLocation(365, 18);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:365:18: ( ',' oclMessageArguments )?
			int alt74=2;
			try { DebugEnterSubRule(74);
			try { DebugEnterDecision(74, false);
			int LA74_0 = input.LA(1);

			if ((LA74_0==66))
			{
				alt74 = 1;
			}
			} finally { DebugExitDecision(74); }
			switch (alt74)
			{
			case 1:
				DebugEnterAlt(1);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:365:20: ',' oclMessageArguments
				{
				DebugLocation(365, 20);
				char_literal203=(CommonToken)Match(input,66,Follow._66_in_oclMessageArguments2584); if (state.failed) return retval;
				if (state.backtracking == 0) {
				char_literal203_tree = (object)adaptor.Create(char_literal203);
				adaptor.AddChild(root_0, char_literal203_tree);
				}
				DebugLocation(365, 24);
				PushFollow(Follow._oclMessageArguments_in_oclMessageArguments2586);
				oclMessageArguments204=oclMessageArguments();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, oclMessageArguments204.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(74); }


			}

			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("oclMessageArguments", 57);
			LeaveRule("oclMessageArguments", 57);
			LeaveRule_oclMessageArguments();
		}
		DebugLocation(366, 1);
		} finally { DebugExitRule(GrammarFileName, "oclMessageArguments"); }
		return retval;

	}
	// $ANTLR end "oclMessageArguments"

	private sealed partial class oclMessageArg_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public oclMessageArg_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_oclMessageArg();
	partial void LeaveRule_oclMessageArg();

	// $ANTLR start "oclMessageArg"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:368:1: oclMessageArg : ( '?' ( ':' type )? | oclExpression );
	[GrammarRule("oclMessageArg")]
	private OCLSyntaxParser.oclMessageArg_return oclMessageArg()
	{
		EnterRule_oclMessageArg();
		EnterRule("oclMessageArg", 58);
		TraceIn("oclMessageArg", 58);
		OCLSyntaxParser.oclMessageArg_return retval = new OCLSyntaxParser.oclMessageArg_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		CommonToken char_literal205 = default(CommonToken);
		CommonToken char_literal206 = default(CommonToken);
		OCLSyntaxParser.type_return type207 = default(OCLSyntaxParser.type_return);
		OCLSyntaxParser.oclExpression_return oclExpression208 = default(OCLSyntaxParser.oclExpression_return);

		object char_literal205_tree = default(object);
		object char_literal206_tree = default(object);

		try { DebugEnterRule(GrammarFileName, "oclMessageArg");
		DebugLocation(368, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:369:2: ( '?' ( ':' type )? | oclExpression )
			int alt76=2;
			try { DebugEnterDecision(76, false);
			int LA76_0 = input.LA(1);

			if ((LA76_0==80))
			{
				alt76 = 1;
			}
			else if (((LA76_0>=IntegerLiteralExp && LA76_0<=InvalidLiteralExp)||LA76_0==NullLiteralExp||(LA76_0>=RealLiteralExp && LA76_0<=SimpleName)||LA76_0==StringLiteralExp||LA76_0==UnlimitedNaturalLiteralExp||LA76_0==63||LA76_0==67||(LA76_0>=82 && LA76_0<=96)||(LA76_0>=108 && LA76_0<=109)||(LA76_0>=114 && LA76_0<=115)||(LA76_0>=117 && LA76_0<=118)||LA76_0==125))
			{
				alt76 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 76, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(76); }
			switch (alt76)
			{
			case 1:
				DebugEnterAlt(1);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:369:4: '?' ( ':' type )?
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(369, 4);
				char_literal205=(CommonToken)Match(input,80,Follow._80_in_oclMessageArg2601); if (state.failed) return retval;
				if (state.backtracking == 0) {
				char_literal205_tree = (object)adaptor.Create(char_literal205);
				adaptor.AddChild(root_0, char_literal205_tree);
				}
				DebugLocation(369, 8);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:369:8: ( ':' type )?
				int alt75=2;
				try { DebugEnterSubRule(75);
				try { DebugEnterDecision(75, false);
				int LA75_0 = input.LA(1);

				if ((LA75_0==71))
				{
					alt75 = 1;
				}
				} finally { DebugExitDecision(75); }
				switch (alt75)
				{
				case 1:
					DebugEnterAlt(1);
					// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:369:9: ':' type
					{
					DebugLocation(369, 9);
					char_literal206=(CommonToken)Match(input,71,Follow._71_in_oclMessageArg2604); if (state.failed) return retval;
					if (state.backtracking == 0) {
					char_literal206_tree = (object)adaptor.Create(char_literal206);
					adaptor.AddChild(root_0, char_literal206_tree);
					}
					DebugLocation(369, 13);
					PushFollow(Follow._type_in_oclMessageArg2606);
					type207=type();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, type207.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(75); }


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:370:4: oclExpression
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(370, 4);
				PushFollow(Follow._oclExpression_in_oclMessageArg2613);
				oclExpression208=oclExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, oclExpression208.Tree);

				}
				break;

			}
			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("oclMessageArg", 58);
			LeaveRule("oclMessageArg", 58);
			LeaveRule_oclMessageArg();
		}
		DebugLocation(371, 1);
		} finally { DebugExitRule(GrammarFileName, "oclMessageArg"); }
		return retval;

	}
	// $ANTLR end "oclMessageArg"

	private sealed partial class ifExp_return : ParserRuleReturnScope<CommonToken>, IAstRuleReturnScope<object>, IAstRuleReturnScope
	{
		private object _tree;
		public object Tree { get { return _tree; } set { _tree = value; } }
		object IAstRuleReturnScope.Tree { get { return Tree; } }
		public ifExp_return(OCLSyntaxParser grammar) {OnCreated(grammar);}
		partial void OnCreated(OCLSyntaxParser grammar);
	}

	partial void EnterRule_ifExp();
	partial void LeaveRule_ifExp();

	// $ANTLR start "ifExp"
	// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:373:1: ifExp : i= 'if' oclExpression 'then' oclExpression 'else' oclExpression 'endif' -> ^( IF[$i] ( oclExpression )+ ) ;
	[GrammarRule("ifExp")]
	private OCLSyntaxParser.ifExp_return ifExp()
	{
		EnterRule_ifExp();
		EnterRule("ifExp", 59);
		TraceIn("ifExp", 59);
		OCLSyntaxParser.ifExp_return retval = new OCLSyntaxParser.ifExp_return(this);
		retval.Start = (CommonToken)input.LT(1);

		object root_0 = default(object);

		CommonToken i = default(CommonToken);
		CommonToken string_literal210 = default(CommonToken);
		CommonToken string_literal212 = default(CommonToken);
		CommonToken string_literal214 = default(CommonToken);
		OCLSyntaxParser.oclExpression_return oclExpression209 = default(OCLSyntaxParser.oclExpression_return);
		OCLSyntaxParser.oclExpression_return oclExpression211 = default(OCLSyntaxParser.oclExpression_return);
		OCLSyntaxParser.oclExpression_return oclExpression213 = default(OCLSyntaxParser.oclExpression_return);

		object i_tree = default(object);
		object string_literal210_tree = default(object);
		object string_literal212_tree = default(object);
		object string_literal214_tree = default(object);
		RewriteRuleITokenStream stream_109=new RewriteRuleITokenStream(adaptor,"token 109");
		RewriteRuleITokenStream stream_124=new RewriteRuleITokenStream(adaptor,"token 124");
		RewriteRuleITokenStream stream_106=new RewriteRuleITokenStream(adaptor,"token 106");
		RewriteRuleITokenStream stream_107=new RewriteRuleITokenStream(adaptor,"token 107");
		RewriteRuleSubtreeStream stream_oclExpression=new RewriteRuleSubtreeStream(adaptor,"rule oclExpression");
		try { DebugEnterRule(GrammarFileName, "ifExp");
		DebugLocation(373, 1);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:374:2: (i= 'if' oclExpression 'then' oclExpression 'else' oclExpression 'endif' -> ^( IF[$i] ( oclExpression )+ ) )
			DebugEnterAlt(1);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:374:4: i= 'if' oclExpression 'then' oclExpression 'else' oclExpression 'endif'
			{
			DebugLocation(374, 5);
			i=(CommonToken)Match(input,109,Follow._109_in_ifExp2627); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_109.Add(i);

			DebugLocation(374, 11);
			PushFollow(Follow._oclExpression_in_ifExp2629);
			oclExpression209=oclExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_oclExpression.Add(oclExpression209.Tree);
			DebugLocation(374, 25);
			string_literal210=(CommonToken)Match(input,124,Follow._124_in_ifExp2631); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_124.Add(string_literal210);

			DebugLocation(374, 32);
			PushFollow(Follow._oclExpression_in_ifExp2633);
			oclExpression211=oclExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_oclExpression.Add(oclExpression211.Tree);
			DebugLocation(374, 46);
			string_literal212=(CommonToken)Match(input,106,Follow._106_in_ifExp2635); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_106.Add(string_literal212);

			DebugLocation(374, 53);
			PushFollow(Follow._oclExpression_in_ifExp2637);
			oclExpression213=oclExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_oclExpression.Add(oclExpression213.Tree);
			DebugLocation(374, 67);
			string_literal214=(CommonToken)Match(input,107,Follow._107_in_ifExp2639); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_107.Add(string_literal214);



			{
			// AST REWRITE
			// elements: oclExpression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 374:75: -> ^( IF[$i] ( oclExpression )+ )
			{
				DebugLocation(374, 78);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:374:78: ^( IF[$i] ( oclExpression )+ )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(374, 80);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(IF, i), root_1);

				DebugLocation(374, 87);
				if (!(stream_oclExpression.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_oclExpression.HasNext )
				{
					DebugLocation(374, 87);
					adaptor.AddChild(root_1, stream_oclExpression.NextTree());

				}
				stream_oclExpression.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (CommonToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("ifExp", 59);
			LeaveRule("ifExp", 59);
			LeaveRule_ifExp();
		}
		DebugLocation(375, 1);
		} finally { DebugExitRule(GrammarFileName, "ifExp"); }
		return retval;

	}
	// $ANTLR end "ifExp"

	partial void EnterRule_synpred1_OCLSyntax_fragment();
	partial void LeaveRule_synpred1_OCLSyntax_fragment();

	// $ANTLR start synpred1_OCLSyntax
	public void synpred1_OCLSyntax_fragment()
	{
		EnterRule_synpred1_OCLSyntax_fragment();
		EnterRule("synpred1_OCLSyntax_fragment", 60);
		TraceIn("synpred1_OCLSyntax_fragment", 60);
		try
		{
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:184:6: ( SimpleName ( ( ':' ) type )? ';' )
			DebugEnterAlt(1);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:184:7: SimpleName ( ( ':' ) type )? ';'
			{
			DebugLocation(184, 7);
			Match(input,SimpleName,Follow._SimpleName_in_synpred1_OCLSyntax1409); if (state.failed) return;
			DebugLocation(184, 18);
			// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:184:18: ( ( ':' ) type )?
			int alt77=2;
			try { DebugEnterSubRule(77);
			try { DebugEnterDecision(77, false);
			int LA77_0 = input.LA(1);

			if ((LA77_0==71))
			{
				alt77 = 1;
			}
			} finally { DebugExitDecision(77); }
			switch (alt77)
			{
			case 1:
				DebugEnterAlt(1);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:184:19: ( ':' ) type
				{
				DebugLocation(184, 19);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:184:19: ( ':' )
				DebugEnterAlt(1);
				// ..\\..\\Model\\OCL\\Grammar\\OCLSyntax.g3:184:20: ':'
				{
				DebugLocation(184, 20);
				Match(input,71,Follow._71_in_synpred1_OCLSyntax1413); if (state.failed) return;

				}

				DebugLocation(184, 25);
				PushFollow(Follow._type_in_synpred1_OCLSyntax1416);
				type();
				PopFollow();
				if (state.failed) return;

				}
				break;

			}
			} finally { DebugExitSubRule(77); }

			DebugLocation(184, 32);
			Match(input,73,Follow._73_in_synpred1_OCLSyntax1420); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred1_OCLSyntax_fragment", 60);
			LeaveRule("synpred1_OCLSyntax_fragment", 60);
			LeaveRule_synpred1_OCLSyntax_fragment();
		}
	}
	// $ANTLR end synpred1_OCLSyntax
	#endregion Rules

	#region Synpreds
	private bool EvaluatePredicate(System.Action fragment)
	{
		bool success = false;
		state.backtracking++;
		try { DebugBeginBacktrack(state.backtracking);
		int start = input.Mark();
		try
		{
			fragment();
		}
		catch ( RecognitionException re )
		{
			System.Console.Error.WriteLine("impossible: "+re);
		}
		success = !state.failed;
		input.Rewind(start);
		} finally { DebugEndBacktrack(state.backtracking, success); }
		state.backtracking--;
		state.failed=false;
		return success;
	}
	#endregion Synpreds


	#region DFA
	private DFA3 dfa3;
	private DFA4 dfa4;
	private DFA39 dfa39;

	protected override void InitDFAs()
	{
		base.InitDFAs();
		dfa3 = new DFA3( this );
		dfa4 = new DFA4( this );
		dfa39 = new DFA39( this );
	}

	private class DFA3 : DFA
	{
		private const string DFA3_eotS =
			"\xA\xFFFF";
		private const string DFA3_eofS =
			"\x2\xFFFF\x1\x3\x3\xFFFF\x1\x3\x2\xFFFF\x1\x3";
		private const string DFA3_minS =
			"\x1\x67\x1\x35\x1\x3F\x1\xFFFF\x1\x35\x1\xFFFF\x1\x3F\x1\xFFFF\x1\x35"+
			"\x1\x3F";
		private const string DFA3_maxS =
			"\x1\x67\x1\x35\x1\x7B\x1\xFFFF\x1\x35\x1\xFFFF\x1\x7B\x1\xFFFF\x1\x35"+
			"\x1\x7B";
		private const string DFA3_acceptS =
			"\x3\xFFFF\x1\x2\x1\xFFFF\x1\x3\x1\xFFFF\x1\x1\x2\xFFFF";
		private const string DFA3_specialS =
			"\xA\xFFFF}>";
		private static readonly string[] DFA3_transitionS =
			{
				"\x1\x1",
				"\x1\x2",
				"\x1\x5\x7\xFFFF\x1\x3\x1\x4\x1E\xFFFF\x2\x3\x8\xFFFF\x1\x3\x9\xFFFF"+
				"\x1\x3",
				"",
				"\x1\x6",
				"",
				"\x1\x5\x7\xFFFF\x1\x7\x1\x8\x1E\xFFFF\x2\x3\x8\xFFFF\x1\x3\x9\xFFFF"+
				"\x1\x3",
				"",
				"\x1\x9",
				"\x1\x5\x7\xFFFF\x1\x7\x1\x8\x1E\xFFFF\x2\x3\x8\xFFFF\x1\x3\x9\xFFFF"+
				"\x1\x3"
			};

		private static readonly short[] DFA3_eot = DFA.UnpackEncodedString(DFA3_eotS);
		private static readonly short[] DFA3_eof = DFA.UnpackEncodedString(DFA3_eofS);
		private static readonly char[] DFA3_min = DFA.UnpackEncodedStringToUnsignedChars(DFA3_minS);
		private static readonly char[] DFA3_max = DFA.UnpackEncodedStringToUnsignedChars(DFA3_maxS);
		private static readonly short[] DFA3_accept = DFA.UnpackEncodedString(DFA3_acceptS);
		private static readonly short[] DFA3_special = DFA.UnpackEncodedString(DFA3_specialS);
		private static readonly short[][] DFA3_transition;

		static DFA3()
		{
			int numStates = DFA3_transitionS.Length;
			DFA3_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA3_transition[i] = DFA.UnpackEncodedString(DFA3_transitionS[i]);
			}
		}

		public DFA3( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 3;
			this.eot = DFA3_eot;
			this.eof = DFA3_eof;
			this.min = DFA3_min;
			this.max = DFA3_max;
			this.accept = DFA3_accept;
			this.special = DFA3_special;
			this.transition = DFA3_transition;
		}

		public override string Description { get { return "34:1: public contextDeclaration : ( propertyContextDecl | classifierContextDecl | operationContextDecl );"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA4 : DFA
	{
		private const string DFA4_eotS =
			"\xA\xFFFF";
		private const string DFA4_eofS =
			"\x2\xFFFF\x1\x3\x3\xFFFF\x1\x3\x2\xFFFF\x1\x3";
		private const string DFA4_minS =
			"\x1\x67\x1\x35\x1\x3F\x1\xFFFF\x1\x35\x1\xFFFF\x1\x3F\x1\xFFFF\x1\x35"+
			"\x1\x3F";
		private const string DFA4_maxS =
			"\x1\x67\x1\x35\x1\x7B\x1\xFFFF\x1\x35\x1\xFFFF\x1\x7B\x1\xFFFF\x1\x35"+
			"\x1\x7B";
		private const string DFA4_acceptS =
			"\x3\xFFFF\x1\x2\x1\xFFFF\x1\x3\x1\xFFFF\x1\x1\x2\xFFFF";
		private const string DFA4_specialS =
			"\xA\xFFFF}>";
		private static readonly string[] DFA4_transitionS =
			{
				"\x1\x1",
				"\x1\x2",
				"\x1\x5\x7\xFFFF\x1\x3\x1\x4\x1E\xFFFF\x2\x3\x8\xFFFF\x1\x3\x9\xFFFF"+
				"\x1\x3",
				"",
				"\x1\x6",
				"",
				"\x1\x5\x7\xFFFF\x1\x7\x1\x8\x1E\xFFFF\x2\x3\x8\xFFFF\x1\x3\x9\xFFFF"+
				"\x1\x3",
				"",
				"\x1\x9",
				"\x1\x5\x7\xFFFF\x1\x7\x1\x8\x1E\xFFFF\x2\x3\x8\xFFFF\x1\x3\x9\xFFFF"+
				"\x1\x3"
			};

		private static readonly short[] DFA4_eot = DFA.UnpackEncodedString(DFA4_eotS);
		private static readonly short[] DFA4_eof = DFA.UnpackEncodedString(DFA4_eofS);
		private static readonly char[] DFA4_min = DFA.UnpackEncodedStringToUnsignedChars(DFA4_minS);
		private static readonly char[] DFA4_max = DFA.UnpackEncodedStringToUnsignedChars(DFA4_maxS);
		private static readonly short[] DFA4_accept = DFA.UnpackEncodedString(DFA4_acceptS);
		private static readonly short[] DFA4_special = DFA.UnpackEncodedString(DFA4_specialS);
		private static readonly short[][] DFA4_transition;

		static DFA4()
		{
			int numStates = DFA4_transitionS.Length;
			DFA4_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA4_transition[i] = DFA.UnpackEncodedString(DFA4_transitionS[i]);
			}
		}

		public DFA4( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 4;
			this.eot = DFA4_eot;
			this.eof = DFA4_eof;
			this.min = DFA4_min;
			this.max = DFA4_max;
			this.accept = DFA4_accept;
			this.special = DFA4_special;
			this.transition = DFA4_transition;
		}

		public override string Description { get { return "41:1: public contextDeclarationE : ( propertyContextDecl | classifierContextDecl | operationContextDecl );"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA39 : DFA
	{
		private const string DFA39_eotS =
			"\xB\xFFFF";
		private const string DFA39_eofS =
			"\xB\xFFFF";
		private const string DFA39_minS =
			"\x1\x21\x1\xFFFF\x1\x3F\x8\xFFFF";
		private const string DFA39_maxS =
			"\x1\x7D\x1\xFFFF\x1\x7F\x8\xFFFF";
		private const string DFA39_acceptS =
			"\x1\xFFFF\x1\x1\x1\xFFFF\x1\x3\x1\x4\x1\x5\x1\x6\x1\x7\x1\x8\x1\x9\x1"+
			"\x2";
		private const string DFA39_specialS =
			"\xB\xFFFF}>";
		private static readonly string[] DFA39_transitionS =
			{
				"\x2\x4\x6\xFFFF\x1\x4\xA\xFFFF\x1\x4\x1\x6\x1\xFFFF\x1\x4\x3\xFFFF\x1"+
				"\x4\x3\xFFFF\x1\x7\x12\xFFFF\x1\x1\x1\x5\x1\x1\x5\x5\x1\x1\x1\x5\x2"+
				"\x1\x1\x5\x1\x2\x1\x5\xB\xFFFF\x1\x4\x1\x8\x4\xFFFF\x1\x6\x1\x9\x1\xFFFF"+
				"\x1\x3\x7\xFFFF\x1\x4",
				"",
				"\x1\x5\x3F\xFFFF\x1\xA",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				""
			};

		private static readonly short[] DFA39_eot = DFA.UnpackEncodedString(DFA39_eotS);
		private static readonly short[] DFA39_eof = DFA.UnpackEncodedString(DFA39_eofS);
		private static readonly char[] DFA39_min = DFA.UnpackEncodedStringToUnsignedChars(DFA39_minS);
		private static readonly char[] DFA39_max = DFA.UnpackEncodedStringToUnsignedChars(DFA39_maxS);
		private static readonly short[] DFA39_accept = DFA.UnpackEncodedString(DFA39_acceptS);
		private static readonly short[] DFA39_special = DFA.UnpackEncodedString(DFA39_specialS);
		private static readonly short[][] DFA39_transition;

		static DFA39()
		{
			int numStates = DFA39_transitionS.Length;
			DFA39_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA39_transition[i] = DFA.UnpackEncodedString(DFA39_transitionS[i]);
			}
		}

		public DFA39( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 39;
			this.eot = DFA39_eot;
			this.eof = DFA39_eof;
			this.min = DFA39_min;
			this.max = DFA39_max;
			this.accept = DFA39_accept;
			this.special = DFA39_special;
			this.transition = DFA39_transition;
		}

		public override string Description { get { return "155:1: primaryExperession : ( collectionLiteralExpAndType | tupleLiteralExp | classLiteralExp | primitiveLiteralExp -> ^( PRIMITIVELITERAL primitiveLiteralExp ) | enumAndType -> ^( TYPE enumAndType ) | propertyCall | '(' oclExpression ')' | ifExp | letExp );"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}


	#endregion DFA

	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _122_in_evolutionDeclarationList175 = new BitSet(new ulong[]{0x20000000000000UL});
		public static readonly BitSet _SimpleName_in_evolutionDeclarationList177 = new BitSet(new ulong[]{0x0UL,0x8000000000UL});
		public static readonly BitSet _contextDeclarationE_in_evolutionDeclarationList179 = new BitSet(new ulong[]{0x0UL,0x8000000000UL});
		public static readonly BitSet _EOF_in_evolutionDeclarationList182 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _contextDeclaration_in_contextDeclarationList206 = new BitSet(new ulong[]{0x0UL,0x8000000000UL});
		public static readonly BitSet _EOF_in_contextDeclarationList209 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _propertyContextDecl_in_contextDeclaration231 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _classifierContextDecl_in_contextDeclaration235 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _operationContextDecl_in_contextDeclaration239 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _propertyContextDecl_in_contextDeclarationE252 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _classifierContextDecl_in_contextDeclarationE256 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _operationContextDecl_in_contextDeclarationE260 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _propertyContextHead_in_propertyContextDecl270 = new BitSet(new ulong[]{0x2UL,0x1020000000000UL});
		public static readonly BitSet _initOrDerValue_in_propertyContextDecl272 = new BitSet(new ulong[]{0x2UL,0x1020000000000UL});
		public static readonly BitSet _103_in_propertyContextHead295 = new BitSet(new ulong[]{0x20000000000000UL});
		public static readonly BitSet _SimpleName_in_propertyContextHead297 = new BitSet(new ulong[]{0x0UL,0x100UL});
		public static readonly BitSet _72_in_propertyContextHead300 = new BitSet(new ulong[]{0x20000000000000UL});
		public static readonly BitSet _SimpleName_in_propertyContextHead302 = new BitSet(new ulong[]{0x0UL,0x100UL});
		public static readonly BitSet _72_in_propertyContextHead306 = new BitSet(new ulong[]{0x20000000000000UL});
		public static readonly BitSet _SimpleName_in_propertyContextHead308 = new BitSet(new ulong[]{0x0UL,0x80UL});
		public static readonly BitSet _71_in_propertyContextHead310 = new BitSet(new ulong[]{0x20000000000000UL,0x1FFFC0000UL});
		public static readonly BitSet _type_in_propertyContextHead312 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _operationContextHead_in_operationContextDecl336 = new BitSet(new ulong[]{0x2UL,0x300004000000000UL});
		public static readonly BitSet _prePostOrBodyDecl_in_operationContextDecl338 = new BitSet(new ulong[]{0x2UL,0x300004000000000UL});
		public static readonly BitSet _103_in_operationContextHead361 = new BitSet(new ulong[]{0x20000000000000UL});
		public static readonly BitSet _operation_in_operationContextHead363 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _classifierContextHead_in_classifierContextDecl381 = new BitSet(new ulong[]{0x2UL,0x802010000000000UL});
		public static readonly BitSet _invOrDef_in_classifierContextDecl384 = new BitSet(new ulong[]{0x2UL,0x802010000000000UL});
		public static readonly BitSet _103_in_classifierContextHead409 = new BitSet(new ulong[]{0x20000000000000UL});
		public static readonly BitSet _pathName_in_classifierContextHead411 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _103_in_classifierContextHead427 = new BitSet(new ulong[]{0x20000000000000UL});
		public static readonly BitSet _SimpleName_in_classifierContextHead429 = new BitSet(new ulong[]{0x0UL,0x80UL});
		public static readonly BitSet _71_in_classifierContextHead430 = new BitSet(new ulong[]{0x20000000000000UL});
		public static readonly BitSet _pathName_in_classifierContextHead431 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _112_in_initOrDerValue454 = new BitSet(new ulong[]{0x0UL,0x80UL});
		public static readonly BitSet _71_in_initOrDerValue456 = new BitSet(new ulong[]{0x88B0020600000000UL,0x206C3001FFFC0008UL});
		public static readonly BitSet _oclExpression_in_initOrDerValue458 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _105_in_initOrDerValue473 = new BitSet(new ulong[]{0x0UL,0x80UL});
		public static readonly BitSet _71_in_initOrDerValue475 = new BitSet(new ulong[]{0x88B0020600000000UL,0x206C3001FFFC0008UL});
		public static readonly BitSet _oclExpression_in_initOrDerValue477 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _113_in_invOrDef497 = new BitSet(new ulong[]{0x20000000000000UL,0x80UL});
		public static readonly BitSet _SimpleName_in_invOrDef500 = new BitSet(new ulong[]{0x0UL,0x80UL});
		public static readonly BitSet _71_in_invOrDef505 = new BitSet(new ulong[]{0x88B0020600000000UL,0x206C3001FFFC0008UL});
		public static readonly BitSet _oclExpression_in_invOrDef507 = new BitSet(new ulong[]{0x2UL,0x10000000000000UL});
		public static readonly BitSet _116_in_invOrDef515 = new BitSet(new ulong[]{0x0UL,0x80UL});
		public static readonly BitSet _71_in_invOrDef517 = new BitSet(new ulong[]{0x88B0020600000000UL,0x206C3001FFFC0008UL});
		public static readonly BitSet _oclExpression_in_invOrDef523 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _123_in_invOrDef553 = new BitSet(new ulong[]{0x0UL,0x10000000000UL});
		public static readonly BitSet _104_in_invOrDef558 = new BitSet(new ulong[]{0x20000000000000UL,0x80UL});
		public static readonly BitSet _SimpleName_in_invOrDef560 = new BitSet(new ulong[]{0x0UL,0x80UL});
		public static readonly BitSet _71_in_invOrDef563 = new BitSet(new ulong[]{0x20000000000000UL});
		public static readonly BitSet _defExpression_in_invOrDef565 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _121_in_prePostOrBodyDecl596 = new BitSet(new ulong[]{0x20000000000000UL,0x80UL});
		public static readonly BitSet _SimpleName_in_prePostOrBodyDecl599 = new BitSet(new ulong[]{0x0UL,0x80UL});
		public static readonly BitSet _71_in_prePostOrBodyDecl603 = new BitSet(new ulong[]{0x88B0020600000000UL,0x206C3001FFFC0008UL});
		public static readonly BitSet _oclExpression_in_prePostOrBodyDecl605 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _120_in_prePostOrBodyDecl622 = new BitSet(new ulong[]{0x20000000000000UL,0x80UL});
		public static readonly BitSet _SimpleName_in_prePostOrBodyDecl625 = new BitSet(new ulong[]{0x0UL,0x80UL});
		public static readonly BitSet _71_in_prePostOrBodyDecl629 = new BitSet(new ulong[]{0x88B0020600000000UL,0x206C3001FFFC0008UL});
		public static readonly BitSet _oclExpression_in_prePostOrBodyDecl631 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _102_in_prePostOrBodyDecl648 = new BitSet(new ulong[]{0x20000000000000UL,0x80UL});
		public static readonly BitSet _SimpleName_in_prePostOrBodyDecl651 = new BitSet(new ulong[]{0x0UL,0x80UL});
		public static readonly BitSet _71_in_prePostOrBodyDecl655 = new BitSet(new ulong[]{0x88B0020600000000UL,0x206C3001FFFC0008UL});
		public static readonly BitSet _oclExpression_in_prePostOrBodyDecl657 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _pathName_in_operation679 = new BitSet(new ulong[]{0x8000000000000000UL});
		public static readonly BitSet _63_in_operation683 = new BitSet(new ulong[]{0x20000000000000UL,0x1UL});
		public static readonly BitSet _parameters_in_operation685 = new BitSet(new ulong[]{0x0UL,0x1UL});
		public static readonly BitSet _64_in_operation688 = new BitSet(new ulong[]{0x2UL,0x80UL});
		public static readonly BitSet _71_in_operation691 = new BitSet(new ulong[]{0x20000000000000UL,0x1FFFC0000UL});
		public static readonly BitSet _type_in_operation693 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _variableDeclarationList_in_parameters721 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _variableDeclaration_in_defExpression734 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _operation_in_defExpression740 = new BitSet(new ulong[]{0x0UL,0x2000UL});
		public static readonly BitSet _77_in_defExpression742 = new BitSet(new ulong[]{0x88B0020600000000UL,0x206C3001FFFC0008UL});
		public static readonly BitSet _oclExpression_in_defExpression744 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _logicalImpliesExpression_in_oclExpression768 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _logicalXorExpression_in_logicalImpliesExpression784 = new BitSet(new ulong[]{0x2UL,0x400000000000UL});
		public static readonly BitSet _110_in_logicalImpliesExpression793 = new BitSet(new ulong[]{0x88B0020600000000UL,0x206C3001FFFC0008UL});
		public static readonly BitSet _logicalXorExpression_in_logicalImpliesExpression797 = new BitSet(new ulong[]{0x2UL,0x400000000000UL});
		public static readonly BitSet _logicalOrExpression_in_logicalXorExpression822 = new BitSet(new ulong[]{0x2UL,0x4000000000000000UL});
		public static readonly BitSet _126_in_logicalXorExpression830 = new BitSet(new ulong[]{0x88B0020600000000UL,0x206C3001FFFC0008UL});
		public static readonly BitSet _logicalOrExpression_in_logicalXorExpression834 = new BitSet(new ulong[]{0x2UL,0x4000000000000000UL});
		public static readonly BitSet _logicalAndExpression_in_logicalOrExpression858 = new BitSet(new ulong[]{0x2UL,0x80000000000000UL});
		public static readonly BitSet _119_in_logicalOrExpression866 = new BitSet(new ulong[]{0x88B0020600000000UL,0x206C3001FFFC0008UL});
		public static readonly BitSet _logicalAndExpression_in_logicalOrExpression870 = new BitSet(new ulong[]{0x2UL,0x80000000000000UL});
		public static readonly BitSet _relationalEqExpression_in_logicalAndExpression894 = new BitSet(new ulong[]{0x2UL,0x2000000000UL});
		public static readonly BitSet _101_in_logicalAndExpression903 = new BitSet(new ulong[]{0x88B0020600000000UL,0x206C3001FFFC0008UL});
		public static readonly BitSet _relationalEqExpression_in_logicalAndExpression907 = new BitSet(new ulong[]{0x2UL,0x2000000000UL});
		public static readonly BitSet _relationalNotEqExprassion_in_relationalEqExpression932 = new BitSet(new ulong[]{0x2UL,0x3000UL});
		public static readonly BitSet _77_in_relationalEqExpression941 = new BitSet(new ulong[]{0x88B0020600000000UL,0x206C3001FFFC0008UL});
		public static readonly BitSet _76_in_relationalEqExpression945 = new BitSet(new ulong[]{0x88B0020600000000UL,0x206C3001FFFC0008UL});
		public static readonly BitSet _relationalNotEqExprassion_in_relationalEqExpression950 = new BitSet(new ulong[]{0x2UL,0x3000UL});
		public static readonly BitSet _additiveExpression_in_relationalNotEqExprassion977 = new BitSet(new ulong[]{0x2UL,0xCC00UL});
		public static readonly BitSet _74_in_relationalNotEqExprassion987 = new BitSet(new ulong[]{0x88B0020600000000UL,0x206C3001FFFC0008UL});
		public static readonly BitSet _78_in_relationalNotEqExprassion992 = new BitSet(new ulong[]{0x88B0020600000000UL,0x206C3001FFFC0008UL});
		public static readonly BitSet _75_in_relationalNotEqExprassion997 = new BitSet(new ulong[]{0x88B0020600000000UL,0x206C3001FFFC0008UL});
		public static readonly BitSet _79_in_relationalNotEqExprassion1002 = new BitSet(new ulong[]{0x88B0020600000000UL,0x206C3001FFFC0008UL});
		public static readonly BitSet _additiveExpression_in_relationalNotEqExprassion1007 = new BitSet(new ulong[]{0x2UL,0xCC00UL});
		public static readonly BitSet _multiplicativeExpression_in_additiveExpression1033 = new BitSet(new ulong[]{0x2UL,0xAUL});
		public static readonly BitSet _65_in_additiveExpression1042 = new BitSet(new ulong[]{0x88B0020600000000UL,0x206C3001FFFC0008UL});
		public static readonly BitSet _67_in_additiveExpression1046 = new BitSet(new ulong[]{0x88B0020600000000UL,0x206C3001FFFC0008UL});
		public static readonly BitSet _multiplicativeExpression_in_additiveExpression1052 = new BitSet(new ulong[]{0x2UL,0xAUL});
		public static readonly BitSet _unaryExpression_in_multiplicativeExpression1079 = new BitSet(new ulong[]{0x800000000000002UL,0x40UL});
		public static readonly BitSet _UnlimitedNaturalLiteralExp_in_multiplicativeExpression1088 = new BitSet(new ulong[]{0x88B0020600000000UL,0x206C3001FFFC0008UL});
		public static readonly BitSet _70_in_multiplicativeExpression1092 = new BitSet(new ulong[]{0x88B0020600000000UL,0x206C3001FFFC0008UL});
		public static readonly BitSet _unaryExpression_in_multiplicativeExpression1097 = new BitSet(new ulong[]{0x800000000000002UL,0x40UL});
		public static readonly BitSet _67_in_unaryExpression1125 = new BitSet(new ulong[]{0x88B0020600000000UL,0x206C3001FFFC0008UL});
		public static readonly BitSet _118_in_unaryExpression1129 = new BitSet(new ulong[]{0x88B0020600000000UL,0x206C3001FFFC0008UL});
		public static readonly BitSet _termExpression_in_unaryExpression1134 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _termExpression_in_unaryExpression1148 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _primaryExperession_in_termExpression1162 = new BitSet(new ulong[]{0x2UL,0x1800000030UL});
		public static readonly BitSet _69_in_termExpression1173 = new BitSet(new ulong[]{0x20000000000000UL,0x4000000000000UL});
		public static readonly BitSet _68_in_termExpression1177 = new BitSet(new ulong[]{0x20000000000000UL,0x4000000000000UL});
		public static readonly BitSet _propertyCall_in_termExpression1182 = new BitSet(new ulong[]{0x2UL,0x1800000030UL});
		public static readonly BitSet _oclMessageExp_in_termExpression1206 = new BitSet(new ulong[]{0x2UL,0x1800000030UL});
		public static readonly BitSet _collectionLiteralExpAndType_in_primaryExperession1248 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _tupleLiteralExp_in_primaryExperession1256 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _classLiteralExp_in_primaryExperession1262 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _primitiveLiteralExp_in_primaryExperession1269 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _enumAndType_in_primaryExperession1287 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _propertyCall_in_primaryExperession1303 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _63_in_primaryExperession1308 = new BitSet(new ulong[]{0x88B0020600000000UL,0x206C3001FFFC0008UL});
		public static readonly BitSet _oclExpression_in_primaryExperession1310 = new BitSet(new ulong[]{0x0UL,0x1UL});
		public static readonly BitSet _64_in_primaryExperession1311 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ifExp_in_primaryExperession1317 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _letExp_in_primaryExperession1322 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _pathName_in_propertyCall1332 = new BitSet(new ulong[]{0x8000000000000002UL,0x200020000UL});
		public static readonly BitSet _97_in_propertyCall1335 = new BitSet(new ulong[]{0x88B0020600000000UL,0x206C3001FFFC0008UL});
		public static readonly BitSet _arguments_in_propertyCall1336 = new BitSet(new ulong[]{0x0UL,0x400000000UL});
		public static readonly BitSet _98_in_propertyCall1337 = new BitSet(new ulong[]{0x8000000000000002UL,0x20000UL});
		public static readonly BitSet _isMarkedPre_in_propertyCall1341 = new BitSet(new ulong[]{0x8000000000000002UL});
		public static readonly BitSet _63_in_propertyCall1345 = new BitSet(new ulong[]{0x88B0020600000000UL,0x206C3001FFFC0009UL});
		public static readonly BitSet _propertyCallParametrs_in_propertyCall1346 = new BitSet(new ulong[]{0x0UL,0x1UL});
		public static readonly BitSet _64_in_propertyCall1347 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _114_in_propertyCall1396 = new BitSet(new ulong[]{0x8000000000000000UL});
		public static readonly BitSet _63_in_propertyCall1398 = new BitSet(new ulong[]{0x20000000000000UL});
		public static readonly BitSet _SimpleName_in_propertyCall1425 = new BitSet(new ulong[]{0x0UL,0x280UL});
		public static readonly BitSet _71_in_propertyCall1429 = new BitSet(new ulong[]{0x20000000000000UL,0x1FFFC0000UL});
		public static readonly BitSet _type_in_propertyCall1436 = new BitSet(new ulong[]{0x0UL,0x200UL});
		public static readonly BitSet _73_in_propertyCall1440 = new BitSet(new ulong[]{0x20000000000000UL});
		public static readonly BitSet _SimpleName_in_propertyCall1445 = new BitSet(new ulong[]{0x0UL,0x2080UL});
		public static readonly BitSet _71_in_propertyCall1448 = new BitSet(new ulong[]{0x20000000000000UL,0x1FFFC0000UL});
		public static readonly BitSet _type_in_propertyCall1454 = new BitSet(new ulong[]{0x0UL,0x2000UL});
		public static readonly BitSet _77_in_propertyCall1457 = new BitSet(new ulong[]{0x88B0020600000000UL,0x206C3001FFFC0008UL});
		public static readonly BitSet _oclExpression_in_propertyCall1463 = new BitSet(new ulong[]{0x0UL,0x0UL,0x1UL});
		public static readonly BitSet _SimpleName_in_propertyCall1479 = new BitSet(new ulong[]{0x0UL,0x2080UL});
		public static readonly BitSet _71_in_propertyCall1482 = new BitSet(new ulong[]{0x20000000000000UL,0x1FFFC0000UL});
		public static readonly BitSet _type_in_propertyCall1487 = new BitSet(new ulong[]{0x0UL,0x2000UL});
		public static readonly BitSet _77_in_propertyCall1490 = new BitSet(new ulong[]{0x88B0020600000000UL,0x206C3001FFFC0008UL});
		public static readonly BitSet _oclExpression_in_propertyCall1496 = new BitSet(new ulong[]{0x0UL,0x0UL,0x1UL});
		public static readonly BitSet _128_in_propertyCall1508 = new BitSet(new ulong[]{0x88B0020600000000UL,0x206C3001FFFC0008UL});
		public static readonly BitSet _oclExpression_in_propertyCall1514 = new BitSet(new ulong[]{0x0UL,0x1UL});
		public static readonly BitSet _64_in_propertyCall1516 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _declarePropertyCallParametrs_in_propertyCallParametrs1572 = new BitSet(new ulong[]{0x88B0020600000002UL,0x206C3001FFFC0008UL});
		public static readonly BitSet _arguments_in_propertyCallParametrs1575 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _typedef_in_declarePropertyCallParametrs1609 = new BitSet(new ulong[]{0x0UL,0x4UL,0x1UL});
		public static readonly BitSet _66_in_declarePropertyCallParametrs1612 = new BitSet(new ulong[]{0x20000000000000UL});
		public static readonly BitSet _typedef_in_declarePropertyCallParametrs1616 = new BitSet(new ulong[]{0x0UL,0x0UL,0x1UL});
		public static readonly BitSet _128_in_declarePropertyCallParametrs1620 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SimpleName_in_typedef1648 = new BitSet(new ulong[]{0x2UL,0x80UL});
		public static readonly BitSet _71_in_typedef1650 = new BitSet(new ulong[]{0x20000000000000UL,0x1FFFC0000UL});
		public static readonly BitSet _type_in_typedef1651 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _tupleType_in_enumAndType1688 = new BitSet(new ulong[]{0x0UL,0x80000000UL});
		public static readonly BitSet _tupleType_in_enumAndType1696 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _primitiveType_in_enumAndType1701 = new BitSet(new ulong[]{0x0UL,0x148280000UL});
		public static readonly BitSet _primitiveType_in_enumAndType1706 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _oclType_in_enumAndType1711 = new BitSet(new ulong[]{0x20000000000000UL,0x1FFFC0000UL});
		public static readonly BitSet _oclType_in_enumAndType1715 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SimpleName_in_pathName1732 = new BitSet(new ulong[]{0x2UL,0x100UL});
		public static readonly BitSet _72_in_pathName1735 = new BitSet(new ulong[]{0x20000000000000UL});
		public static readonly BitSet _SimpleName_in_pathName1737 = new BitSet(new ulong[]{0x2UL,0x100UL});
		public static readonly BitSet _collectionTypeIdentifier_in_collectionLiteralExpAndType1766 = new BitSet(new ulong[]{0x2UL,0x8000000000000000UL});
		public static readonly BitSet _127_in_collectionLiteralExpAndType1769 = new BitSet(new ulong[]{0x88B0020600000000UL,0x206C3001FFFC0008UL,0x2UL});
		public static readonly BitSet _collectionLiteralParts_in_collectionLiteralExpAndType1771 = new BitSet(new ulong[]{0x0UL,0x0UL,0x2UL});
		public static readonly BitSet _129_in_collectionLiteralExpAndType1774 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _collectionTypeIdentifier_in_collectionLiteralExpAndType1796 = new BitSet(new ulong[]{0x8000000000000000UL});
		public static readonly BitSet _63_in_collectionLiteralExpAndType1799 = new BitSet(new ulong[]{0x20000000000000UL,0x1FFFC0000UL});
		public static readonly BitSet _type_in_collectionLiteralExpAndType1801 = new BitSet(new ulong[]{0x0UL,0x1UL});
		public static readonly BitSet _64_in_collectionLiteralExpAndType1804 = new BitSet(new ulong[]{0x2UL,0x8000000000000000UL});
		public static readonly BitSet _127_in_collectionLiteralExpAndType1814 = new BitSet(new ulong[]{0x88B0020600000000UL,0x206C3001FFFC0008UL,0x2UL});
		public static readonly BitSet _collectionLiteralParts_in_collectionLiteralExpAndType1816 = new BitSet(new ulong[]{0x0UL,0x0UL,0x2UL});
		public static readonly BitSet _129_in_collectionLiteralExpAndType1819 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _pathName_in_enumLiteralExp1867 = new BitSet(new ulong[]{0x0UL,0x100UL});
		public static readonly BitSet _72_in_enumLiteralExp1868 = new BitSet(new ulong[]{0x20000000000000UL});
		public static readonly BitSet _SimpleName_in_enumLiteralExp1870 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _collectionTypeIdentifier_in_collectionLiteralExp1882 = new BitSet(new ulong[]{0x0UL,0x8000000000000000UL});
		public static readonly BitSet _127_in_collectionLiteralExp1885 = new BitSet(new ulong[]{0x88B0020600000000UL,0x206C3001FFFC0008UL,0x2UL});
		public static readonly BitSet _collectionLiteralParts_in_collectionLiteralExp1887 = new BitSet(new ulong[]{0x0UL,0x0UL,0x2UL});
		public static readonly BitSet _129_in_collectionLiteralExp1890 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _collectionType_in_collectionLiteralExp1894 = new BitSet(new ulong[]{0x0UL,0x8000000000000000UL});
		public static readonly BitSet _127_in_collectionLiteralExp1896 = new BitSet(new ulong[]{0x88B0020600000000UL,0x206C3001FFFC0008UL,0x2UL});
		public static readonly BitSet _collectionLiteralParts_in_collectionLiteralExp1898 = new BitSet(new ulong[]{0x0UL,0x0UL,0x2UL});
		public static readonly BitSet _129_in_collectionLiteralExp1901 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _set_in_collectionTypeIdentifier1917 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _collectionLiteralPart_in_collectionLiteralParts1948 = new BitSet(new ulong[]{0x2UL,0x4UL});
		public static readonly BitSet _66_in_collectionLiteralParts1952 = new BitSet(new ulong[]{0x88B0020600000000UL,0x206C3001FFFC0008UL});
		public static readonly BitSet _collectionLiteralPart_in_collectionLiteralParts1955 = new BitSet(new ulong[]{0x2UL,0x4UL});
		public static readonly BitSet _oclExpression_in_collectionLiteralPart1972 = new BitSet(new ulong[]{0x400002UL});
		public static readonly BitSet _DoubleDot_in_collectionLiteralPart1976 = new BitSet(new ulong[]{0x88B0020600000000UL,0x206C3001FFFC0008UL});
		public static readonly BitSet _oclExpression_in_collectionLiteralPart1980 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _set_in_primitiveLiteralExp2012 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _95_in_tupleLiteralExp2068 = new BitSet(new ulong[]{0x0UL,0x8000000000000000UL});
		public static readonly BitSet _127_in_tupleLiteralExp2070 = new BitSet(new ulong[]{0x20000000000000UL});
		public static readonly BitSet _variableDeclarationList_in_tupleLiteralExp2072 = new BitSet(new ulong[]{0x0UL,0x0UL,0x2UL});
		public static readonly BitSet _129_in_tupleLiteralExp2075 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _117_in_classLiteralExp2099 = new BitSet(new ulong[]{0x20000000000000UL});
		public static readonly BitSet _pathName_in_classLiteralExp2101 = new BitSet(new ulong[]{0x0UL,0x8000000000000000UL});
		public static readonly BitSet _127_in_classLiteralExp2103 = new BitSet(new ulong[]{0x20000000000000UL});
		public static readonly BitSet _variableDeclarationList_in_classLiteralExp2105 = new BitSet(new ulong[]{0x0UL,0x0UL,0x2UL});
		public static readonly BitSet _129_in_classLiteralExp2108 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _type_in_typeLiteralExp2130 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SimpleName_in_variableDeclaration2145 = new BitSet(new ulong[]{0x0UL,0x80UL});
		public static readonly BitSet _71_in_variableDeclaration2147 = new BitSet(new ulong[]{0x20000000000000UL,0x1FFFC0000UL});
		public static readonly BitSet _type_in_variableDeclaration2149 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SimpleName_in_variableDeclaration2172 = new BitSet(new ulong[]{0x0UL,0x2080UL});
		public static readonly BitSet _71_in_variableDeclaration2175 = new BitSet(new ulong[]{0x20000000000000UL,0x1FFFC0000UL});
		public static readonly BitSet _type_in_variableDeclaration2177 = new BitSet(new ulong[]{0x0UL,0x2000UL});
		public static readonly BitSet _77_in_variableDeclaration2182 = new BitSet(new ulong[]{0x88B0020600000000UL,0x206C3001FFFC0008UL});
		public static readonly BitSet _oclExpression_in_variableDeclaration2184 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _pathName_in_type2213 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _collectionType_in_type2221 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _tupleType_in_type2227 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _primitiveType_in_type2234 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _oclType_in_type2241 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _set_in_primitiveType2255 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _set_in_oclType2305 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _collectionTypeIdentifier_in_collectionType2347 = new BitSet(new ulong[]{0x8000000000000000UL});
		public static readonly BitSet _63_in_collectionType2349 = new BitSet(new ulong[]{0x20000000000000UL,0x1FFFC0000UL});
		public static readonly BitSet _type_in_collectionType2351 = new BitSet(new ulong[]{0x0UL,0x1UL});
		public static readonly BitSet _64_in_collectionType2354 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _95_in_tupleType2379 = new BitSet(new ulong[]{0x8000000000000000UL});
		public static readonly BitSet _63_in_tupleType2382 = new BitSet(new ulong[]{0x20000000000000UL,0x1UL});
		public static readonly BitSet _variableDeclarationList_in_tupleType2385 = new BitSet(new ulong[]{0x0UL,0x1UL});
		public static readonly BitSet _64_in_tupleType2389 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _variableDeclaration_in_variableDeclarationList2405 = new BitSet(new ulong[]{0x2UL,0x4UL});
		public static readonly BitSet _66_in_variableDeclarationList2409 = new BitSet(new ulong[]{0x20000000000000UL});
		public static readonly BitSet _variableDeclaration_in_variableDeclarationList2412 = new BitSet(new ulong[]{0x2UL,0x4UL});
		public static readonly BitSet _81_in_isMarkedPre2428 = new BitSet(new ulong[]{0x0UL,0x200000000000000UL});
		public static readonly BitSet _121_in_isMarkedPre2431 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _oclExpression_in_arguments2447 = new BitSet(new ulong[]{0x2UL,0x4UL});
		public static readonly BitSet _66_in_arguments2452 = new BitSet(new ulong[]{0x88B0020600000000UL,0x206C3001FFFC0008UL});
		public static readonly BitSet _oclExpression_in_arguments2457 = new BitSet(new ulong[]{0x2UL,0x4UL});
		public static readonly BitSet _115_in_letExp2473 = new BitSet(new ulong[]{0x20000000000000UL});
		public static readonly BitSet _variableDeclaration_in_letExp2475 = new BitSet(new ulong[]{0x0UL,0x800000000004UL});
		public static readonly BitSet _letExpSub_in_letExp2478 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _66_in_letExpSub2500 = new BitSet(new ulong[]{0x20000000000000UL});
		public static readonly BitSet _variableDeclaration_in_letExpSub2502 = new BitSet(new ulong[]{0x0UL,0x800000000004UL});
		public static readonly BitSet _letExpSub_in_letExpSub2505 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _111_in_letExpSub2520 = new BitSet(new ulong[]{0x88B0020600000000UL,0x206C3001FFFC0008UL});
		public static readonly BitSet _oclExpression_in_letExpSub2531 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _100_in_oclMessageExp2547 = new BitSet(new ulong[]{0x20000000000000UL});
		public static readonly BitSet _SimpleName_in_oclMessageExp2549 = new BitSet(new ulong[]{0x8000000000000000UL});
		public static readonly BitSet _63_in_oclMessageExp2551 = new BitSet(new ulong[]{0x88B0020600000000UL,0x206C3001FFFD0009UL});
		public static readonly BitSet _oclMessageArguments_in_oclMessageExp2553 = new BitSet(new ulong[]{0x0UL,0x1UL});
		public static readonly BitSet _64_in_oclMessageExp2556 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _99_in_oclMessageExp2561 = new BitSet(new ulong[]{0x20000000000000UL});
		public static readonly BitSet _SimpleName_in_oclMessageExp2563 = new BitSet(new ulong[]{0x8000000000000000UL});
		public static readonly BitSet _63_in_oclMessageExp2565 = new BitSet(new ulong[]{0x88B0020600000000UL,0x206C3001FFFD0009UL});
		public static readonly BitSet _oclMessageArguments_in_oclMessageExp2567 = new BitSet(new ulong[]{0x0UL,0x1UL});
		public static readonly BitSet _64_in_oclMessageExp2570 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _oclMessageArg_in_oclMessageArguments2580 = new BitSet(new ulong[]{0x2UL,0x4UL});
		public static readonly BitSet _66_in_oclMessageArguments2584 = new BitSet(new ulong[]{0x88B0020600000000UL,0x206C3001FFFD0008UL});
		public static readonly BitSet _oclMessageArguments_in_oclMessageArguments2586 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _80_in_oclMessageArg2601 = new BitSet(new ulong[]{0x2UL,0x80UL});
		public static readonly BitSet _71_in_oclMessageArg2604 = new BitSet(new ulong[]{0x20000000000000UL,0x1FFFC0000UL});
		public static readonly BitSet _type_in_oclMessageArg2606 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _oclExpression_in_oclMessageArg2613 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _109_in_ifExp2627 = new BitSet(new ulong[]{0x88B0020600000000UL,0x206C3001FFFC0008UL});
		public static readonly BitSet _oclExpression_in_ifExp2629 = new BitSet(new ulong[]{0x0UL,0x1000000000000000UL});
		public static readonly BitSet _124_in_ifExp2631 = new BitSet(new ulong[]{0x88B0020600000000UL,0x206C3001FFFC0008UL});
		public static readonly BitSet _oclExpression_in_ifExp2633 = new BitSet(new ulong[]{0x0UL,0x40000000000UL});
		public static readonly BitSet _106_in_ifExp2635 = new BitSet(new ulong[]{0x88B0020600000000UL,0x206C3001FFFC0008UL});
		public static readonly BitSet _oclExpression_in_ifExp2637 = new BitSet(new ulong[]{0x0UL,0x80000000000UL});
		public static readonly BitSet _107_in_ifExp2639 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SimpleName_in_synpred1_OCLSyntax1409 = new BitSet(new ulong[]{0x0UL,0x280UL});
		public static readonly BitSet _71_in_synpred1_OCLSyntax1413 = new BitSet(new ulong[]{0x20000000000000UL,0x1FFFC0000UL});
		public static readonly BitSet _type_in_synpred1_OCLSyntax1416 = new BitSet(new ulong[]{0x0UL,0x200UL});
		public static readonly BitSet _73_in_synpred1_OCLSyntax1420 = new BitSet(new ulong[]{0x2UL});

	}
	#endregion Follow sets
}

} // namespace Exolutio.Model.OCL.Compiler
